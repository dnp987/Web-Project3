{"version":3,"sources":["webpack://dataForge/webpack/bootstrap","webpack://dataForge/./src/lib/series.ts","webpack://dataForge/./src/lib/dataframe.ts","webpack://dataForge/./src/index.ts","webpack://dataForge/./node_modules/dayjs/dayjs.min.js","webpack://dataForge/./src/lib/utils.ts","webpack://dataForge/./src/lib/index.ts","webpack://dataForge/./src/lib/iterators/array-iterator.ts","webpack://dataForge/./src/lib/iterables/empty-iterable.ts","webpack://dataForge/./src/lib/iterables/count-iterable.ts","webpack://dataForge/./src/lib/iterables/multi-iterable.ts","webpack://dataForge/./src/lib/iterables/select-iterable.ts","webpack://dataForge/./src/lib/iterables/select-many-iterable.ts","webpack://dataForge/./src/lib/iterables/take-iterable.ts","webpack://dataForge/./src/lib/iterables/take-while-iterable.ts","webpack://dataForge/./src/lib/iterables/where-iterable.ts","webpack://dataForge/./src/lib/iterables/concat-iterable.ts","webpack://dataForge/./src/lib/iterables/reverse-iterable.ts","webpack://dataForge/./src/lib/iterables/zip-iterable.ts","webpack://dataForge/./src/lib/iterables/distinct-iterable.ts","webpack://dataForge/./src/lib/iterables/ordered-iterable.ts","webpack://dataForge/./src/lib/iterables/extract-element-iterable.ts","webpack://dataForge/./src/lib/iterables/skip-iterable.ts","webpack://dataForge/./src/lib/iterables/skip-while-iterable.ts","webpack://dataForge/./node_modules/easy-table/table.js","webpack://dataForge/./node_modules/json5/dist/index.js","webpack://dataForge/./node_modules/papaparse/papaparse.min.js","webpack://dataForge/./src/lib/iterables/cached-iterator-iterable.ts","webpack://dataForge/./node_modules/dayjs/plugin/customParseFormat.js","webpack://dataForge/./src/lib/iterators/empty-iterator.ts","webpack://dataForge/./src/lib/iterators/count-iterator.ts","webpack://dataForge/./src/lib/iterators/multi-iterator.ts","webpack://dataForge/./src/lib/iterators/select-iterator.ts","webpack://dataForge/./src/lib/iterators/select-many-iterator.ts","webpack://dataForge/./src/lib/iterators/take-iterator.ts","webpack://dataForge/./src/lib/iterators/take-while-iterator.ts","webpack://dataForge/./src/lib/iterators/where-iterator.ts","webpack://dataForge/./src/lib/iterators/concat-iterator.ts","webpack://dataForge/./src/lib/iterables/series-window-iterable.ts","webpack://dataForge/./src/lib/iterators/series-window-iterator.ts","webpack://dataForge/./src/lib/iterators/zip-iterator.ts","webpack://dataForge/./src/lib/iterators/distinct-iterator.ts","webpack://dataForge/./src/lib/iterables/series-rolling-window-iterable.ts","webpack://dataForge/./src/lib/iterators/series-rolling-window-iterator.ts","webpack://dataForge/./src/lib/iterables/series-variable-window-iterable.ts","webpack://dataForge/./src/lib/iterators/series-variable-window-iterator.ts","webpack://dataForge/./src/lib/iterators/extract-element-iterator.ts","webpack://dataForge/./src/lib/iterators/skip-iterator.ts","webpack://dataForge/./src/lib/iterators/skip-while-iterator.ts","webpack://dataForge/./node_modules/wcwidth/index.js","webpack://dataForge/./node_modules/defaults/index.js","webpack://dataForge/./node_modules/clone/clone.js","webpack://dataForge/./node_modules/buffer/index.js","webpack://dataForge/(webpack)/buildin/global.js","webpack://dataForge/./node_modules/base64-js/index.js","webpack://dataForge/./node_modules/ieee754/index.js","webpack://dataForge/./node_modules/isarray/index.js","webpack://dataForge/./node_modules/wcwidth/combining.js","webpack://dataForge/./src/lib/iterables/dataframe-window-iterable.ts","webpack://dataForge/./src/lib/iterators/dataframe-window-iterator.ts","webpack://dataForge/./src/lib/iterables/csv-rows-iterable.ts","webpack://dataForge/./src/lib/iterators/csv-rows-iterator.ts","webpack://dataForge/./src/lib/iterables/dataframe-rolling-window-iterable.ts","webpack://dataForge/./src/lib/iterators/dataframe-rolling-window-iterator.ts","webpack://dataForge/./src/lib/iterables/dataframe-variable-window-iterable.ts","webpack://dataForge/./src/lib/iterators/dataframe-variable-window-iterator.ts","webpack://dataForge/./src/lib/iterables/repeat-iterable.ts","webpack://dataForge/./src/lib/iterators/repeat-iterator.ts","webpack://dataForge/./src/lib/iterables/tile-iterable.ts","webpack://dataForge/./src/lib/iterators/tile-iterator.ts","webpack://dataForge/./src/lib/iterables/ravel-iterable.ts","webpack://dataForge/./src/lib/iterators/ravel-iterator.ts","webpack://dataForge/./src/lib/iterables/column-names-iterable.ts","webpack://dataForge/./src/lib/iterators/column-names-iterator.ts","webpack://dataForge/./node_modules/typy/lib/index.js","webpack://dataForge/./node_modules/typy/lib/typy.js","webpack://dataForge/./node_modules/typy/lib/util.js","webpack://dataForge/./src/lib/iterators/cached-iterator.ts","webpack://dataForge/./node_modules/numeral/numeral.js","webpack://dataForge/./node_modules/util/util.js","webpack://dataForge/./node_modules/process/browser.js","webpack://dataForge/./node_modules/util/support/isBufferBrowser.js","webpack://dataForge/./node_modules/inherits/inherits_browser.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","empty_iterable_1","count_iterable_1","multi_iterable_1","select_iterable_1","select_many_iterable_1","take_iterable_1","take_while_iterable_1","where_iterable_1","concat_iterable_1","series_window_iterable_1","reverse_iterable_1","zip_iterable_1","distinct_iterable_1","series_rolling_window_iterable_1","series_variable_window_iterable_1","ordered_iterable_1","index_1","extract_element_iterable_1","skip_iterable_1","skip_while_iterable_1","easy_table_1","__importDefault","dataframe_1","dayjs_1","customParseFormat_1","default","extend","WhichIndex","utils_1","__1","numeral_1","cached_iterator_iterable_1","Series","config","this","configFn","content","indexedContent","configAsAny","undefined","getTypeCode","typeCode","isFunction","isIterator","initFromIterator","isIterable","initFromIterable","initFromConfig","initEmpty","iterator","CachedIteratorIterable","arr","index","defaultCountIterable","values","pairs","MultiIterable","isBaked","defaultEmptyIterable","input","isObject","next","isArray","checkIterable","fieldName","Error","ExtractElementIterable","baked","lazyInit","getContent","getRowByIndex","Map","_a","__values","_b","done","pair","set","cast","getIndex","_this","Index","withIndex","newIndex","select","resetIndex","merge","series","rowMap","numSeries","Array","from","length","seriesIndex","series_1","series_1_1","workingSeries","toPairs","has","mergedPairs","keys","map","sort","a","b","args","_i","arguments","concat","toArray","push","toObject","keySelector","valueSelector","toMap","transformer","SelectIterable","selectMany","flatMap","SelectManyIterable","outputPairs","transformed","window","period","whichIndex","isNumber","SeriesWindowIterable","End","rollingWindow","SeriesRollingWindowIterable","variableWindow","comparer","SeriesVariableWindowIterable","sequentialDistinct","selector","first","aggregate","seedOrSelector","skip","accum","reduce","reducer","seed","any","series_2","series_2_1","amountRange","max","min","proportionRange","last","percentRange","v","amountChange","proportionChange","percentChange","proportionRank","latestValue","head","filter","prevMomentum","count","percentRank","proportion","cumsum","working","__read","numValues","SkipIterable","skipWhile","predicate","SkipWhileIterable","skipUntil","take","numRows","TakeIterable","takeWhile","TakeWhileIterable","takeUntil","total","lastValue","at","none","toTake","Math","abs","tail","toSkip","where","WhereIterable","forEach","callback","all","startAt","indexValue","lessThan","getLessThan","endAt","lessThanOrEqualTo","getLessThanOrEqualTo","before","after","between","startIndexValue","endIndexValue","toString","header","rows","table","rowIndex","row","cellIndex","cell","newRow","parseInt","valueIndex","isString","parseInts","parseFloat","parseFloats","parseDate","formatString","toDate","parseDates","isDate","format","toStrings","bake","inflate","DataFrame","asNumberSeries","numberSeries","sum","numberSeries_1","numberSeries_1_1","average","mean","numberSeries_2","numberSeries_2_1","median","ordered","orderBy","floor","lookup","numberSeries_3","numberSeries_3_1","entries","sumOfSquares","sumOfSquaredDiffs","numberSeries_4","numberSeries_4_1","diffFromMean","variance","std","sqrt","standardize","sampleVariance","sampleStd","sampleStandardize","range","invert","counter","groupSequentialBy","group","replicate","reverse","ReverseIterable","distinct","DistinctIterable","groupBy","groups","groupMap","groupKey","existingGroup","newGroup","contents","ConcatIterable","concatInput","series_3","series_3_1","input_1","input_1_1","subInput","zip","zipper","firstSeries","upcast","ZipIterable","slice","apply","__spread","OrderedSeries","direction","Direction","Ascending","parent","orderByDescending","Descending","union","other","intersection","inner","outerSelector","innerSelector","outerValue","outerKey","innerValue","except","join","outerKeySelector","innerKeySelector","resultSelector","outer","innerMap","output","outer_1","outer_1_1","innerGroup","innerGroup_1","innerGroup_1_1","joinOuter","outerResult","innerResult","intersectionResults","joinOuterLeft","joinOuterRight","truncateStrings","maxLength","substring","round","numDecimalPlaces","toFixed","insertPair","appendPair","remove","fillGaps","generator","pairA","pairB","generatedRows","defaultIfEmpty","defaultSequence","detectTypes","totalValues","typeFrequencies","valueType","accumulated","typeInfo","columnNames","detectValues","valueFrequencies","valueInfo","bucket","numBuckets","console","warn","width","bucketMin","Value","Bucket","Min","Mid","Max","frequency","options","lower","upper","captureValues","Number","MAX_VALUE","MIN_VALUE","numberSeries_5","numberSeries_5_1","numGroups","interval","ceil","groupIndex","minValue","cumulative","beforeGroup","afterGroup","numberSeries_6","numberSeries_6_1","unshift","groups_1","groups_1_1","CountIterable","EmptyIterable","_super","valueSortSpecs","pairSortSpecs","sortLevel","parents","parents_1","parents_1_1","parentConfig","makeSortSpec","makePairsSelector","OrderedIterable","__extends","thenBy","thenByDescending","dataframe_window_iterable_1","csv_rows_iterable_1","dataframe_rolling_window_iterable_1","dataframe_variable_window_iterable_1","repeat_iterable_1","tile_iterable_1","ravel_iterable_1","column_names_iterable_1","json5_1","papaparse_1","firstResult","isCaseSensitive","initColumnNames","inputColumnNames","outputColumnNames","columnNamesMap","columnName","columnNames_1","columnNames_1_1","columnNameLwr","toLowerCase","columnNoMap","columnNames_2","columnNames_2_1","curColumnNo","columns","columnsConfig","iterableColumnsConfig","column","columnIterables","columnNames_3","columnNames_3_1","columnConfig","CsvRowsIterable","caseSensitive","ColumnNamesIterable","considerAllRows","getColumnNames","getColumns","getSeries","firstValue","type","determineType","setIndex","deflate","hasSeries","expectSeries","withSeries","columnNameOrSpec","isUndefined","columnSpec","workingDataFrame","columnNames_4","columnNames_4_1","columnName_1","importSeries","seriesValueMap","toMap2","makeDistinct","modified","assign","dataFrames","resultIsCaseSensitive","dataFrames_1","dataFrames_1_1","dataFrame","clone","allColumnNames","prev","newColumnNames","otherDataFrames","ensureSeries","columnNames_5","columnNames_5_1","columnName_2","subset","columnNames_6","columnNames_6_1","columnNames_7","columnNames_7_1","dropSeries","columnOrColumns","indexOf","columnOrColumns_1","columnOrColumns_1_1","columnOrColumns_2","columnOrColumns_2_1","reorderSeries","columnNames_8","columnNames_8_1","columnNames_9","columnNames_9_1","columnNames_10","columnNames_10_1","bringToFront","columnOrColumns_3","columnOrColumns_3_1","existingColumns","columnsToMove","columnOrColumns_4","columnOrColumns_4_1","columnToMove","untouchedColumnNames","existingColumns_1","existingColumns_1_1","existingColumnName","bringToBack","columnOrColumns_5","columnOrColumns_5_1","columnOrColumns_6","columnOrColumns_6_1","existingColumns_2","existingColumns_2_1","renameSeries","existingColumnsToRename","existingColumnsToRename_1","existingColumnsToRename_1_1","renamedColumns","remapValue","existingColumnsToRename_2","existingColumnsToRename_2_1","existingColumName","toRows","columnIndex","transformSeries","columnSelectors","generateSeries","columnTransformSpec","newColumnNames_2","newColumnNames_2_1","newColumnName","newColumns","newColumnNames_1","newColumnNames_1_1","inflateSeries","row1","row2","DataFrameWindowIterable","DataFrameRollingWindowIterable","DataFrameVariableWindowIterable","columnAggregateSpec_1","aggregatedColumns","columnSelector","dataframe","dataframe_1_1","columnNameOrNames","columnNameOrNames_1","columnNameOrNames_1_1","columnNameOrNames_2","columnNameOrNames_2_1","columnNameOrNames_3","columnNameOrNames_3_1","_d","_e","columnFormatString","columnNames_11","columnNames_11_1","singleColumnName","dataframes","contents_1","contents_1_1","dataframes_1","dataframes_1_1","OrderedDataFrame","summarize","spec","inputColumnName","inputSpec","outputFieldsMap","valueColumnName","inputColumnNames_1","inputColumnNames_1_1","outputFieldNames","outputFieldNames_1","outputFieldNames_1_1","outputFieldName","aggregatorFn","pivot","valueColumnNameOrSpec","aggregator","aggSpec","columnNames_12","columnNames_12_1","_c","columnAggSpec","aggColumnName","outputSpec","firstColumnName","src","columnNameIndex","nextColumnName","parentGroup","subGroup","valueColumnNames","outputColumnsMap","outputColumnNames_1","outputColumnNames_1_1","outputColumName","srcRow","valueColumnNames_1","valueColumnNames_1_1","melt","idColumnOrColumns","valueColumnOrColumns","idColumnNames","idColumnNames_1","idColumnNames_1_1","valueColumnNames_2","valueColumnNames_2_1","K","N","mdata","original","idColumnNames_2","idColumnNames_2_1","col","idData","columnData_1","TileIterable","columnSeries_1","seriesArray","columnData","RavelIterable","columnSeries","valueColumnData","RepeatIterable","valueColumnSeries","defaultDataFrame","typeFrequency","Column","valueFrequency","toJSON","JSON","stringify","toJSON5","toCSV","unparse","toHTML","columNames","columName","serialize","indexValues","serializedColumns","indexType","getType","toISOString","cloned","columns_1","columns_1_1","rows_1","rows_1_1","columnOrder","deserialize","rows_2","rows_2_1","_1","_2","util_1","fromObject","obj","Field","fromJSON","jsonTextString","parse","fromJSON5","fromCSV","csvTextString","skipEmptyLines","data","trim","shift","concatSeries","zipSeries","start","matrix","numColumns","increment","nextValue","colIndex","e","u","h","f","String","z","utcOffset","year","month","add","M","y","w","ms","Q","replace","$","weekdays","split","months","S","g","pl","date","D","locale","$L","utc","$u","$d","Date","NaN","test","match","UTC","init","$y","getFullYear","$M","getMonth","$D","getDate","$W","getDay","$H","getHours","$m","getMinutes","$s","getSeconds","$ms","getMilliseconds","$utils","isValid","isSame","startOf","endOf","isAfter","isBefore","$g","day","hour","minute","second","millisecond","unix","valueOf","getTime","$locale","weekStart","$set","daysInMonth","setDate","subtract","substr","YY","YYYY","MM","MMM","monthsShort","MMMM","DD","dd","weekdaysMin","ddd","weekdaysShort","dddd","H","HH","hh","A","mm","ss","SSS","Z","getTimezoneOffset","diff","toUTCString","isDayjs","en","Ls","typy_1","isBoolean","mapIterable","items","mapFn","result","sent","items_1","items_1_1","item","items_2","items_2_1","items_3","items_3_1","_type","d1","d2","v1","v2","getGreaterThan","ArrayIterator","empty_iterator_1","EmptyIterator","count_iterator_1","CountIterator","multi_iterator_1","iterables","iterators","iterable","MultiIterator","select_iterator_1","SelectIterator","select_many_iterator_1","SelectManyIterator","take_iterator_1","childIterable","numElements","childIterator","TakeIterator","take_while_iterator_1","TakeWhileIterator","where_iterator_1","WhereIterator","concat_iterator_1","ConcatIterator","array_iterator_1","zip_iterator_1","ZipIterator","distinct_iterator_1","DistinctIterator","SortOperation","sortSpec","genKeys","compare","indexA","indexB","keyA","keyB","comparison","indexes","sortOperations","sortOperations_1","sortOperations_1_1","sortedValues","indexes_1","indexes_1_1","extract_element_iterator_1","arrayIterable","extractIndex","arrayIterator","ExtractElementIterator","skip_iterator_1","SkipIterator","skip_while_iterator_1","SkipWhileIterator","wcwidth","Table","__printers","string","val","str","leftPadder","ch","len","printer","separator","padLeft","rightPadder","padRight","each","fn","number","digits","cols","idx","print","widths","out","line","pushDelimeter","totals","forEachTotal","cb","aggr","acc","printTransposed","opts","namePrinter","cmp","comparators","order","exec","prefix","avg","params","log","createCommonjsModule","_global","global","self","Function","__g","_core","core","version","__e","_isObject","it","_anObject","TypeError","_fails","_descriptors","document","is","createElement","_ie8DomDefine","dP","_objectDp","O","P","Attributes","_toPrimitive","_hide","bitmap","configurable","writable","_propertyDesc","_has","id","px","random","_redefine","SRC","$toString","TPL","inspectSource","safe","_ctx","that","_aFunction","$export","source","own","exp","IS_FORCED","F","IS_GLOBAL","G","IS_STATIC","IS_PROTO","IS_BIND","B","target","expProto","U","W","R","TO_STRING","_export","_toInteger","isNaN","$at","pos","_defined","charCodeAt","charAt","codePointAt","fromCharCode","$fromCodePoint","fromCodePoint","x","code","arguments$1","res","aLen","RangeError","parseState","stack","token","root","lexState","buffer","doubleQuote","sign","unicode","Space_Separator","ID_Start","ID_Continue","util","isSpaceSeparator","isIdStartChar","isIdContinueChar","isDigit","isHexDigit","lex","peek","lexStates","read","newToken","comment","invalidChar","multiLineComment","multiLineCommentAsterisk","singleLineComment","literal","Infinity","identifierNameStartEscape","unicodeEscape","invalidIdentifier","identifierName","identifierNameEscape","zero","decimalInteger","decimalPointLeading","decimalPoint","decimalFraction","decimalExponent","decimalExponentSign","decimalExponentInteger","hexadecimal","hexadecimalInteger","hexEscape","escape","formatChar","separatorChar","beforePropertyName","afterPropertyName","beforePropertyValue","afterPropertyValue","beforeArrayValue","afterArrayValue","end","list","parseStates","invalidEOF","pop","current","syntaxError","replacements","'","\"","\\","\b","\f","\n","\r","\t","\u000b","\u0000"," "," ","hexString","message","err","SyntaxError","lineNumber","columnNumber","text","reviver","internalize","holder","replacement","","replacer","space","propertyList","replacerFunc","quote","indent","gap","serializeProperty","Boolean","quoteString","stepback","final","partial","propertyString","properties","properties$1","serializeArray","member","serializeKey","serializeObject","quotes","product","quoteChar","RegExp","firstChar","factory","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","postMessage","location","protocol","dynamicTyping","dynamicTypingFunction","transform","worker","WORKERS_SUPPORTED","URL","webkitURL","BLOB_URL","createObjectURL","Blob","Worker","onmessage","_","userStep","step","userChunk","chunk","userComplete","complete","userError","error","workerId","NODE_STREAM_INPUT","download","readable","on","File","stream","delimiter","BAD_DELIMITERS","newline","escapeChar","q","fields","meta","constructor","RECORD_SEP","UNIT_SEP","BYTE_ORDER_MARK","LocalChunkSize","RemoteChunkSize","DefaultDelimiter","Parser","ParserHandle","NetworkStreamer","FileStreamer","StringStreamer","ReadableStreamStreamer","jQuery","prop","toUpperCase","attr","FileReader","files","file","inputElem","instanceConfig","action","reason","splice","_handle","_finished","_completed","_halted","_input","_baseIndex","_partialLine","_rowCount","_start","_nextChunk","isFirstChunk","_completeResults","errors","E","chunkSize","streamer","_config","parseChunk","beforeFirstChunk","paused","aborted","cursor","preview","results","WORKER_ID","finished","_sendError","_readChunk","_chunkLoaded","XMLHttpRequest","withCredentials","onload","onerror","_chunkError","open","downloadRequestBody","downloadRequestHeaders","setRequestHeader","send","status","readyState","responseText","getResponseHeader","lastIndexOf","statusText","webkitSlice","mozSlice","FileReaderSync","size","readAsText","encoding","pause","resume","_streamData","_streamEnd","_streamError","_checkIsFinished","_streamCleanUp","removeListener","pow","abort","k","transformHeader","comments","successful","bestDelimiter","delimitersToGuess","getCharIndex","setTimeout","I","T","L","fastMode","j","nextDelim","quoteSearch","C","linebreak","truncated","terminate","cached_iterator_1","cached","CachedIterator","_next","zone","offset","afternoon","milliseconds","SS","Do","ordinal","findIndex","Y","ZZ","regex","parser","hours","minutes","seconds","multiResult","outputIterator","outputIterable","outputResult","curIterator","moveToNextIterable","nextIterable","series_window_iterator_1","SeriesWindowIterator","curWindow","curPos","Start","results_1","results_1_1","zippedValues","zipperInput","valuesAlreadySeen","Set","potentialOutput","series_rolling_window_iterator_1","SeriesRollingWindowIterator","series_variable_window_iterator_1","SeriesVariableWindowIterator","prevValue","doneSkipping","defaults","combining","DEFAULTS","nul","control","wcswidth","ucs","mid","bisearch","Buffer","circular","depth","allParents","allChildren","useBuffer","_clone","child","proto","__isArray","__isRegExp","__getRegExpFlags","lastIndex","__isDate","isBuffer","allocUnsafe","copy","getPrototypeOf","attrs","getOwnPropertyDescriptor","__objToStr","re","flags","ignoreCase","multiline","clonePrototype","base64","ieee754","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","Uint8Array","__proto__","arg","encodingOrOffset","ArrayBuffer","array","byteOffset","byteLength","fromArrayLike","fromArrayBuffer","isEncoding","actual","write","fromString","checked","assertSize","isView","loweredCase","utf8ToBytes","base64ToBytes","swap","bidirectionalIndexOf","dir","arrayIndexOf","indexSize","arrLength","valLength","buf","readUInt16BE","foundIndex","found","hexWrite","remaining","strLen","parsed","utf8Write","blitBuffer","asciiWrite","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","base64Slice","fromByteArray","utf8Slice","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","decodeCodePointsArray","SlowBuffer","alloc","INSPECT_MAX_BYTES","foo","subarray","typedArraySupport","poolSize","_augment","species","fill","allocUnsafeSlow","_isBuffer","swap16","swap32","swap64","hexSlice","asciiSlice","latin1Slice","utf16leSlice","equals","inspect","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","_arr","ret","toHex","bytes","checkOffset","ext","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","writeDouble","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","INVALID_BASE64_RE","leadSurrogate","toByteArray","stringtrim","base64clean","dst","b64","lens","getLens","validLen","placeHoldersLen","tmp","Arr","_byteLength","curByte","revLookup","uint8","extraBytes","parts","len2","encodeChunk","num","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","rt","LN2","dataframe_window_iterator_1","DataFrameWindowIterator","csv_rows_iterator_1","CsvRowsIterator","rowsIterable","rowsIterator","dataframe_rolling_window_iterator_1","DataFrameRollingWindowIterator","dataframe_variable_window_iterator_1","DataFrameVariableWindowIterator","repeat_iterator_1","RepeatIterator","repetition","tile_iterator_1","TileIterator","firstIteration","ravel_iterator_1","RavelIterator","iteratorIndex","column_names_iterator_1","ColumnNamesIterator","columnNamesIterator","combinedFields","addCustomTypes","Schema","_typy","_typy2","__defineGetter__","_typeof","_createClass","_util","Typy","_classCallCheck","schemaCheck","getNestedObject","convertSchemaAndGetMatch","isNull","Null","Undefined","_arguments","buildSchema","getSchemaMatch","numeral","decimal","binary","unformatRegex","formats","locales","currentLocale","zeroFormat","nullFormat","defaultFormat","scalePercentBy100","Numeral","_value","kind","unformatFunction","regexp","isNumeral","regexps","unformat","stringToNumber","numberToFormat","roundingFunction","leadingCount","abbrForce","int","precision","signed","thousands","negP","optDec","abbr","neg","abbreviations","trillion","billion","million","thousand","delimiters","abbreviation","stringOriginal","currency","symbol","search","insert","subString","multiplier","correctionFactor","mn","maxDecimals","optionals","boundedPrecision","optionalsRegExp","power","splitValue","minDecimals","localeData","reset","register","validate","culture","_decimalSep","_thousandSep","_currSymbol","_valArray","_abbrObj","_thousandRegEx","temp","inputString","formatFunction","corrFactor","curr","currI","multiply","divide","difference","base","suffixes","suffix","bytesMultiplier","symbols","toExponential","timeArray","process","getOwnPropertyDescriptors","descriptors","formatRegExp","objects","deprecate","msg","noDeprecation","warned","throwDeprecation","traceDeprecation","trace","debugEnviron","debugs","ctx","seen","stylize","stylizeNoColor","colors","showHidden","_extend","customInspect","stylizeWithColor","formatValue","styleType","style","styles","recurseTimes","primitive","simple","formatPrimitive","visibleKeys","hash","arrayToHash","getOwnPropertyNames","isError","formatError","isRegExp","braces","formatProperty","formatArray","cur","numLinesEst","reduceToSingleString","desc","ar","objectToString","pad","debuglog","env","NODE_DEBUG","pid","bold","italic","underline","inverse","white","grey","black","blue","cyan","green","magenta","red","yellow","special","boolean","null","isNullOrUndefined","isSymbol","isPrimitive","time","inherits","origin","kCustomPromisifiedSymbol","callbackifyOnRejected","newReason","promisify","promiseResolve","promiseReject","promise","Promise","resolve","reject","setPrototypeOf","defineProperties","custom","callbackify","callbackified","maybeCb","then","nextTick","rej","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","noop","title","browser","argv","versions","addListener","once","off","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","ctor","superCtor","super_","TempCtor"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","import { ArrayIterable }  from './iterables/array-iterable';\r\nimport { EmptyIterable }  from './iterables/empty-iterable';\r\nimport { CountIterable }  from './iterables/count-iterable';\r\nimport { MultiIterable }  from './iterables/multi-iterable';\r\nimport { SelectIterable }  from './iterables/select-iterable';\r\nimport { SelectManyIterable }  from './iterables/select-many-iterable';\r\nimport { TakeIterable }  from './iterables/take-iterable';\r\nimport { TakeWhileIterable }  from './iterables/take-while-iterable';\r\nimport { WhereIterable }  from './iterables/where-iterable';\r\nimport { ConcatIterable }  from './iterables/concat-iterable';\r\nimport { SeriesWindowIterable }  from './iterables/series-window-iterable';\r\nimport { ReverseIterable }  from './iterables/reverse-iterable';\r\nimport { ZipIterable }  from './iterables/zip-iterable';\r\nimport { DistinctIterable }  from './iterables/distinct-iterable';\r\nimport { SeriesRollingWindowIterable }  from './iterables/series-rolling-window-iterable';\r\nimport { SeriesVariableWindowIterable }  from './iterables/series-variable-window-iterable';\r\nimport { OrderedIterable, Direction, ISortSpec, SelectorFn as SortSelectorFn }  from './iterables/ordered-iterable';\r\nimport { IIndex, Index } from './index';\r\nimport { ExtractElementIterable } from './iterables/extract-element-iterable';\r\nimport { SkipIterable } from './iterables/skip-iterable';\r\nimport { SkipWhileIterable } from './iterables/skip-while-iterable';\r\n// @ts-ignore\r\nimport Table from 'easy-table';\r\nimport { IDataFrame, DataFrame } from './dataframe';\r\n// @ts-ignore\r\nimport moment from \"dayjs\";\r\n// @ts-ignore\r\nimport customParseFormat from 'dayjs/plugin/customParseFormat';\r\nmoment.extend(customParseFormat);\r\nimport { toMap, isArray, isFunction, isNumber, isString, isDate, isObject } from './utils';\r\nimport { range, replicate } from '..';\r\nimport numeral from 'numeral';\r\nimport { CachedIteratorIterable } from './iterables/cached-iterator-iterable';\r\n\r\n/**\r\n * Used to configure a series.\r\n */\r\nexport interface ISeriesConfig<IndexT, ValueT> {\r\n    /**\r\n     * Values to put in the dataframe.\r\n     * This should be array or iterable of JavaScript values.\r\n     */\r\n    values?: Iterator<ValueT> | Iterable<ValueT>;\r\n\r\n    /***\r\n     * The index for the serires.\r\n     * If omitted the index will default to a 0-based index.\r\n     */\r\n    index?: Iterator<IndexT> | Iterable<IndexT>;\r\n\r\n    /**\r\n     * Array or iterable of index,value pairs to put in the series.\r\n     * If index and values are not separately specified they can be extracted\r\n     * from the pairs.\r\n     */\r\n    pairs?: Iterator<[IndexT, ValueT]> | Iterable<[IndexT, ValueT]>;\r\n\r\n    /***\r\n     * Set to true when the series has been baked into memory\r\n     * and does not need to be lazily evaluated.\r\n     */\r\n    baked?: boolean;\r\n}\r\n\r\n/**\r\n * A user-defined callback function that can be applied to each value.\r\n */\r\nexport type CallbackFn<ValueT> = (value: ValueT, index: number) => void;\r\n\r\n/**\r\n * A user-defined selector function. \r\n * Transforms a value into another kind of value.\r\n */\r\nexport type SelectorWithIndexFn<FromT, ToT> = (value: FromT, index: number) => ToT;\r\n\r\n/**\r\n * User-defined zipper functions.\r\n * Used to 'zip together' multiple series or dataframes.\r\n */\r\n//TODO: The Zip function should actually be necessary. Should really just output a series of arrays, collecting each value into one array.\r\n// The caller can then run select on it and this means th the zipper function is unecessary.\r\nexport type ZipNFn<ValueT, ReturnT> = (input: ISeries<number, ValueT>) => ReturnT;\r\nexport type Zip2Fn<T1, T2, ReturnT> = (a: T1, b : T2) => ReturnT;\r\nexport type Zip3Fn<T1, T2, T3, ReturnT> = (a: T1, b: T2, c: T3) => ReturnT;\r\nexport type Zip4Fn<T1, T2, T3, T4, ReturnT> = (a: T1, b: T2, c: T3, d: T4) => ReturnT;\r\nexport type Zip5Fn<T1, T2, T3, T4, T5, ReturnT> = (a: T1, b: T2, c: T3, d: T4) => ReturnT;\r\n\r\n/**\r\n * A user-defined selector function with no index. \r\n * Transforms a value into another kind of value.\r\n */\r\nexport type SelectorFn<FromT, ToT> = (value: FromT) => ToT;\r\n\r\n/**\r\n * A user-defined function that joins two values and produces a result.\r\n */\r\nexport type JoinFn<ValueT1, ValueT2, ResultT> = (a: ValueT1, b: ValueT2) => ResultT;\r\n\r\n/**\r\n * A user-defined predicate function, returns true or false based on input.\r\n */\r\nexport type PredicateFn<ValueT> = (value: ValueT) => boolean;\r\n\r\n/**\r\n * A user-defined function that aggregtates a value into an accumulator\r\n * and returns the new result.\r\n */\r\nexport type AggregateFn<ValueT, ToT> = (accum: ToT, value: ValueT) => ToT;\r\n\r\n/**\r\n * A user-defined comparer function that Compares to values and \r\n * returns true (truthy) if they are equivalent or false (falsy) if not.\r\n */\r\nexport type ComparerFn<ValueT1, ValueT2> = (a: ValueT1, b: ValueT2) => boolean;\r\n\r\n/*\r\n * A user-defined function that generates a series config object.\r\n * Used to make it easy to create lazy evaluated series.\r\n */\r\nexport type SeriesConfigFn<IndexT, ValueT> = () => ISeriesConfig<IndexT, ValueT>;\r\n\r\n/*\r\n * A user-defined gap-filler function.\r\n * This function generates a sequence of values between to fill the gaps between two other values.\r\n */\r\nexport type GapFillFn<ValueT, ResultT> = (a: ValueT, b: ValueT) => ResultT[];\r\n\r\n/**\r\n * Represents the frequency of a type in a series or dataframe.\r\n */\r\nexport interface ITypeFrequency {\r\n\r\n    /**\r\n     * The name of the type.\r\n     */\r\n    Type: string; \r\n\r\n    /**\r\n     * The frequency of the type's appearance in the series or dataframe.\r\n     */\r\n    Frequency: number;\r\n}\r\n\r\n/**\r\n * Represents the frequency of a value in a series or dataframe.\r\n */\r\nexport interface IValueFrequency {\r\n\r\n    /**\r\n     * The value.\r\n     */\r\n    Value: any; \r\n\r\n    /**\r\n     * The frequency of the value's appearance in the series or dataframe.\r\n     */\r\n    Frequency: number;\r\n}\r\n\r\n/**\r\n * Places a value in a bucket or range of values.\r\n * \r\n * WARNING: This interface is deprecated and will be removed in the future.\r\n */\r\nexport interface IBucket {\r\n    /**\r\n     * The bucketed value.\r\n     */\r\n    Value: number;\r\n\r\n    /**\r\n     * The index of the bucket that contains the value.\r\n     */\r\n    Bucket: number;\r\n\r\n    /**\r\n     * The minimum value in the bucket.\r\n     */\r\n    Min: number;\r\n\r\n    /**\r\n     * The mid-point value in the bucket.\r\n     */\r\n    Mid: number;\r\n    \r\n    /**\r\n     * The maximum value in the bucket.\r\n     */\r\n    Max: number;\r\n}\r\n\r\n/**\r\n * Specifies where from a data window the index is pulled from: the start of the window, the end or from the middle.\r\n */\r\nexport enum WhichIndex {\r\n    Start = \"start\",\r\n    End = \"end\",\r\n}\r\n\r\n/**\r\n * Options to the `Series.frequency` function.\r\n */\r\nexport interface IFrequencyTableOptions {\r\n\r\n    /**\r\n     * Lower boundary (if defined).\r\n     */\r\n    lower?: number;\r\n\r\n    /**\r\n     * Upper boundary (if defined).\r\n     */\r\n    upper?: number;\r\n\r\n     /**\r\n     * Directly sets the interval (if defined). This is the range of each group.\r\n     */\r\n    interval?: number;\r\n    \r\n    /**\r\n     * Enables capturing of values for each group.\r\n     */\r\n    captureValues?: boolean;\r\n}\r\n\r\n/**\r\n * Defines a record in the frequency table output by the `Series.frequency` function.\r\n */\r\nexport interface IFrequencyTableEntry {\r\n\r\n    /**\r\n     * Lower value in this group of the frequency table.\r\n     */\r\n    lower?: number;\r\n\r\n    /** \r\n     * Upper value in this group of the frequency table.  \r\n     */\r\n    upper?: number;\r\n\r\n    /**\r\n     * Count of values in this group.\r\n     */\r\n    count: number;\r\n\r\n    /**\r\n     * Proportion (0-1) of values in this group.\r\n     */\r\n    proportion: number;\r\n\r\n    /**\r\n     * Cumulative proportion of values in this and earlier groups.\r\n     */\r\n    cumulative: number;\r\n\r\n    /**\r\n     * The values that were record in this group.\r\n     * (if enabled in the options).\r\n     */\r\n    values?: number[];\r\n}\r\n\r\n\r\n/**\r\n * Interface that represents a series.\r\n * A series contains an indexed sequence of values.\r\n * A series indexed by time is a timeseries.\r\n * \r\n * @typeparam IndexT The type to use for the index.\r\n * @typeparam ValueT The type to use for each value.\r\n */\r\nexport interface ISeries<IndexT = number, ValueT = any> extends Iterable<ValueT> {\r\n\r\n    /**\r\n     * Get an iterator to enumerate the values of the series.\r\n     * Enumerating the iterator forces lazy evaluation to complete.\r\n     * This function is automatically called by `for...of`.\r\n     * \r\n     * @return An iterator for the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * for (const value of series) {\r\n     *     // ... do something with the value ...\r\n     * }\r\n     * </pre>\r\n     */\r\n    [Symbol.iterator] (): Iterator<ValueT>;\r\n\r\n    /**\r\n     * Cast the value of the series to a new type.\r\n     * This operation has no effect but to retype the values that the series contains.\r\n     * \r\n     * @return The same series, but with the type changed.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const castSeries = series.cast<SomeOtherType>();\r\n     * </pre>\r\n     */\r\n    cast<NewValueT> (): ISeries<IndexT, NewValueT>;\r\n\r\n    /**\r\n     * Get the index for the series.\r\n     * \r\n     * @return The {@link Index} for the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const index = series.getIndex();\r\n     * </pre>\r\n     */\r\n    getIndex (): IIndex<IndexT>;\r\n\r\n    /**\r\n     * Apply a new {@link Index} to the series.\r\n     * \r\n     * @param newIndex The new array or iterable to be the new {@link Index} of the series. Can also be a selector to choose the {@link Index} for each value in the series.\r\n     * \r\n     * @return Returns a new series with the specified {@link Index} attached.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedSeries = series.withIndex([10, 20, 30]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedSeries = series.withIndex(someOtherSeries);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedSeries = series.withIndex(value => computeIndexFromValue(value));\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedSeries = series.withIndex(value => value + 20);\r\n     * </pre>\r\n     */\r\n    withIndex<NewIndexT> (newIndex: Iterable<NewIndexT> | SelectorFn<ValueT, NewIndexT>): ISeries<NewIndexT, ValueT>;\r\n\r\n    /**\r\n     * Resets the {@link Index} of the series back to the default zero-based sequential integer index.\r\n     * \r\n     * @return Returns a new series with the {@link Index} reset to the default zero-based index. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithResetIndex = series.resetIndex();\r\n     * </pre>\r\n     */\r\n    resetIndex (): ISeries<number, ValueT>;\r\n\r\n   /**\r\n     * Merge one or more series into this series.\r\n     * Values are merged by index.\r\n     * Values at each index are combined into arrays in the resulting series.\r\n     * \r\n     * @param series... One or more other series to merge into the series.\r\n     * \r\n     * @returns The merged series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const mergedSeries = series1.merge(series2);\r\n     * </pre>\r\n     * \r\n     * <pre>\r\n     * \r\n     * const mergedSeries = series1.merge(series2, series3, etc);\r\n     * </pre>\r\n     */\r\n    merge<MergedValueT = any>(...args: any[]): ISeries<IndexT, MergedValueT[]>;\r\n\r\n    /**\r\n    * Extract values from the series as an array.\r\n    * This forces lazy evaluation to complete.\r\n    * \r\n    * @return Returns an array of the values contained within the series.\r\n    * \r\n    * @example\r\n    * <pre>\r\n    * const values = series.toArray();\r\n    * </pre>\r\n    */\r\n   toArray (): ValueT[];\r\n\r\n    /**\r\n     * Retreive the index, values pairs from the series as an array.\r\n     * Each pair is [index, value].\r\n     * This forces lazy evaluation to complete.\r\n     * \r\n     * @return Returns an array of pairs that contains the series values. Each pair is a two element array that contains an index and a value.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const pairs = series.toPairs();\r\n     * </pre>\r\n     */\r\n    toPairs (): ([IndexT,ValueT])[];\r\n\r\n    /**\r\n     * Convert the series to a JavaScript object.\r\n     *\r\n     * @param keySelector User-defined selector function that selects keys for the resulting object.\r\n     * @param valueSelector User-defined selector function that selects values for the resulting object.\r\n     * \r\n     * @return Returns a JavaScript object generated from the series by applying the key and value selector functions. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const someObject = series.toObject(\r\n     *      value => value, // Specify the value to use for field names in the output object.\r\n     *      value => value // Specify the value to use as the value for each field.\r\n     * );\r\n     * </pre>\r\n     */\r\n    toObject<KeyT = any, FieldT = any, OutT = any> (keySelector: (value: ValueT) => KeyT, valueSelector: (value: ValueT) => FieldT): OutT;\r\n\r\n    /**\r\n     * Transforms an input series, generating a new series.\r\n     * The transformer function is called for each element of the input and the collection of outputs creates the generated series.\r\n     * \r\n     * `select` is an alias for {@link Series.map}.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.map` but maps over a data series rather than an array.\r\n     *\r\n     * @param transformer A user-defined transformer function that transforms each element from the input to generate the output.\r\n     * \r\n     * @return Returns the series generated by calling the transformer function over each value in the input series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = // ... construct output from input ...\r\n     *      return output;\r\n     * }\r\n     *  \r\n     * const transformed = series.select(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n    select<ToT> (transformer: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT>;\r\n\r\n    /**\r\n     * Transforms an input series, generating a new series.\r\n     * The transformer function is called for each element of the input and the collection of outputs creates the generated series.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.map` but maps over a data series rather than an array.\r\n     *\r\n     * @param transformer A user-defined transformer function that transforms each element from the input to generate the output.\r\n     * \r\n     * @return Returns a new series generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = // ... construct output from input ...\r\n     *      return output;\r\n     * }\r\n     *  \r\n     * const transformed = series.map(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n    map<ToT> (transformer: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT>;\r\n    \r\n    /**\r\n     * Transforms and flattens an input series, generating a new series.\r\n     * The transformer function is called for each value in the input series and produces an array that is then flattened into the generated series.\r\n     * \r\n     * `selectMany` is an alias for {@link Series.flatMap}.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.flatMap` but maps over a data series rather than an array.\r\n     * \r\n     * @param transformer A user-defined function that transforms each value into an array that is then flattened into the generated series.\r\n     * \r\n     * @return Returns a new series generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = [];\r\n     *      while (someCondition) {\r\n     *          // ... generate zero or more outputs from a single input ...\r\n     *          output.push(... some generated value ...);\r\n     *      }\r\n     *      return output;\r\n     * }\r\n     * \r\n     * const transformed = series.selectMany(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n    selectMany<ToT> (transformer: SelectorWithIndexFn<ValueT, Iterable<ToT>>): ISeries<IndexT, ToT>;\r\n\r\n    /**\r\n     * Transforms and flattens an input series, generating a new series.\r\n     * The transformer function is called for each value in the input series and produces an array that is then flattened into the generated series.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.flatMap` but maps over a data series rather than an array.\r\n     * \r\n     * @param transformer A user-defined function that transforms each value into an array that is then flattened into the generated series.\r\n     * \r\n     * @return Returns a new series generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = [];\r\n     *      while (someCondition) {\r\n     *          // ... generate zero or more outputs from a single input ...\r\n     *          output.push(... some generated value ...);\r\n     *      }\r\n     *      return output;\r\n     * }\r\n     * \r\n     * const transformed = series.flatMap(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n    flatMap<ToT> (transformer: SelectorWithIndexFn<ValueT, Iterable<ToT>>): ISeries<IndexT, ToT>;\r\n        \r\n    /**\r\n     * Partition a series into a {@link Series} of *data windows*. \r\n     * Each value in the new series is a chunk of data from the original series.\r\n     *\r\n     * @param period The number of values to include in each data window.\r\n     * @param whichIndex Sets which side of the window the index comes from: start or end. Can be \"start\" or \"end\", defaults to \"end\".\r\n     * \r\n     * @return Returns a new series, each value of which is a chunk (data window) of the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const windows = series.window(2); // Get values in pairs.\r\n     * const pctIncrease = windows.select(pair => (pair.last() - pair.first()) / pair.first());\r\n     * console.log(pctIncrease.toString());\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesDf = ... // Daily sales data.\r\n     * const weeklySales = salesDf.window(7); // Partition up into weekly data sets.\r\n     * console.log(weeklySales.toString());\r\n     * </pre>\r\n     */\r\n    window (period: number, whichIndex?: WhichIndex): ISeries<IndexT, ISeries<IndexT, ValueT>>;\r\n\r\n    /** \r\n     * Partition a series into a new series of *rolling data windows*. \r\n     * Each value in the new series is a rolling chunk of data from the original series.\r\n     *\r\n     * @param period The number of data values to include in each data window. \r\n     * @param whichIndex Sets which side of the window the index comes from: start or end. Can be \"start\" or \"end\", defaults to \"end\".\r\n     * \r\n     * @return Returns a new series, each value of which is a rolling chunk of the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesData = ... // Daily sales data.\r\n     * const rollingWeeklySales = salesData.rollingWindow(7); // Get rolling window over weekly sales data.\r\n     * console.log(rollingWeeklySales.toString());\r\n     * </pre>\r\n     */\r\n    rollingWindow (period: number, whichIndex?: WhichIndex): ISeries<IndexT, ISeries<IndexT, ValueT>>;\r\n\r\n    /**\r\n     * Partition a series into a new series of variable-length *data windows* \r\n     * where the divisions between the data chunks are\r\n     * defined by a user-provided *comparer* function.\r\n     * \r\n     * @param comparer Function that compares two adjacent data values and returns true if they should be in the same window.\r\n     * \r\n     * @return Returns a new series, each value of which is a chunk of data from the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function rowComparer (valueA, valueB) {\r\n     *      if (... valueA should be in the same data window as valueB ...) {\r\n     *          return true;\r\n     *      }\r\n     *      else {\r\n     *          return false;\r\n     *      }\r\n     * };\r\n     * \r\n     * const variableWindows = series.variableWindow(rowComparer);\r\n     */\r\n    variableWindow (comparer: ComparerFn<ValueT, ValueT>): ISeries<number, ISeries<IndexT, ValueT>>;\r\n\r\n    /**\r\n     * Eliminates adjacent duplicate values.\r\n     * \r\n     * For each group of adjacent values that are equivalent only returns the last index/row for the group, \r\n     * thus ajacent equivalent values are collapsed down to the last value.\r\n     *\r\n     * @param selector Optional selector function to determine the value used to compare for equivalence.\r\n     * \r\n     * @return Returns a new series with groups of adjacent duplicate vlaues collapsed to a single value per group.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithDuplicateRowsRemoved = series.sequentialDistinct(value => value);\r\n     * \r\n     * // Or\r\n     * const seriesWithDuplicateRowsRemoved = series.sequentialDistinct(value => value.someNestedField);\r\n     * </pre>\r\n     */\r\n    sequentialDistinct<ToT> (selector: SelectorFn<ValueT, ToT>): ISeries<IndexT, ValueT>;\r\n    \r\n    /**\r\n     * Reduces the values in the series to a single result.\r\n     *\r\n     * `aggregate` is similar to {@link Series.reduce}, but the parameters are reversed. \r\n     * Please use {@link Series.reduce} in preference to `aggregate`.\r\n     *\r\n     * @param seed Optional seed value for producing the aggregation.\r\n     * @param reducer Function that takes the seed and then each value in the series and produces the reduced value.\r\n     * \r\n     * @return Returns a new value that has been reduced from the input series by passing it through the 'reducer' function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dailySales = ... daily sales figures for the past month ...\r\n     * const totalSalesForthisMonth = dailySales.aggregate(\r\n     *      0, // Seed - the starting value.\r\n     *      (accumulator, salesAmount) => accumulator + salesAmount // Aggregation function.\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const previousSales = 500; // We'll seed the aggregation with this value.\r\n     * const dailySales = ... daily sales figures for the past month ...\r\n     * const updatedSales = dailySales.aggregate(\r\n     *      previousSales, \r\n     *      (accumulator, salesAmount) => accumulator + salesAmount\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * var salesDataSummary = salesData.aggregate({\r\n     *      TotalSales: series => series.count(),\r\n     *      AveragePrice: series => series.average(),\r\n     *      TotalRevenue: series => series.sum(), \r\n     * });\r\n     * </pre>\r\n     */\r\n    aggregate<ToT = ValueT> (seedOrSelector: AggregateFn<ValueT, ToT> | ToT, selector?: AggregateFn<ValueT, ToT>): ToT;\r\n   \r\n    /**\r\n     * Reduces the values in the series to a single result.\r\n     *\r\n     * This is the same concept as the JavaScript function `Array.reduce` but reduces a data series rather than an array.\r\n\r\n     * @param reducer Function that takes the seed and then each value in the series and produces the reduced value.\r\n     * @param seed Optional initial value, if not specifed the first value in the series is used as the initial value.\r\n     * \r\n     * @return Returns a new value that has been reduced from the input series by passing it through the 'reducer' function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dailySales = ... daily sales figures for the past month ...\r\n     * const totalSalesForthisMonth = dailySales.reduce(\r\n     *      (accumulator, salesAmount) => accumulator + salesAmount, // Reducer function.\r\n     *      0  // Seed value, the starting value.\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const previousSales = 500; // We'll seed the reduction with this value.\r\n     * const dailySales = ... daily sales figures for the past month ...\r\n     * const updatedSales = dailySales.reduce(\r\n     *      (accumulator, salesAmount) => accumulator + salesAmount,\r\n     *      previousSales\r\n     * );\r\n     * </pre>\r\n     */\r\n    reduce<ToT = ValueT> (reducer: AggregateFn<ValueT, ToT>, seed?: ToT): ToT;\r\n\r\n    /**\r\n     * Compute the absolute range of values in each period.\r\n     * The range for each period is the absolute difference between largest (max) and smallest (min) values in that period.\r\n     * \r\n     * @param period - Period for computing the range.\r\n     * @param whichIndex Sets which side of the window the index comes from: start or end. Can be \"start\" or \"end\", defaults to \"end\".\r\n     * \r\n     * @returns Returns a new series where each value indicates the absolute range of values for each period in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const closingPrice = ... series of closing prices for a particular stock ...\r\n     * const volatility = closingPrice.amountRange(5);\r\n     * </pre>\r\n     */\r\n    amountRange (period: number, whichIndex?: WhichIndex): ISeries<IndexT, number>;\r\n\r\n    /**\r\n     * Compute the range of values in each period in proportion to the latest value.\r\n     * The range for each period is the absolute difference between largest (max) and smallest (min) values in that period.\r\n     * Proportions are expressed as 0-1 values.\r\n     * \r\n     * @param period - Period for computing the range.\r\n     * @param whichIndex Sets which side of the window the index comes from: start or end. Can be \"start\" or \"end\", defaults to \"end\".\r\n     * \r\n     * @returns Returns a new series where each value indicates the proportion change from the previous number value in the original series.\r\n     * \r\n     * @returns Returns a new series where each value indicates the proportionate range of values for each period in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const closingPrice = ... series of closing prices for a particular stock ...\r\n     * const proportionVolatility = closingPrice.proportionRange(5);\r\n     * </pre>\r\n     */\r\n    proportionRange (period: number, whichIndex?: WhichIndex): ISeries<IndexT, number>;\r\n\r\n    /**\r\n     * Compute the range of values in each period in proportion to the latest value.\r\n     * The range for each period is the absolute difference between largest (max) and smallest (min) values in that period.\r\n     * Proportions are expressed as 0-1 values.\r\n     * \r\n     * @param period - Period for computing the range.\r\n     * @param whichIndex Sets which side of the window the index comes from: start or end. Can be \"start\" or \"end\", defaults to \"end\".\r\n     * \r\n     * @returns Returns a new series where each value indicates the proportion change from the previous number value in the original series.\r\n     * \r\n     * @returns Returns a new series where each value indicates the proportionate range of values for each period in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const closingPrice = ... series of closing prices for a particular stock ...\r\n     * const percentVolatility = closingPrice.percentRange(5);\r\n     * </pre>\r\n     */\r\n    percentRange (period: number, whichIndex?: WhichIndex): ISeries<IndexT, number>;\r\n\r\n    /**\r\n     * Compute the amount of change between pairs or sets of values in the series.\r\n     * \r\n     * @param period Optional period for computing the change - defaults to 2.\r\n     * @param whichIndex Sets which side of the window the index comes from: start or end. Can be \"start\" or \"end\", defaults to \"end\".\r\n     * \r\n     * @returns Returns a new series where each value indicates the amount of change from the previous number value in the original series.  \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const saleFigures = ... running series of daily sales figures ...\r\n     * const amountChanged = salesFigures.amountChanged(); // Amount that sales has changed, day to day.\r\n     * </pre>\r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const saleFigures = ... running series of daily sales figures ...\r\n     * const amountChanged = salesFigures.amountChanged(7); // Amount that sales has changed, week to week.\r\n     * </pre>\r\n     */\r\n    amountChange (period?: number, whichIndex?: WhichIndex): ISeries<IndexT, number>;\r\n\r\n    /**\r\n     * Compute the proportion change between pairs or sets of values in the series.\r\n     * Proportions are expressed as 0-1 values.\r\n     * \r\n     * @param period Optional period for computing the proportion - defaults to 2.\r\n     * @param whichIndex Sets which side of the window the index comes from: start or end. Can be \"start\" or \"end\", defaults to \"end\".\r\n     * \r\n     * @returns Returns a new series where each value indicates the proportion change from the previous number value in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const saleFigures = ... running series of daily sales figures ...\r\n     * const proportionChanged = salesFigures.amountChanged(); // Proportion that sales has changed, day to day.\r\n     * </pre>\r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const saleFigures = ... running series of daily sales figures ...\r\n     * const proportionChanged = salesFigures.amountChanged(7); // Proportion that sales has changed, week to week.\r\n     * </pre>\r\n     */\r\n    proportionChange (period?: number, whichIndex?: WhichIndex): ISeries<IndexT, number>;\r\n\r\n    /**\r\n     * Compute the percentage change between pairs or sets of values in the series.\r\n     * Percentages are expressed as 0-100 values.\r\n     * \r\n     * @param period Optional period for computing the percentage - defaults to 2.\r\n     * @param whichIndex Sets which side of the window the index comes from: start or end. Can be \"start\" or \"end\", defaults to \"end\".\r\n     * \r\n     * @returns Returns a new series where each value indicates the percent change from the previous number value in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const saleFigures = ... running series of daily sales figures ...\r\n     * const percentChanged = salesFigures.amountChanged(); // Percent that sales has changed, day to day.\r\n     * </pre>\r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const saleFigures = ... running series of daily sales figures ...\r\n     * const percentChanged = salesFigures.amountChanged(7); // Percent that sales has changed, week to week.\r\n     * </pre>\r\n     */\r\n    percentChange (period?: number, whichIndex?: WhichIndex): ISeries<IndexT, number>;\r\n\r\n    /**\r\n     * For each period, compute the proportion of values that are less than the last value in the period.\r\n     * Proportions are expressed as 0-1 values.\r\n     * \r\n     * @param period Optional period for computing the proportion rank - defaults to 2.\r\n     * \r\n     * @returns Returns a new series where each value indicates the proportion rank value for that period.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const proportionRank = series.proportionRank();\r\n     * </pre>\r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const proportionRank = series.proportionRank(100);\r\n     * </pre>\r\n     */\r\n    proportionRank (period?: number): ISeries<IndexT, number>;\r\n\r\n    /**\r\n     * For each period, compute the percent of values that are less than the last value in the period.\r\n     * Percent are expressed as 0-100 values.\r\n     * \r\n     * @param period Optional period for computing the percent rank - defaults to 2.\r\n     * \r\n     * @returns Returns a new series where each value indicates the percent rank value for that period.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const percentRank = series.percentRank();\r\n     * </pre>\r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const percentRank = series.percentRank(100);\r\n     * </pre>\r\n     */\r\n    percentRank (period?: number): ISeries<IndexT, number>;\r\n\r\n    /**\r\n     * Generates a cumulative sum across a series.\r\n     * \r\n     * @returns Returns a new series that is the cumulative sum of values across the input series.\r\n     */\r\n    cumsum (): ISeries<IndexT, number>;\r\n    \r\n    /**\r\n     * Skip a number of values in the series.\r\n     *\r\n     * @param numValues Number of values to skip.\r\n     * \r\n     * @return Returns a new series with the specified number of values skipped.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithRowsSkipped = series.skip(10); // Skip 10 rows in the original series.\r\n     * </pre>\r\n     */\r\n    skip (numValues: number): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Skips values in the series while a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Returns true/truthy to continue to skip values in the original series.\r\n     * \r\n     * @return Returns a new series with all initial sequential values removed while the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithRowsSkipped = series.skipWhile(salesFigure => salesFigure > 100); // Skip initial sales figure that are less than 100.\r\n     * </pre>\r\n     */\r\n    skipWhile (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Skips values in the series untils a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Return true/truthy to stop skipping values in the original series.\r\n     * \r\n     * @return Returns a new series with all initial sequential values removed until the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithRowsSkipped = series.skipUntil(salesFigure => salesFigure > 100); // Skip initial sales figures unitl we see one greater than 100.\r\n     * </pre>\r\n     */\r\n    skipUntil (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT>;\r\n    \r\n    /**\r\n     * Take a number of  values from the series.\r\n     *\r\n     * @param numValues Number of values to take.\r\n     * \r\n     * @return Returns a new series with only the specified number of values taken from the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithRowsTaken = series.take(15); // Take only the first 15 values from the original series.\r\n     * </pre>\r\n     */\r\n    take (numRows: number): ISeries<IndexT, ValueT>;\r\n    \r\n    /**\r\n     * Takes values from the series while a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Returns true/truthy to continue to take values from the original series.\r\n     * \r\n     * @return Returns a new series with only the initial sequential values that were taken while the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithRowsTaken = series.takeWhile(salesFigure => salesFigure > 100); // Take only initial sales figures that are greater than 100.\r\n     * </pre>\r\n     */\r\n    takeWhile (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Takes values from the series until a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Return true/truthy to stop taking values in the original series.\r\n     * \r\n     * @return Returns a new series with only the initial sequential values taken until the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithRowsTaken = series.takeUntil(salesFigure => salesFigure > 100); // Take all initial sales figures until we see one that is greater than 100.\r\n     * </pre>\r\n     */\r\n    takeUntil (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT>;\r\n    \r\n    /**\r\n     * Count the number of values in the seriese\r\n     *\r\n     * @return Returns the count of all values.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const numValues = series.count();\r\n     * </pre>\r\n     */\r\n    count (): number;\r\n    \r\n    /**\r\n     * Get the first value of the series.\r\n     *\r\n     * @return Returns the first value of the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const firstValue = series.first();\r\n     * </pre>\r\n     */\r\n    first (): ValueT;\r\n\r\n    /**\r\n     * Get the last value of the series.\r\n     *\r\n     * @return Returns the last value of the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const lastValue = series.last();\r\n     * </pre>\r\n     */\r\n    last (): ValueT;\r\n\r\n    /**\r\n     * Get the value, if there is one, with the specified index.\r\n     *\r\n     * @param index Index to for which to retreive the value.\r\n     *\r\n     * @return Returns the value from the specified index in the series or undefined if there is no such index in the present in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const value = series.at(5); // Get the value at index 5 (with a default 0-based index).\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const date = ... some date ...\r\n     * // Retreive the value with specified date from a time-series (assuming date indexed has been applied).\r\n     * const value = series.at(date); \r\n     * </pre>\r\n     */\r\n    at (index: IndexT): ValueT | undefined;\r\n\r\n    /** \r\n     * Get X value from the start of the series.\r\n     * Pass in a negative value to get all values at the head except for X values at the tail.\r\n     *\r\n     * @param numValues Number of values to take.\r\n     * \r\n     * @return Returns a new series that has only the specified number of values taken from the start of the original series.\r\n     * \r\n     * @examples\r\n     * <pre>\r\n     * \r\n     * const sample = series.head(10); // Take a sample of 10 values from the start of the series.\r\n     * </pre>\r\n     */\r\n    head (numValues: number): ISeries<IndexT, ValueT>;\r\n\r\n    /** \r\n     * Get X values from the end of the series.\r\n     * Pass in a negative value to get all values at the tail except X values at the head.\r\n     *\r\n     * @param numValues Number of values to take.\r\n     * \r\n     * @return Returns a new series that has only the specified number of values taken from the end of the original series.  \r\n     * \r\n     * @examples\r\n     * <pre>\r\n     * \r\n     * const sample = series.tail(12); // Take a sample of 12 values from the end of the series.\r\n     * </pre>\r\n     */\r\n    tail (numValues: number): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Filter the series using user-defined predicate function.\r\n     * \r\n     * `where` is an alias for {@link Series.filter}.\r\n     *\r\n     * This is the same concept as the JavaScript function `Array.filter` but filters a data series rather than an array.\r\n     * \r\n     * @param predicate Predicate function to filter values from the series. Returns true/truthy to keep elements, or false/falsy to omit elements.\r\n     * \r\n     * @return Returns a new series containing only the values from the original series that matched the predicate. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Filter so we only have sales figures greater than 100.\r\n     * const filtered = series.where(salesFigure => salesFigure > 100); \r\n     * console.log(filtered.toArray());\r\n     * </pre>\r\n     */\r\n    where (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Filter the series through a user-defined predicate function.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.filter` but filters a data series rather than an array.\r\n     *\r\n     * @param predicate Predicate function to filter values from the series. Returns true/truthy to keep elements, or false/falsy to omit elements.\r\n     * \r\n     * @return Returns a new series containing only the values from the original series that matched the predicate. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Filter so we only have sales figures greater than 100.\r\n     * const filtered = series.filter(salesFigure => salesFigure > 100); \r\n     * console.log(filtered.toArray());\r\n     * </pre>\r\n     */\r\n    filter (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Invoke a callback function for each value in the series.\r\n     *\r\n     * @param callback The calback function to invoke for each value.\r\n     * \r\n     * @return Returns the original series with no modifications.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * series.forEach(value => {\r\n     *      // ... do something with the value ...\r\n     * });\r\n     * </pre>\r\n     */\r\n    forEach (callback: CallbackFn<ValueT>): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Evaluates a predicate function for every value in the series to determine \r\n     * if some condition is true/truthy for **all** values in the series.\r\n     * \r\n     * @param predicate Predicate function that receives each value. It should returns true/truthy for a match, otherwise false/falsy.\r\n     *\r\n     * @return Returns true if the predicate has returned true or truthy for every value in the series, otherwise returns false. Returns false for an empty series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.all(salesFigure => salesFigure > 100); // Returns true if all sales figures are greater than 100.\r\n     * </pre>\r\n     */\r\n    all (predicate: PredicateFn<ValueT>): boolean;\r\n    \r\n    /**\r\n     * Evaluates a predicate function for every value in the series to determine \r\n     * if some condition is true/truthy for **any** of values in the series.\r\n     * \r\n     * If no predicate is specified then it simply checks if the series contains more than zero values.\r\n     *\r\n     * @param predicate Optional predicate function that receives each value. It should return true/truthy for a match, otherwise false/falsy.\r\n     *\r\n     * @return Returns true if the predicate has returned truthy for any value in the series, otherwise returns false. \r\n     * If no predicate is passed it returns true if the series contains any values at all.\r\n     * Returns false for an empty series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.any(salesFigure => salesFigure > 100); // Do we have any sales figures greater than 100?\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.any(); // Do we have any sales figures at all?\r\n     * </pre>\r\n     */\r\n    any (predicate?: PredicateFn<ValueT>): boolean;\r\n\r\n    /**\r\n     * Evaluates a predicate function for every value in the series to determine \r\n     * if some condition is true/truthy for **none** of values in the series.\r\n     * \r\n     * If no predicate is specified then it simply checks if the series contains zero values.\r\n     *\r\n     * @param predicate Optional predicate function that receives each value. It should return true/truthy for a match, otherwise false/falsy.\r\n     *\r\n     * @return Returns true if the predicate has returned truthy for zero values in the series, otherwise returns false. Returns false for an empty series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.none(salesFigure => salesFigure > 100); // Do we have zero sales figures greater than 100?\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.none(); // Do we have zero sales figures?\r\n     * </pre>\r\n     */\r\n    none (predicate?: PredicateFn<ValueT>): boolean;\r\n\r\n    /**\r\n     * Gets a new series containing all values starting at or after the specified index value.\r\n     * \r\n     * @param indexValue The index value at which to start the new series.\r\n     * \r\n     * @return Returns a new series containing all values starting at or after the specified index value. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const lastHalf = series.startAt(2);\r\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeries = ... a series indexed by date/time ...\r\n     * \r\n     * // Get all values starting at (or after) a particular date.\r\n     * const result = timeSeries.startAt(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    startAt (indexValue: IndexT): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Gets a new series containing all values up until and including the specified index value (inclusive).\r\n     * \r\n     * @param indexValue The index value at which to end the new series.\r\n     * \r\n     * @return Returns a new series containing all values up until and including the specified index value.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const firstHalf = series.endAt(1);\r\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeries = ... a series indexed by date/time ...\r\n     * \r\n     * // Get all values ending at a particular date.\r\n     * const result = timeSeries.endAt(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    endAt (indexValue: IndexT): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Gets a new series containing all values up to the specified index value (exclusive).\r\n     * \r\n     * @param indexValue The index value at which to end the new series.\r\n     * \r\n     * @return Returns a new series containing all values up to (but not including) the specified index value. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const firstHalf = series.before(2);\r\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeries = ... a series indexed by date/time ...\r\n     * \r\n     * // Get all values before the specified date.\r\n     * const result = timeSeries.before(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    before (indexValue: IndexT): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Gets a new series containing all values after the specified index value (exclusive).\r\n     * \r\n     * @param indexValue The index value after which to start the new series.\r\n     * \r\n     * @return Returns a new series containing all values after the specified index value.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const lastHalf = df.before(1);\r\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSerie = ... a series indexed by date/time ...\r\n     * \r\n     * // Get all values after the specified date.\r\n     * const result = timeSeries.after(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */    \r\n    after (indexValue: IndexT): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Gets a new series containing all values between the specified index values (inclusive).\r\n     * \r\n     * @param startIndexValue The index at which to start the new series.\r\n     * @param endIndexValue The index at which to end the new series.\r\n     * \r\n     * @return Returns a new series containing all values between the specified index values (inclusive).\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series({ \r\n     *      index: [0, 1, 2, 3, 4, 6], // This is the default index.\r\n     *      values: [10, 20, 30, 40, 50, 60],\r\n     * });\r\n     * \r\n     * const middleSection = series.between(1, 4);\r\n     * expect(middleSection.toArray()).to.eql([20, 30, 40, 50]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeries = ... a series indexed by date/time ...\r\n     * \r\n     * // Get all values between the start and end dates (inclusive).\r\n     * const result = timeSeries.after(new Date(2016, 5, 4), new Date(2016, 5, 22)); \r\n     * </pre>\r\n     */\r\n    between (startIndexValue: IndexT, endIndexValue: IndexT): ISeries<IndexT, ValueT>;\r\n\r\n    /** \r\n     * Format the series for display as a string.\r\n     * This forces lazy evaluation to complete.\r\n     * \r\n     * @return Generates and returns a string representation of the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * console.log(series.toString());\r\n     * </pre>\r\n     */\r\n    toString (): string;\r\n\r\n    /**\r\n     * Parse a series with string values and convert it to a series with int values.\r\n     *\r\n     * @return Returns a new series with values parsed from strings to ints.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const parsed = series.parseInts();\r\n     * </pre>\r\n     */\r\n    parseInts (): ISeries<IndexT, number>;\r\n\r\n    /**\r\n     * Parse a series with string values and convert it to a series with float values.\r\n     *\r\n     * @return Returns a new series with values parsed from strings to floats.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const parsed = series.parseFloats();\r\n     * </pre>\r\n     */\r\n    parseFloats (): ISeries<IndexT, number>;\r\n\r\n    /**\r\n     * Parse a series with string values and convert it to a series with date values.\r\n     *\r\n     * @param formatString Optional formatting string for dates.\r\n     * \r\n     * Moment is used for date parsing.\r\n     * https://momentjs.com\r\n     * \r\n     * @return Returns a new series with values parsed from strings to dates.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const parsed = series.parseDates();\r\n     * </pre>\r\n     */\r\n    parseDates (formatString?: string): ISeries<IndexT, Date>;\r\n\r\n    /**\r\n     * Convert a series of values of different types to a series containing string values.\r\n     *\r\n     * @param formatString Optional formatting string for dates.\r\n     * \r\n     * Numeral.js is used for number formatting.\r\n     * http://numeraljs.com/\r\n     * \r\n     * Moment is used for date formatting.\r\n     * https://momentjs.com/docs/#/parsing/string-format/\r\n     * \r\n     * @return Returns a new series values converted from values to strings.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.toStrings(\"YYYY-MM-DD\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.toStrings(\"0.00\");\r\n     * </pre>\r\n     */\r\n    toStrings (formatString?: string): ISeries<IndexT, string>;\r\n\r\n    /**\r\n     * Forces lazy evaluation to complete and 'bakes' the series into memory.\r\n     * \r\n     * @return Returns a series that has been 'baked', all lazy evaluation has completed.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const baked = series.bake();\r\n     * </pre>\r\n     */\r\n    bake (): ISeries<IndexT, ValueT>;\r\n\r\n    /** \r\n     * Converts (inflates) a series to a {@link DataFrame}.\r\n     *\r\n     * @param selector Optional user-defined selector function that transforms each value to produce the dataframe.\r\n     *\r\n     * @returns Returns a dataframe that was created from the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dataframe = series.inflate(); // Inflate a series of objects to a dataframe.\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dataframe = series.inflate(value => { AColumn:  value }); // Produces a dataframe with 1 column from a series of values.\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dataframe = series.inflate(value => { AColumn:  value.NestedValue }); // Extract a nested value and produce a dataframe from it.\r\n     * </pre>\r\n     */\r\n    inflate<ToT = ValueT> (selector?: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT>;\r\n\r\n    /**\r\n     * Sum the values in a series and returns the result.\r\n     * \r\n     * @returns Returns the sum of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const totalSales = salesFigures.sum();\r\n     * </pre>\r\n     */\r\n    sum (): number;\r\n\r\n    /**\r\n     * Average the values in a series and returns the result.\r\n     * \r\n     * `average` is an alias of {@link Series.mean}.\r\n     * \r\n     * @returns Returns the average of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const averageSales = salesFigures.average();\r\n     * </pre>\r\n     */\r\n    average (): number;\r\n\r\n    /**\r\n     * Computes and returns the mean value of a set of values.\r\n     * \r\n     * @returns Returns the mean of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const averageSales = salesFigures.mean();\r\n     * </pre>\r\n     */\r\n    mean (): number;\r\n\r\n    /**\r\n     * Get the median value in the series. \r\n     * Note that this sorts the series, which can be expensive.\r\n     * \r\n     * @returns Returns the median of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const medianSales = salesFigures.median();\r\n     * </pre>\r\n     */\r\n    median (): number;\r\n    \r\n    /**\r\n     * Get the mode of the values in the series. \r\n     * The mode is the most frequent value in the series.\r\n     * Note that this reads the entire series into memory, which can be expensive.\r\n     * \r\n     * @returns Returns the mode of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modeSales = salesFigures.mode();\r\n     * </pre>\r\n     */\r\n    mode (): any;\r\n\r\n    /**\r\n     * Get the variance of number values in the series. \r\n     * \r\n     * @returns Returns the variance of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesVariance = salesFigures.variance();\r\n     * </pre>\r\n     */\r\n    variance (): number;\r\n\r\n    /**\r\n     * Get the standard deviation of number values in the series. \r\n     * \r\n     * @returns Returns the standard deviation of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesStdDev = salesFigures.std();\r\n     * </pre>\r\n     */\r\n    std (): number;\r\n\r\n    /**\r\n     * Standardize a series of numbers by converting each \"standard deviations from the mean\".\r\n     * This converts the input series to Z scores using the population standard deviation.\r\n     * \r\n     * @returns A new series containing Z scores computed from the input series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const standardizedSeries = series.standardize();\r\n     * </pre>\r\n     */\r\n    standardize (): ISeries<IndexT, number>;\r\n\r\n    /**\r\n     * Get the (sample) variance of number values in the series. \r\n     * \r\n     * @returns Returns the (sample) variance of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesVariance = salesFigures.variance();\r\n     * </pre>\r\n     */\r\n    sampleVariance (): number;\r\n\r\n    /**\r\n     * Get the (sample) standard deviation of number values in the series. \r\n     * \r\n     * @returns Returns the (sample) standard deviation of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesStdDev = salesFigures.sampleStd();\r\n     * </pre>\r\n     */\r\n    sampleStd (): number;\r\n\r\n    /**\r\n     * Standardize a series of numbers by converting each \"standard deviations from the mean\".\r\n     * This converts the input series to Z scores using the sample standard deviation.\r\n     * \r\n     * @returns A new series containing Z scores computed from the input series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const standardizedSeries = series.sampleStandardize();\r\n     * </pre>\r\n     */\r\n    sampleStandardize (): ISeries<IndexT, number>;\r\n\r\n    /**\r\n     * Get the min value in the series.\r\n     * \r\n     * @returns Returns the minimum of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const minSales = salesFigures.min();\r\n     * </pre>\r\n     */\r\n    min (): number;\r\n\r\n    /**\r\n     * Get the max value in the series.\r\n     * \r\n     * @returns Returns the maximum of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const maxSales = salesFigures.max();\r\n     * </pre>\r\n     */\r\n    max (): number;\r\n\r\n    /**\r\n     * Get the range of values in the series.\r\n     * \r\n     * @returns Returns the range of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const range = salesFigures.range();\r\n     * </pre>\r\n     */\r\n    range (): number;\r\n\r\n    /**\r\n     * Invert the sign of every number value in the series.\r\n     * This assumes that the input series contains numbers.\r\n     * \r\n     * @returns Returns a new series with all number values inverted.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const inverted = series.invert();\r\n     * </pre>\r\n     */\r\n    invert (): ISeries<IndexT, number>;\r\n\r\n    /**\r\n     * Counts the number of sequential values where the predicate evaluates to truthy.\r\n     * Outputs 0 for values when the predicate evaluates to falsy.\r\n     * \r\n     * @param predicate User-defined function. Should evaluate to truthy to activate the counter or falsy to deactivate it.\r\n     * \r\n     * @returns Returns a new series that counts up the number of sequential values where the predicate evaluates to truthy. 0 values appear when the prediate evaluates to falsy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series([ 1, 10, 3, 15, 8, 5 ]);\r\n     * const counted = series.counter(value => value >= 3);\r\n     * console.log(counted.toString());\r\n     * </pre>\r\n     */\r\n    counter (predicate: PredicateFn<ValueT>): ISeries<IndexT, number>;\r\n\r\n    /** \r\n     * Gets a new series in reverse order.\r\n     * \r\n     * @return Returns a new series that is the reverse of the original.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const reversed = series.reverse();\r\n     * </pre>\r\n     */\r\n    reverse (): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Returns only the set of values in the series that are distinct.\r\n     * Provide a user-defined t (tor to specify criteria for determining the distinctness.\r\n     * This can be used to remove duplicate values from the series.\r\n     *\r\n     * @param selector Optional user-defined selector function that specifies the criteria used to make comparisons for duplicate values.\r\n     * \r\n     * @return Returns a series containing only unique values in the series. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const uniqueValues = series.distinct(); // Get only non-duplicated value in the series.\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const bucketedValues = series.distinct(value => Math.floor(value / 10)); // Lump values into buckets of 10.\r\n     * </pre>\r\n     */\r\n    distinct<ToT> (selector?: SelectorFn<ValueT, ToT>): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Collects values in the series into a new series of groups according to a user-defined selector function.\r\n     *\r\n     * @param selector User-defined selector function that specifies the criteriay to group by.\r\n     *\r\n     * @return Returns a new series of groups. Each group is a series with values that have been grouped by the 'selector' function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const sales = ... product sales ...\r\n     * const salesByProduct = sales.groupBy(sale => sale.ProductId);\r\n     * for (const productSalesGroup of salesByProduct) {\r\n     *      // ... do something with each product group ...\r\n     *      const productId = productSalesGroup.first().ProductId;\r\n     *      const totalSalesForProduct = productSalesGroup.deflate(sale => sale.Amount).sum();\r\n     *      console.log(totalSalesForProduct);\r\n     * }\r\n     * </pre>\r\n     */\r\n    groupBy<GroupT> (selector: SelectorFn<ValueT, GroupT>): ISeries<number, ISeries<IndexT, ValueT>>;\r\n\r\n    /**\r\n     * Collects values in the series into a new series of groups based on if the values are the same or according to a user-defined selector function.\r\n     *\r\n     * @param selector Optional selector that specifies the criteria for grouping.\r\n     *\r\n     * @return Returns a new series of groups. Each group is a series with values that are the same or have been grouped by the 'selector' function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Some ultra simple stock trading strategy backtesting...\r\n     * const dailyStockPrice = ... daily stock price for a company ...\r\n     * const priceGroups  = dailyStockPrice.groupBy(day => day.close > day.movingAverage);\r\n     * for (const priceGroup of priceGroups) {\r\n     *      // ... do something with each stock price group ...\r\n     * \r\n     *      const firstDay = priceGroup.first();\r\n     *      if (firstDay.close > movingAverage) {\r\n     *          // This group of days has the stock price above its moving average.\r\n     *          // ... maybe enter a long trade here ...\r\n     *      }\r\n     *      else {\r\n     *          // This group of days has the stock price below its moving average.\r\n     *          // ... maybe enter a short trade here ...\r\n     *      }\r\n     * }\r\n     * </pre>\r\n     */    \r\n    groupSequentialBy<GroupT> (selector?: SelectorFn<ValueT, GroupT>): ISeries<number, ISeries<IndexT, ValueT>>;\r\n    \r\n    /**\r\n     * Concatenate multiple other series onto this series.\r\n     * \r\n     * @param series Multiple arguments. Each can be either a series or an array of series.\r\n     * \r\n     * @return Returns a single series concatenated from multiple input series. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenated = a.concat(b);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenated = a.concat(b, c);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenated = a.concat([b, c]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenated = a.concat(b, [c, d]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const otherSeries = [... array of series...];\r\n     * const concatenated = a.concat(otherSeries);\r\n     * </pre>\r\n     */    \r\n    concat (...series: (ISeries<IndexT, ValueT>[]|ISeries<IndexT, ValueT>)[]): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n    * Zip together multiple series to create a new series.\r\n    * Preserves the index of the first series.\r\n    * \r\n    * @param s2, s3, s4, s4 Multiple series to zip.\r\n    * @param zipper User-defined zipper function that merges rows. It produces values for the new series based-on values from the input series.\r\n    * \r\n    * @return Returns a single series merged from multiple input series. \r\n    * \r\n    * @example\r\n    * <pre>\r\n    * \r\n    * const a = new Series([1, 2, 3]);\r\n    * const b = new Series([10, 20, 30]);\r\n    * const zipped = a.zip(b (valueA, valueB) => valueA + valueB);\r\n    * </pre>\r\n    */    \r\n   zip<Index2T, Value2T, ResultT>  (s2: ISeries<Index2T, Value2T>, zipper: Zip2Fn<ValueT, Value2T, ResultT> ): ISeries<IndexT, ResultT>;\r\n   zip<Index2T, Value2T, Index3T, Value3T, ResultT>  (s2: ISeries<Index2T, Value2T>, s3: ISeries<Index3T, Value3T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): ISeries<IndexT, ResultT>;\r\n   zip<Index2T, Value2T, Index3T, Value3T, Index4T, Value4T, ResultT>  (s2: ISeries<Index2T, Value2T>, s3: ISeries<Index3T, Value3T>, s4: ISeries<Index4T, Value4T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): ISeries<IndexT, ResultT>;\r\n   zip<ResultT>  (...args: any[]): ISeries<IndexT, ResultT>;\r\n   \r\n    /**\r\n     * Sorts the series in ascending order by a value defined by the user-defined selector function. \r\n     * \r\n     * @param selector User-defined selector function that selects the value to sort by.\r\n     * \r\n     * @return Returns a new series that has been ordered accorrding to the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const orderedSeries = series.orderBy(value => value); \r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const orderedSeries = series.orderBy(value => value.NestedValue); \r\n     * </pre>\r\n     */\r\n    orderBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT>;\r\n\r\n    /**\r\n     * Sorts the series in descending order by a value defined by the user-defined selector function. \r\n     * \r\n     * @param selector User-defined selector function that selects the value to sort by.\r\n     * \r\n     * @return Returns a new series that has been ordered accorrding to the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const orderedSeries = series.orderByDescending(value => value); \r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const orderedSeries = series.orderByDescending(value => value.NestedValue); \r\n     * </pre>\r\n     */\r\n    orderByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT>;\r\n\r\n    /**\r\n     * Creates a new series by merging two input dataframes.\r\n     * The resulting series contains the union of value from the two input series.\r\n     * These are the unique combination of values in both series.\r\n     * This is basically a concatenation and then elimination of duplicates.\r\n     *\r\n     * @param other The other series to merge.\r\n     * @param selector Optional user-defined selector function that selects the value to compare to determine distinctness.\r\n     * \r\n     * @return Returns the union of the two series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * const seriesA = ...\r\n     * const seriesB = ...\r\n     * const merged = seriesA.union(seriesB);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Merge two sets of customer records that may contain the same\r\n     * // customer record in each set. This is basically a concatenation\r\n     * // of the series and then an elimination of any duplicate records\r\n     * // that result.\r\n     * const customerRecordsA = ...\r\n     * const customerRecordsB = ...\r\n     * const mergedCustomerRecords = customerRecordsA.union(\r\n     *      customerRecordsB, \r\n     *      customerRecord => customerRecord.CustomerId\r\n     * );\r\n     * </pre>\r\n     * \r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Note that you can achieve the exact same result as the previous\r\n     * // example by doing a {@link Series.concat) and {@link Series.distinct}\r\n     * // of the input series and then an elimination of any duplicate records\r\n     * // that result.\r\n     * const customerRecordsA = ...\r\n     * const customerRecordsB = ...\r\n     * const mergedCustomerRecords = customerRecordsA\r\n     *      .concat(customerRecordsB)\r\n     *      .distinct(customerRecord => customerRecord.CustomerId);\r\n     * </pre>\r\n     * \r\n     */\r\n    union<KeyT = ValueT> (\r\n        other: ISeries<IndexT, ValueT>, \r\n        selector?: SelectorFn<ValueT, KeyT>): \r\n            ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Creates a new series by merging two input series.\r\n     * The resulting series contains the intersection of values from the two input series.\r\n     * These are only the values that appear in both series.\r\n     *\r\n     * @param inner The inner series to merge (the series you call the function on is the 'outer' series).\r\n     * @param outerSelector Optional user-defined selector function that selects the key from the outer series that is used to match the two series.\r\n     * @param innerSelector Optional user-defined selector function that selects the key from the inner series that is used to match the two series.\r\n     * \r\n     * @return Returns a new series that contains the intersection of values from the two input series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesA = ...\r\n     * const seriesB = ...\r\n     * const mergedDf = seriesA.intersection(seriesB);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Merge two sets of customer records to find only the\r\n     * // customers that appears in both.\r\n     * const customerRecordsA = ...\r\n     * const customerRecordsB = ...\r\n     * const intersectionOfCustomerRecords = customerRecordsA.intersection(\r\n     *      customerRecordsB, \r\n     *      customerRecord => customerRecord.CustomerId\r\n     * );\r\n     * </pre>     \r\n     */    \r\n    intersection<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\r\n        inner: ISeries<InnerIndexT, InnerValueT>, \r\n        outerSelector?: SelectorFn<ValueT, KeyT>,\r\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \r\n            ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Creates a new series by merging two input series.\r\n     * The resulting series contains only the values from the 1st series that don't appear in the 2nd series.\r\n     * This is essentially subtracting the values from the 2nd series from the 1st and creating a new series with the remaining values.\r\n     *\r\n     * @param inner The inner series to merge (the series you call the function on is the 'outer' series).\r\n     * @param outerSelector Optional user-defined selector function that selects the key from the outer series that is used to match the two series.\r\n     * @param innerSelector Optional user-defined selector function that selects the key from the inner series that is used to match the two series.\r\n     * \r\n     * @return Returns a new series that contains only the values from the 1st series that don't appear in the 2nd series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesA = ...\r\n     * const seriesB = ...\r\n     * const remainingDf = seriesA.except(seriesB);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Find the list of customers haven't bought anything recently.\r\n     * const allCustomers = ... list of all customers ...\r\n     * const recentCustomers = ... list of customers who have purchased recently ...\r\n     * const remainingCustomers = allCustomers.except(\r\n     *      recentCustomers, \r\n     *      customerRecord => customerRecord.CustomerId\r\n     * );\r\n     * </pre>\r\n     */    \r\n    except<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\r\n        inner: ISeries<InnerIndexT, InnerValueT>, \r\n        outerSelector?: SelectorFn<ValueT, KeyT>,\r\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \r\n            ISeries<IndexT, ValueT>;\r\n\r\n   /**\r\n     * Creates a new series by merging two input series.\r\n     * The resulting dataframe contains only those value that have matching keys in both input series.\r\n     *\r\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * @return Returns the new merged series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought both product A and product B.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const customersWhoBoughtBothProductsDf = customerWhoBoughtProductA.join(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    join<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: ISeries<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT, InnerValueT, ResultValueT>):\r\n            ISeries<number, ResultValueT>;\r\n\r\n    /**\r\n     * Creates a new series by merging two input series.\r\n     * The resulting series contains only those values that are only present in one or the other of the series, not both.\r\n     *\r\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * Implementation from here:\r\n     * \r\n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n     * \r\n     * @return Returns the new merged series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought either product A or product B, not not both.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const customersWhoBoughtEitherProductButNotBothDf = customerWhoBoughtProductA.joinOuter(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */    \r\n    joinOuter<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: ISeries<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\r\n            ISeries<number, ResultValueT>;\r\n\r\n    /**\r\n     * Creates a new series by merging two input series.\r\n     * The resulting series contains only those values that are present either in both series or only in the outer (left) series.\r\n     * \r\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * Implementation from here:\r\n     * \r\n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n     * \r\n     * @return Returns the new merged series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought either just product A or both product A and product B.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterLeft(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    joinOuterLeft<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: ISeries<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\r\n            ISeries<number, ResultValueT>;\r\n\r\n    /**\r\n     * Creates a new series by merging two input series.\r\n     * The resulting series contains only those values that are present either in both series or only in the inner (right) series.\r\n     *\r\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * Implementation from here:\r\n     * \r\n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n     * \r\n     * @return Returns the new merged series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought either just product B or both product A and product B.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterRight(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    joinOuterRight<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: ISeries<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\r\n            ISeries<number, ResultValueT>;\r\n\r\n    /**\r\n     * Produces a new series with all string values truncated to the requested maximum length.\r\n     *\r\n     * @param maxLength - The maximum length of the string values after truncation.\r\n     * \r\n     * @returns Returns a new series with strings that are truncated to the specified maximum length. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const truncated = series.truncateStrings(10); // Truncate all string values to max length of 10 characters.\r\n     * </pre>\r\n     */\r\n    truncateStrings (maxLength: number): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Produces a new series with all number values rounded to the specified number of places.\r\n     *\r\n     * @param numDecimalPlaces The number of decimal places, defaults to 2.\r\n     * \r\n     * @returns Returns a new series with all number values rounded to the specified number of places.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = ... your data series ...\r\n     * const rounded = series.round(); // Round numbers to two decimal places.\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = ... your data series ...\r\n     * const rounded = series.round(3); // Round numbers to three decimal places.\r\n     * </pre>\r\n     */\r\n    round (numDecimalPlaces?: number): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Insert a pair at the start of the series.\r\n     * Doesn't modify the original series! The returned series is entirely new and contains values from the original series plus the inserted pair.\r\n     *\r\n     * @param pair The index/value pair to insert.\r\n     * \r\n     * @return Returns a new series with the specified pair inserted.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const newIndex = ... index of the new row ...\r\n     * const newRow = ... the new data row to insert ...\r\n     * const insertedSeries = series.insertPair([newIndex, newRows]);\r\n     * </pre>\r\n     */\r\n    insertPair (pair: [IndexT, ValueT]): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Append a pair to the end of a series.\r\n     * Doesn't modify the original series! The returned series is entirely new and contains values from the original series plus the appended pair.\r\n     *\r\n     * @param pair The index/value pair to append.\r\n     *  \r\n     * @return Returns a new series with the specified pair appended.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const newIndex = ... index of the new row ...\r\n     * const newRow = ... the new data row to append ...\r\n     * const appendedSeries = series.appendPair([newIndex, newRows]);\r\n     * </pre>\r\n     */\r\n    appendPair (pair: [IndexT, ValueT]): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Removes values from the series by index.\r\n     */\r\n    remove(index: IndexT): ISeries<IndexT, ValueT>;\r\n    \r\n    /**\r\n     * Fill gaps in a series.\r\n     *\r\n     * @param comparer User-defined comparer function that is passed pairA and pairB, two consecutive values, return truthy if there is a gap between the value, or falsey if there is no gap.\r\n     * @param generator User-defined generator function that is passed pairA and pairB, two consecutive values, returns an array of pairs that fills the gap between the values.\r\n     *\r\n     * @return Returns a new series with gaps filled in.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     *   var sequenceWithGaps = ...\r\n     *\r\n     *  // Predicate that determines if there is a gap.\r\n     *  var gapExists = (pairA, pairB) => {\r\n     *      // Returns true if there is a gap.\r\n     *      return true;\r\n     *  };\r\n     *\r\n     *  // Generator function that produces new rows to fill the game.\r\n     *  var gapFiller = (pairA, pairB) => {\r\n     *      // Create an array of index, value pairs that fill the gaps between pairA and pairB.\r\n     *      return [\r\n     *          newPair1,\r\n     *          newPair2,\r\n     *          newPair3,\r\n     *      ];\r\n     *  };\r\n     *\r\n     *  var sequenceWithoutGaps = sequenceWithGaps.fillGaps(gapExists, gapFiller);\r\n     * </pre>\r\n     */\r\n    fillGaps (comparer: ComparerFn<[IndexT, ValueT], [IndexT, ValueT]>, generator: GapFillFn<[IndexT, ValueT], [IndexT, ValueT]>): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Returns the specified default series if the input series is empty. \r\n     *\r\n     * @param defaultSequence Default series to return if the input series is empty.\r\n     * \r\n     * @return Returns 'defaultSequence' if the input series is empty. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const emptySeries = new Series();\r\n     * const defaultSeries = new Series([ 1, 2, 3 ]);\r\n     * expect(emptyDataFrame.defaultIfEmpty(defaultSeries)).to.eql(defaultSeries);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const nonEmptySeries = new Series([ 100 ]);\r\n     * const defaultSeries = new Series([ 1, 2, 3 ]);\r\n     * expect(nonEmptySeries.defaultIfEmpty(defaultSeries)).to.eql(nonEmptySeries);\r\n     * </pre>\r\n     */\r\n    defaultIfEmpty (defaultSequence: ValueT[] | ISeries<IndexT, ValueT>): ISeries<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Detect the the frequency of the types of the values in the series.\r\n     * This is a good way to understand the shape of your data.\r\n     *\r\n     * @return Returns a {@link DataFrame} with rows that confirm to {@link ITypeFrequency} that describes the data types contained in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dataTypes = series.detectTypes();\r\n     * console.log(dataTypes.toString());\r\n     * </pre>\r\n     */\r\n    detectTypes (): IDataFrame<number, ITypeFrequency>;\r\n\r\n    /**\r\n     * Detect the frequency of the values in the series.\r\n     * This is a good way to understand the shape of your data.\r\n     *\r\n     * @return Returns a {@link DataFrame} with rows that conform to {@link IValueFrequency} that describes the values contained in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dataValues = series.detectValues();\r\n     * console.log(dataValues.toString());\r\n     * </pre>\r\n     */\r\n    detectValues (): IDataFrame<number, IValueFrequency>;\r\n\r\n    /**\r\n     * Organise all values in the series into the specified number of buckets.\r\n     * Assumes that the series is a series of numbers.\r\n     * \r\n     * WARNING: This function is deprecated and will be removed in the future.\r\n     * \r\n     * @param numBuckets - The number of buckets to create.\r\n     * \r\n     * @returns Returns a dataframe containing bucketed values. The input values are divided up into these buckets.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const buckets = series.bucket(20); // Distribute values into 20 evenly spaced buckets.\r\n     * console.log(buckets.toString());\r\n     * </pre>\r\n     */\r\n    bucket (numBuckets: number): IDataFrame<IndexT, IBucket>;    \r\n\r\n    /**\r\n     * Counts frequencies in the series to produce a frequency table.\r\n     * \r\n     * @param options - Options for computing the frequency table (e.g. `numGroups` which defaults to 10).\r\n     * \r\n     * @returns Returns a dataframe for the frequency table showing the frequency for the band of values in each group.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series([ 1, 2, 3, 4 ]);\r\n     * // Or \r\n     * const series = dataFrame.getSeries(\"SomeColumn\");\r\n     *  \r\n     * const frequencyTable = series.frequency();\r\n     * console.log(frequencyTable.toArray());\r\n     * </pre>\r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series([ 37, 63, 56, 54, 39, 49, 55, 114, 59, 55 ]);\r\n     * const frequencyTable = series.frequency({ \r\n     *      lower: 40,\r\n     *      upper: 90,\r\n     *      interval: 10,\r\n     * })\r\n     * console.log(frequencyTable.toArray());\r\n     * </pre>\r\n     */\r\n    frequency (options?: IFrequencyTableOptions): IDataFrame<number, IFrequencyTableEntry>;\r\n}\r\n\r\n/**\r\n * Interface to a series that has been ordered.\r\n */\r\nexport interface IOrderedSeries<IndexT = number, ValueT = any, SortT = any> extends ISeries<IndexT, ValueT> {\r\n\r\n    /** \r\n     * Applys additional sorting (ascending) to an already sorted series.\r\n     * \r\n     * @param selector User-defined selector that selects the additional value to sort by.\r\n     * \r\n     * @return Returns a new series has been additionally sorted by the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Order sales by salesperson and then by amount (from least to most).\r\n     * const ordered = sales.orderBy(sale => sale.SalesPerson).thenBy(sale => sale.Amount);\r\n     * </pre>\r\n     */\r\n    thenBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT>;\r\n\r\n    /** \r\n     * Applys additional sorting (descending) to an already sorted series.\r\n     * \r\n     * @param selector User-defined selector that selects the additional value to sort by.\r\n     * \r\n     * @return Returns a new series has been additionally sorted by the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Order sales by salesperson and then by amount (from most to least).\r\n     * const ordered = sales.orderBy(sale => sale.SalesPerson).thenByDescending(sale => sale.Amount);\r\n     * </pre>\r\n     */\r\n    thenByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT>;\r\n}\r\n\r\n//\r\n// Represents the contents of a series.\r\n//\r\ninterface ISeriesContent<IndexT, ValueT> {\r\n\r\n    /***\r\n     * Iterates the index for the series.\r\n     */\r\n    index: Iterable<IndexT>;\r\n\r\n    /**\r\n     * Iterates values for each item in the series.\r\n     */\r\n    values: Iterable<ValueT>;\r\n\r\n    /**\r\n     * Iterates the index/value pairs in the series.\r\n     */\r\n    pairs: Iterable<[IndexT, ValueT]>;\r\n\r\n    /***\r\n      * Set to true when the dataframe has been baked into memory\r\n      * and does not need to be lazily evaluated.\r\n      */\r\n     isBaked: boolean;\r\n}\r\n\r\n/**\r\n * Class that represents a series containing a sequence of indexed values.\r\n */\r\nexport class Series<IndexT = number, ValueT = any> implements ISeries<IndexT, ValueT> {\r\n\r\n    //\r\n    // Function to lazy evaluate the configuration of the series.\r\n    //\r\n    private configFn: SeriesConfigFn<IndexT, ValueT> | null = null;\r\n\r\n    //\r\n    // The content of the series.\r\n    // When this is null it means the series is yet to be lazy initialised.\r\n    //\r\n    private content: ISeriesContent<IndexT, ValueT> | null = null;\r\n\r\n    // \r\n    // Indexed content of the dataframe.\r\n    // \r\n    private indexedContent: Map<any, ValueT> | null = null;\r\n\r\n    private static readonly defaultCountIterable = new CountIterable();\r\n    private static readonly defaultEmptyIterable = new EmptyIterable();\r\n\r\n    //\r\n    // Initialise a series from an iterator (or generator object).\r\n    //\r\n    private static initFromIterator<IndexT, ValueT>(iterator: Iterator<ValueT>): ISeriesContent<IndexT, ValueT> {\r\n        return Series.initFromIterable<IndexT, ValueT>(new CachedIteratorIterable(iterator));\r\n    }\r\n\r\n    //\r\n    // Initialise series content from an iterable of values.\r\n    //\r\n    private static initFromIterable<IndexT, ValueT>(arr: Iterable<ValueT>): ISeriesContent<IndexT, ValueT> {\r\n        return {\r\n            index: Series.defaultCountIterable,\r\n            values: arr,\r\n            pairs: new MultiIterable([Series.defaultCountIterable, arr]),\r\n            isBaked: true,\r\n        };\r\n    }\r\n\r\n    //\r\n    // Initialise an empty series.\r\n    //\r\n    private static initEmpty<IndexT, ValueT>(): ISeriesContent<IndexT, ValueT> {\r\n        return {\r\n            index: Series.defaultEmptyIterable,\r\n            values: Series.defaultEmptyIterable,\r\n            pairs: Series.defaultEmptyIterable,\r\n            isBaked: true,\r\n        };\r\n    }\r\n\r\n    //\r\n    // Returns true if the input is an iterator.\r\n    //\r\n    private static isIterator(input: any): boolean {\r\n        return isObject(input) && isFunction(input.next);\r\n    }\r\n\r\n    //\r\n    // Returns true if the input is an iterable.\r\n    //\r\n    private static isIterable(input: any): boolean {\r\n        return isArray(input) || \r\n               (isObject(input) && isFunction(input[Symbol.iterator]));\r\n    }\r\n\r\n    //\r\n    // Check that a value is an interable.\r\n    //\r\n    private static checkIterable<T>(input: any, fieldName: string): void {\r\n        if (Series.isIterable(input)) {\r\n            // Assume it's an iterable.\r\n            // Ok\r\n        }\r\n        else {\r\n            // Not ok\r\n            throw new Error(\"Expected '\" + fieldName + \"' field of Series config object to be an array of values or an iterable of values.\");\r\n        }\r\n    }\r\n\r\n    //\r\n    // Initialise series content from a config object.\r\n    //\r\n    private static initFromConfig<IndexT, ValueT>(config: ISeriesConfig<IndexT, ValueT>): ISeriesContent<IndexT, ValueT> {\r\n\r\n        let index: Iterable<IndexT>;\r\n        let values: Iterable<ValueT>;\r\n        let pairs: Iterable<[IndexT, ValueT]> | undefined;\r\n        let isBaked = false;\r\n\r\n        if (config.pairs) {\r\n            if (Series.isIterator(config.pairs)) {\r\n                pairs = new CachedIteratorIterable(config.pairs as Iterator<[IndexT, ValueT]>);\r\n            }\r\n            else {\r\n                Series.checkIterable<[IndexT, ValueT]>(config.pairs, \"pairs\");\r\n                pairs = config.pairs as Iterable<[IndexT, ValueT]>;\r\n            }\r\n        }\r\n\r\n        if (config.index) {\r\n            if (Series.isIterator(config.index)) {\r\n                index = new CachedIteratorIterable(config.index as Iterator<IndexT>);\r\n            }\r\n            else {\r\n                Series.checkIterable<IndexT>(config.index, \"index\")\r\n                index = config.index as Iterable<IndexT>;\r\n            }\r\n        }\r\n        else if (pairs) {\r\n            index = new ExtractElementIterable(pairs, 0);\r\n        }\r\n        else {\r\n            index = Series.defaultCountIterable;\r\n        }\r\n\r\n        if (config.values) {\r\n            if (Series.isIterator(config.values)) {\r\n                values = new CachedIteratorIterable(config.values as Iterator<ValueT>);\r\n            }\r\n            else {\r\n                Series.checkIterable<ValueT>(config.values, \"values\");\r\n                values = config.values as Iterable<ValueT>;\r\n            }\r\n        }\r\n        else if (pairs) {\r\n            values = new ExtractElementIterable(pairs, 1);\r\n        }\r\n        else {\r\n            values = Series.defaultEmptyIterable;\r\n        }\r\n\r\n        if (!pairs) {\r\n            pairs = new MultiIterable([index, values]);\r\n        }\r\n\r\n        if (config.baked !== undefined) {\r\n            isBaked = config.baked;\r\n        }\r\n\r\n        return {\r\n            index: index,\r\n            values: values,\r\n            pairs: pairs,\r\n            isBaked: isBaked,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create a series.\r\n     * \r\n     * @param config This can be an array, a configuration object or a function that lazily produces a configuration object. \r\n     * \r\n     * It can be an array that specifies the values that the series contains.\r\n     * \r\n     * It can be a {@link ISeriesConfig} that defines the values and configuration of the series.\r\n     * \r\n     * Or it can be a function that lazily produces a {@link ISeriesConfig}.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series();\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series([10, 20, 30, 40]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series({ index: [1, 2, 3, 4], values: [10, 20, 30, 40]});\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const lazyInit = () => ({ index: [1, 2, 3, 4], values: [10, 20, 30, 40] });\r\n     * const series = new Series(lazyInit);\r\n     * </pre>\r\n     */\r\n    constructor(config?: Iterator<ValueT> | Iterable<ValueT> | ISeriesConfig<IndexT, ValueT> | SeriesConfigFn<IndexT, ValueT>) {\r\n        if (config) {\r\n            const configAsAny = config as any;\r\n            if (configAsAny.getTypeCode !== undefined) {\r\n                const typeCode = configAsAny.getTypeCode();\r\n                if (typeCode === \"dataframe\" || typeCode === \"series\") {\r\n                    if (configAsAny.content !== undefined) {\r\n                        this.content = configAsAny.content;\r\n                    }\r\n                    else {\r\n                        this.configFn = configAsAny.configFn;\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (isFunction(config)) {\r\n                this.configFn = config;\r\n            }\r\n            else if (Series.isIterator(config)) {\r\n                this.content = Series.initFromIterator(config as Iterator<ValueT>);\r\n            }\r\n            else if (Series.isIterable(config)) {\r\n                this.content = Series.initFromIterable(config as Iterable<ValueT>);\r\n            }\r\n            else {\r\n                this.content = Series.initFromConfig(config as ISeriesConfig<IndexT, ValueT>);\r\n            }\r\n        }\r\n        else {\r\n            this.content = Series.initEmpty();\r\n        }\r\n    }\r\n\r\n    //\r\n    // Ensure the series content has been initialised.\r\n    //\r\n    private lazyInit() {\r\n        if (this.content === null && this.configFn !== null) {\r\n            this.content = Series.initFromConfig(this.configFn());\r\n        }\r\n    }\r\n\r\n    //\r\n    // Ensure the series content is lazy initalised and return it.\r\n    //\r\n    private getContent(): ISeriesContent<IndexT, ValueT> { \r\n        this.lazyInit();\r\n        return this.content!;\r\n    }\r\n\r\n    // \r\n    // Lazy builds content index, does basic hash lookup.\r\n    //\r\n    private getRowByIndex(index: IndexT): ValueT | undefined {\r\n        if (!this.indexedContent) {\r\n            this.indexedContent = new Map<any, ValueT>();\r\n            for (const pair of this.getContent().pairs) {\r\n                this.indexedContent.set(pair[0], pair[1]);\r\n            }\r\n        }\r\n       \r\n        return this.indexedContent.get(index);\r\n    }\r\n\r\n    /**\r\n     * Get an iterator to enumerate the values of the series.\r\n     * Enumerating the iterator forces lazy evaluation to complete.\r\n     * This function is automatically called by `for...of`.\r\n     * \r\n     * @return An iterator for the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * for (const value of series) {\r\n     *     // ... do something with the value ...\r\n     * }\r\n     * </pre>\r\n     */\r\n    [Symbol.iterator](): Iterator<ValueT> {\r\n        return this.getContent().values[Symbol.iterator]();\r\n    }\r\n\r\n    /**\r\n     * Cast the value of the series to a new type.\r\n     * This operation has no effect but to retype the values that the series contains.\r\n     * \r\n     * @return The same series, but with the type changed.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const castSeries = series.cast<SomeOtherType>();\r\n     * </pre>\r\n     */\r\n    cast<NewValueT> (): ISeries<IndexT, NewValueT> {\r\n        return this as any as ISeries<IndexT, NewValueT>;\r\n    }\r\n    \r\n    /**\r\n     * Get the index for the series.\r\n     * \r\n     * @return The {@link Index} for the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const index = series.getIndex();\r\n     * </pre>\r\n     */\r\n    getIndex (): IIndex<IndexT> {\r\n        return new Index<IndexT>(() => ({ values: this.getContent().index }));\r\n    }\r\n\r\n    /**\r\n     * Apply a new {@link Index} to the series.\r\n     * \r\n     * @param newIndex The new array or iterable to be the new {@link Index} of the series. Can also be a selector to choose the {@link Index} for each value in the series.\r\n     * \r\n     * @return Returns a new series with the specified {@link Index} attached.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedSeries = series.withIndex([10, 20, 30]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedSeries = series.withIndex(someOtherSeries);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedSeries = series.withIndex(value => computeIndexFromValue(value));\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedSeries = series.withIndex(value => value + 20);\r\n     * </pre>\r\n     */\r\n    withIndex<NewIndexT> (newIndex: Iterable<NewIndexT> | SelectorFn<ValueT, NewIndexT>): ISeries<NewIndexT, ValueT> {\r\n\r\n        if (isFunction(newIndex)) {\r\n            return new Series<NewIndexT, ValueT>(() => ({\r\n                values: this.getContent().values,\r\n                index: this.select(newIndex),\r\n            }));\r\n        }\r\n        else {\r\n            Series.checkIterable(newIndex as Iterable<NewIndexT>, 'newIndex');\r\n            \r\n            return new Series<NewIndexT, ValueT>(() => ({\r\n                values: this.getContent().values,\r\n                index: newIndex as Iterable<NewIndexT>,\r\n            }));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the {@link Index} of the series back to the default zero-based sequential integer index.\r\n     * \r\n     * @return Returns a new series with the {@link Index} reset to the default zero-based index. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithResetIndex = series.resetIndex();\r\n     * </pre>\r\n     */\r\n    resetIndex (): ISeries<number, ValueT> {\r\n        return new Series<number, ValueT>(() => ({\r\n            values: this.getContent().values // Just strip the index.\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Merge multiple series into a single series.\r\n     * Values are merged by index.\r\n     * Values at each index are combined into arrays in the resulting series.\r\n     * \r\n     * @param series An array or series of series to merge.\r\n     * \r\n     * @returns The merged series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const mergedSeries = Series.merge([series1, series2, etc]);\r\n     * </pre>\r\n     */\r\n    static merge<MergedValueT = any, IndexT = any>(series: Iterable<ISeries<IndexT, any>>): ISeries<IndexT, MergedValueT[]> {\r\n\r\n        const rowMap = new Map<IndexT, any[]>();\r\n        const numSeries = Array.from(series).length; //TODO: Be nice not to have to do this.\r\n        let seriesIndex = 0;\r\n        for (const workingSeries of series) {\r\n            for (const pair of workingSeries.toPairs()) {\r\n                const index = pair[0];\r\n                if (!rowMap.has(index)) {\r\n                    rowMap.set(index, new Array(numSeries));\r\n                }\r\n\r\n                rowMap.get(index)![seriesIndex] = pair[1];\r\n            }\r\n\r\n            ++seriesIndex;\r\n        }\r\n\r\n        const mergedPairs = Array.from(rowMap.keys())\r\n            .map(index => [index, rowMap.get(index)] as [IndexT, MergedValueT[]]);\r\n\r\n        mergedPairs.sort((a, b) => { // Sort by index, ascending.\r\n            if (a[0] === b[0]) {\r\n                return 0;\r\n            }\r\n            else if (a[0] > b[0]) {\r\n                return 1;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        });\r\n\r\n        return new Series<IndexT, MergedValueT[]>({\r\n            pairs: mergedPairs,\r\n        });\r\n    }\r\n\r\n   /**\r\n     * Merge one or more series into this series.\r\n     * Values are merged by index.\r\n     * Values at each index are combined into arrays in the resulting series.\r\n     * \r\n     * @param series... One or more other series to merge into the series.\r\n     * \r\n     * @returns The merged series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const mergedSeries = series1.merge(series2);\r\n     * </pre>\r\n     * \r\n     * <pre>\r\n     * \r\n     * const mergedSeries = series1.merge(series2, series3, etc);\r\n     * </pre>\r\n     */\r\n    merge<MergedValueT = any>(...args: any[]): ISeries<IndexT, MergedValueT[]> {\r\n        return Series.merge<MergedValueT, IndexT>([this].concat(args));\r\n    }\r\n    \r\n    /**\r\n    * Extract values from the series as an array.\r\n    * This forces lazy evaluation to complete.\r\n    * \r\n    * @return Returns an array of the values contained within the series.\r\n    * \r\n    * @example\r\n    * <pre>\r\n    * const values = series.toArray();\r\n    * </pre>\r\n    */\r\n   toArray (): any[] {\r\n        const values = [];\r\n        for (const value of this.getContent().values) {\r\n            if (value !== undefined && value !== null) {\r\n                values.push(value);\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n\r\n    /**\r\n     * Retreive the index, values pairs from the series as an array.\r\n     * Each pair is [index, value].\r\n     * This forces lazy evaluation to complete.\r\n     * \r\n     * @return Returns an array of pairs that contains the series values. Each pair is a two element array that contains an index and a value.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const pairs = series.toPairs();\r\n     * </pre>\r\n     */\r\n    toPairs (): ([IndexT, ValueT])[] {\r\n        const pairs = [];\r\n        for (const pair of this.getContent().pairs) {\r\n            if (pair[1] !== undefined && pair[1] !== null) {\r\n                pairs.push(pair);\r\n            }\r\n        }\r\n        return pairs;\r\n    }\r\n\r\n    /**\r\n     * Convert the series to a JavaScript object.\r\n     *\r\n     * @param keySelector User-defined selector function that selects keys for the resulting object.\r\n     * @param valueSelector User-defined selector function that selects values for the resulting object.\r\n     * \r\n     * @return Returns a JavaScript object generated from the series by applying the key and value selector functions. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const someObject = series.toObject(\r\n     *      value => value, // Specify the value to use for field names in the output object.\r\n     *      value => value // Specify the value to use as the value for each field.\r\n     * );\r\n     * </pre>\r\n     */\r\n    toObject<KeyT = any, FieldT = any, OutT = any> (keySelector: (value: ValueT) => KeyT, valueSelector: (value: ValueT) => FieldT): OutT {\r\n\r\n        if (!isFunction(keySelector)) throw new Error(\"Expected 'keySelector' parameter to Series.toObject to be a function.\");\r\n        if (!isFunction(valueSelector)) throw new Error(\"Expected 'valueSelector' parameter to Series.toObject to be a function.\");\r\n\r\n        return toMap(this, keySelector, valueSelector);\r\n    }\r\n    \r\n    /**\r\n     * Transforms an input series, generating a new series.\r\n     * The transformer function is called for each element of the input and the collection of outputs creates the generated series.\r\n     * \r\n     * `select` is an alias for {@link Series.map}.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.map` but maps over a data series rather than an array.\r\n     *\r\n     * @param transformer A user-defined transformer function that transforms each element from the input to generate the output.\r\n     * \r\n     * @return Returns the series generated by calling the transformer function over each value in the input series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = // ... construct output from input ...\r\n     *      return output;\r\n     * }\r\n     *  \r\n     * const transformed = series.select(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n     select<ToT> (transformer: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT> {\r\n        if (!isFunction(transformer)) throw new Error(\"Expected 'transformer' parameter to 'Series.select' to be a function.\");\r\n\r\n        return this.map<ToT>(transformer);\r\n    }\r\n\r\n    /**\r\n     * Transforms an input series, generating a new series.\r\n     * The transformer function is called for each element of the input and the collection of outputs creates the generated series.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.map` but maps over a data series rather than an array.\r\n     *\r\n     * @param transformer A user-defined transformer function that transforms each element from the input to generate the output.\r\n     * \r\n     * @return Returns a new series generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = // ... construct output from input ...\r\n     *      return output;\r\n     * }\r\n     *  \r\n     * const transformed = series.map(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n     map<ToT> (transformer: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT> {\r\n        if (!isFunction(transformer)) throw new Error(\"Expected 'transformer' parameter to 'Series.map' to be a function.\");\r\n\r\n        return new Series(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                values: new SelectIterable(content.values, transformer),\r\n                index: content.index,\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Transforms and flattens an input series, generating a new series.\r\n     * The transformer function is called for each value in the input series and produces an array that is then flattened into the generated series.\r\n     * \r\n     * `selectMany` is an alias for {@link Series.flatMap}.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.flatMap` but maps over a data series rather than an array.\r\n     * \r\n     * @param transformer A user-defined function that transforms each value into an array that is then flattened into the generated series.\r\n     * \r\n     * @return Returns a new series generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = [];\r\n     *      while (someCondition) {\r\n     *          // ... generate zero or more outputs from a single input ...\r\n     *          output.push(... some generated value ...);\r\n     *      }\r\n     *      return output;\r\n     * }\r\n     * \r\n     * const transformed = series.selectMany(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n    selectMany<ToT> (transformer: SelectorWithIndexFn<ValueT, Iterable<ToT>>): ISeries<IndexT, ToT> {\r\n        if (!isFunction(transformer)) throw new Error(\"Expected 'transformer' parameter to 'Series.selectMany' to be a function.\");\r\n\r\n        return this.flatMap<ToT>(transformer);\r\n    }\r\n\r\n    /**\r\n     * Transforms and flattens an input series, generating a new series.\r\n     * The transformer function is called for each value in the input series and produces an array that is then flattened into the generated series.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.flatMap` but maps over a data series rather than an array.\r\n     * \r\n     * @param transformer A user-defined function that transforms each value into an array that is then flattened into the generated series.\r\n     * \r\n     * @return Returns a new series generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = [];\r\n     *      while (someCondition) {\r\n     *          // ... generate zero or more outputs from a single input ...\r\n     *          output.push(... some generated value ...);\r\n     *      }\r\n     *      return output;\r\n     * }\r\n     * \r\n     * const transformed = series.flatMap(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n    flatMap<ToT> (transformer: SelectorWithIndexFn<ValueT, Iterable<ToT>>): ISeries<IndexT, ToT> {\r\n        if (!isFunction(transformer)) throw new Error(\"Expected 'transformer' parameter to 'Series.flatMap' to be a function.\");\r\n\r\n        return new Series(() => ({\r\n            pairs: new SelectManyIterable(\r\n                this.getContent().pairs, \r\n                (pair: [IndexT, ValueT], index: number): Iterable<[IndexT, ToT]> => {\r\n                    const outputPairs: [IndexT, ToT][] = [];\r\n                    for (const transformed of transformer(pair[1], index)) {\r\n                        outputPairs.push([\r\n                            pair[0],\r\n                            transformed\r\n                        ]);\r\n                    }\r\n                    return outputPairs;\r\n                }\r\n            )\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Partition a series into a {@link Series} of *data windows*. \r\n     * Each value in the new series is a chunk of data from the original series.\r\n     *\r\n     * @param period The number of values to include in each data window.\r\n     * @param whichIndex Sets which side of the window the index comes from: start or end. Can be \"start\" or \"end\", defaults to \"end\".\r\n     * \r\n     * @return Returns a new series, each value of which is a chunk (data window) of the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const windows = series.window(2); // Get values in pairs.\r\n     * const pctIncrease = windows.select(pair => (pair.last() - pair.first()) / pair.first());\r\n     * console.log(pctIncrease.toString());\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesDf = ... // Daily sales data.\r\n     * const weeklySales = salesDf.window(7); // Partition up into weekly data sets.\r\n     * console.log(weeklySales.toString());\r\n     * </pre>\r\n     */\r\n    window (period: number, whichIndex?: WhichIndex): ISeries<IndexT, ISeries<IndexT, ValueT>> {\r\n\r\n        if (!isNumber(period)) throw new Error(\"Expected 'period' parameter to 'Series.window' to be a number.\");\r\n\r\n        return new Series<IndexT, ISeries<IndexT, ValueT>>(() => ({\r\n            pairs: new SeriesWindowIterable<IndexT, ValueT>(this.getContent().pairs, period, whichIndex || WhichIndex.End),\r\n        }));\r\n    }\r\n\r\n    /** \r\n     * Partition a series into a new series of *rolling data windows*. \r\n     * Each value in the new series is a rolling chunk of data from the original series.\r\n     *\r\n     * @param period The number of data values to include in each data window.\r\n     * @param whichIndex Sets which side of the window the index comes from: start or end. Can be \"start\" or \"end\", defaults to \"end\".\r\n     * \r\n     * @return Returns a new series, each value of which is a rolling chunk of the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesData = ... // Daily sales data.\r\n     * const rollingWeeklySales = salesData.rollingWindow(7); // Get rolling window over weekly sales data.\r\n     * console.log(rollingWeeklySales.toString());\r\n     * </pre>\r\n     */\r\n    rollingWindow (period: number, whichIndex?: WhichIndex): ISeries<IndexT, ISeries<IndexT, ValueT>> {\r\n\r\n        if (!isNumber(period)) throw new Error(\"Expected 'period' parameter to 'Series.rollingWindow' to be a number.\");\r\n\r\n        return new Series<IndexT, ISeries<IndexT, ValueT>>(() => ({\r\n            pairs: new SeriesRollingWindowIterable<IndexT, ValueT>(this.getContent().pairs, period, whichIndex || WhichIndex.End),\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Partition a series into a new series of variable-length *data windows* \r\n     * where the divisions between the data chunks are\r\n     * defined by a user-provided *comparer* function.\r\n     * \r\n     * @param comparer Function that compares two adjacent data values and returns true if they should be in the same window.\r\n     * \r\n     * @return Returns a new series, each value of which is a chunk of data from the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function rowComparer (valueA, valueB) {\r\n     *      if (... valueA should be in the same data window as valueB ...) {\r\n     *          return true;\r\n     *      }\r\n     *      else {\r\n     *          return false;\r\n     *      }\r\n     * };\r\n     * \r\n     * const variableWindows = series.variableWindow(rowComparer);\r\n     */\r\n    variableWindow (comparer: ComparerFn<ValueT, ValueT>): ISeries<number, ISeries<IndexT, ValueT>> {\r\n        \r\n        if (!isFunction(comparer)) throw new Error(\"Expected 'comparer' parameter to 'Series.variableWindow' to be a function.\")\r\n\r\n        return new Series<number, ISeries<IndexT, ValueT>>(() => ({\r\n            values: new SeriesVariableWindowIterable<IndexT, ValueT>(this.getContent().pairs, comparer)\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Eliminates adjacent duplicate values.\r\n     * \r\n     * For each group of adjacent values that are equivalent only returns the last index/row for the group, \r\n     * thus ajacent equivalent values are collapsed down to the last value.\r\n     *\r\n     * @param selector Optional selector function to determine the value used to compare for equivalence.\r\n     * \r\n     * @return Returns a new series with groups of adjacent duplicate vlaues collapsed to a single value per group.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithDuplicateRowsRemoved = series.sequentialDistinct(value => value);\r\n     * \r\n     * // Or\r\n     * const seriesWithDuplicateRowsRemoved = series.sequentialDistinct(value => value.someNestedField);\r\n     * </pre>\r\n     */\r\n    sequentialDistinct<ToT = ValueT> (selector?: SelectorFn<ValueT, ToT>): ISeries<IndexT, ValueT> {\r\n        \r\n        if (selector) {\r\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'Series.sequentialDistinct' to be a selector function that determines the value to compare for duplicates.\")\r\n        }\r\n        else {\r\n            selector = (value: ValueT): ToT => <ToT> <any> value;\r\n        }\r\n\r\n        return this.variableWindow((a, b) => selector!(a) === selector!(b))\r\n            .select((window): [IndexT, ValueT] => {\r\n                return [window.getIndex().first(), window.first()] ;\r\n            })\r\n            .withIndex(pair => pair[0])\r\n            .select(pair => pair[1]);\r\n    }\r\n\r\n    /**\r\n     * Reduces the values in the series to a single result.\r\n     *\r\n     * `aggregate` is similar to {@link Series.reduce}, but the parameters are reversed. \r\n     * Please use {@link Series.reduce} in preference to `aggregate`.\r\n     *\r\n     * @param seed Optional seed value for producing the aggregation.\r\n     * @param reducer Function that takes the seed and then each value in the series and produces the reduced value.\r\n     * \r\n     * @return Returns a new value that has been reduced from the input series by passing it through the 'reducer' function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dailySales = ... daily sales figures for the past month ...\r\n     * const totalSalesForthisMonth = dailySales.aggregate(\r\n     *      0, // Seed - the starting value.\r\n     *      (accumulator, salesAmount) => accumulator + salesAmount // Aggregation function.\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const previousSales = 500; // We'll seed the aggregation with this value.\r\n     * const dailySales = ... daily sales figures for the past month ...\r\n     * const updatedSales = dailySales.aggregate(\r\n     *      previousSales, \r\n     *      (accumulator, salesAmount) => accumulator + salesAmount\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * var salesDataSummary = salesData.aggregate({\r\n     *      TotalSales: series => series.count(),\r\n     *      AveragePrice: series => series.average(),\r\n     *      TotalRevenue: series => series.sum(), \r\n     * });\r\n     * </pre>\r\n     */\r\n    aggregate<ToT = ValueT> (seedOrSelector: AggregateFn<ValueT, ToT> | ToT, selector?: AggregateFn<ValueT, ToT>): ToT {\r\n\r\n        if (isFunction(seedOrSelector) && !selector) {\r\n            return this.skip(1).aggregate(<ToT> <any> this.first(), seedOrSelector);\r\n        }\r\n        else {\r\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to aggregate to be a function.\");\r\n\r\n            let accum = <ToT> seedOrSelector;\r\n\r\n            for (const value of this) {\r\n                accum = selector!(accum, value);\r\n            }\r\n\r\n            return accum;\r\n        }\r\n    }\r\n   \r\n    /**\r\n     * Reduces the values in the series to a single result.\r\n     *\r\n     * This is the same concept as the JavaScript function `Array.reduce` but reduces a data series rather than an array.\r\n\r\n     * @param reducer Function that takes the seed and then each value in the series and produces the reduced value.\r\n     * @param seed Optional initial value, if not specifed the first value in the series is used as the initial value.\r\n     * \r\n     * @return Returns a value that has been reduced from the input series by passing each element through the reducer function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dailySales = ... daily sales figures for the past month ...\r\n     * const totalSales = dailySales.reduce(\r\n     *      (accumulator, salesAmount) => accumulator + salesAmount, // Reducer function.\r\n     *      0  // Seed value, the starting value.\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const previousSales = 500; // We'll seed the reduction with this value.\r\n     * const dailySales = ... daily sales figures for the past month ...\r\n     * const updatedSales = dailySales.reduce(\r\n     *      (accumulator, salesAmount) => accumulator + salesAmount,\r\n     *      previousSales\r\n     * );\r\n     * </pre>\r\n     */\r\n    reduce<ToT = ValueT> (reducer: AggregateFn<ValueT, ToT>, seed?: ToT): ToT {\r\n        if (!isFunction(reducer)) throw new Error(\"Expected 'reducer' parameter to `Series.reduce` to be a function.\");\r\n\r\n        let accum = <ToT> seed;\r\n        let series: ISeries<any, ValueT> = this;\r\n        if (accum === undefined) {\r\n            if (series.any()) {\r\n                accum = series.first() as any as ToT;\r\n                series = series.skip(1);\r\n            }\r\n        }\r\n\r\n        for (const value of series) {\r\n            accum = reducer(accum, value);\r\n        }\r\n\r\n        return accum;\r\n    }\r\n\r\n    /**\r\n     * Compute the absolute range of values in each period.\r\n     * The range for each period is the absolute difference between largest (max) and smallest (min) values in that period.\r\n     * \r\n     * @param period - Period for computing the range.\r\n     * \r\n     * @returns Returns a new series where each value indicates the absolute range of values for each period in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const closingPrice = ... series of closing prices for a particular stock ...\r\n     * const volatility = closingPrice.amountRange(5);\r\n     * </pre>\r\n     */\r\n    amountRange (period: number, whichIndex?: WhichIndex): ISeries<IndexT, number> {\r\n        return (<ISeries<IndexT, number>> <any> this) // Have to assume this is a number series.\r\n            .rollingWindow(period, whichIndex)\r\n            .select(window => window.max() - window.min());\r\n    }   \r\n\r\n    /**\r\n     * Compute the range of values in each period in proportion to the latest value.\r\n     * The range for each period is the absolute difference between largest (max) and smallest (min) values in that period.\r\n     * Proportions are expressed as 0-1 values.\r\n     * \r\n     * @param period - Period for computing the range.\r\n     * \r\n     * @returns Returns a new series where each value indicates the proportion change from the previous number value in the original series.\r\n     * \r\n     * @returns Returns a new series where each value indicates the proportionate range of values for each period in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const closingPrice = ... series of closing prices for a particular stock ...\r\n     * const proportionVolatility = closingPrice.proportionRange(5);\r\n     * </pre>\r\n     */\r\n    proportionRange (period: number, whichIndex?: WhichIndex): ISeries<IndexT, number> {\r\n        return (<ISeries<IndexT, number>> <any> this) // Have to assume this is a number series.\r\n            .rollingWindow(period, whichIndex)\r\n            .select(window => (window.max() - window.min()) / window.last());\r\n    }    \r\n\r\n    /**\r\n     * Compute the range of values in each period in proportion to the latest value.\r\n     * The range for each period is the absolute difference between largest (max) and smallest (min) values in that period.\r\n     * Proportions are expressed as 0-1 values.\r\n     * \r\n     * @param period - Period for computing the range.\r\n     * \r\n     * @returns Returns a new series where each value indicates the proportion change from the previous number value in the original series.\r\n     * \r\n     * @returns Returns a new series where each value indicates the proportionate range of values for each period in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const closingPrice = ... series of closing prices for a particular stock ...\r\n     * const percentVolatility = closingPrice.percentRange(5);\r\n     * </pre>\r\n     */\r\n    percentRange (period: number, whichIndex?: WhichIndex): ISeries<IndexT, number> {\r\n        return this.proportionRange(period, whichIndex).select(v => v * 100);\r\n    }\r\n\r\n    /**\r\n     * Compute the amount of change between pairs or sets of values in the series.\r\n     * \r\n     * @param period Optional period for computing the change - defaults to 2.\r\n     * \r\n     * @returns Returns a new series where each value indicates the amount of change from the previous number value in the original series.  \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const saleFigures = ... running series of daily sales figures ...\r\n     * const amountChanged = salesFigures.amountChanged(); // Amount that sales has changed, day to day.\r\n     * </pre>\r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const saleFigures = ... running series of daily sales figures ...\r\n     * const amountChanged = salesFigures.amountChanged(7); // Amount that sales has changed, week to week.\r\n     * </pre>\r\n     */\r\n    amountChange (period?: number, whichIndex?: WhichIndex): ISeries<IndexT, number> {\r\n        return (<ISeries<IndexT, number>> <any> this) // Have to assume this is a number series.\r\n            .rollingWindow(period === undefined ? 2 : period, whichIndex)\r\n            .select(window => window.last() - window.first());\r\n    }   \r\n\r\n    /**\r\n     * Compute the proportion change between pairs or sets of values in the series.\r\n     * Proportions are expressed as 0-1 values.\r\n     * \r\n     * @param period Optional period for computing the proportion - defaults to 2.\r\n     * \r\n     * @returns Returns a new series where each value indicates the proportion change from the previous number value in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const saleFigures = ... running series of daily sales figures ...\r\n     * const proportionChanged = salesFigures.amountChanged(); // Proportion that sales has changed, day to day.\r\n     * </pre>\r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const saleFigures = ... running series of daily sales figures ...\r\n     * const proportionChanged = salesFigures.amountChanged(7); // Proportion that sales has changed, week to week.\r\n     * </pre>\r\n     */\r\n    proportionChange (period?: number, whichIndex?: WhichIndex): ISeries<IndexT, number> {\r\n        return (<ISeries<IndexT, number>> <any> this) // Have to assume this is a number series.\r\n            .rollingWindow(period === undefined ? 2 : period, whichIndex)\r\n            .select(window => (window.last() - window.first())  / window.first());\r\n    }    \r\n\r\n    /**\r\n     * Compute the percentage change between pairs or sets of values in the series.\r\n     * Percentages are expressed as 0-100 values.\r\n     * \r\n     * @param period Optional period for computing the percentage - defaults to 2.\r\n     * \r\n     * @returns Returns a new series where each value indicates the percent change from the previous number value in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const saleFigures = ... running series of daily sales figures ...\r\n     * const percentChanged = salesFigures.amountChanged(); // Percent that sales has changed, day to day.\r\n     * </pre>\r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const saleFigures = ... running series of daily sales figures ...\r\n     * const percentChanged = salesFigures.amountChanged(7); // Percent that sales has changed, week to week.\r\n     * </pre>\r\n     */\r\n    percentChange (period?: number, whichIndex?: WhichIndex): ISeries<IndexT, number> {\r\n        return this.proportionChange(period, whichIndex).select(v => v * 100);\r\n    }    \r\n    \r\n    /**\r\n     * For each period, compute the proportion of values that are less than the last value in the period.\r\n     * Proportions are expressed as 0-1 values.\r\n     * \r\n     * @param period Optional period for computing the proportion rank - defaults to 2.\r\n     * \r\n     * @returns Returns a new series where each value indicates the proportion rank value for that period.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const proportionRank = series.proportionRank();\r\n     * </pre>\r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const proportionRank = series.proportionRank(100);\r\n     * </pre>\r\n     */\r\n    proportionRank (period?: number): ISeries<IndexT, number> {\r\n        if (period === undefined) {\r\n            period = 2;\r\n        }\r\n\r\n        if (!isNumber(period)) {\r\n            throw new Error(\"Expected 'period' parameter to 'Series.proportionRank' to be a number that specifies the time period for the ranking.\");\r\n        }\r\n    \r\n        return this.rollingWindow(period+1) // +1 to account for the last value being used.\r\n            .select(window => {\r\n                const latestValue = window.last();\r\n                const numLowerValues = window.head(-1).filter(prevMomentum => prevMomentum < latestValue).count();\r\n                const proportionRank = numLowerValues / period!;\r\n                return proportionRank;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * For each period, compute the percent of values that are less than the last value in the period.\r\n     * Percent are expressed as 0-100 values.\r\n     * \r\n     * @param period Optional period for computing the percent rank - defaults to 2.\r\n     * \r\n     * @returns Returns a new series where each value indicates the percent rank value for that period.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const percentRank = series.percentRank();\r\n     * </pre>\r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const percentRank = series.percentRank(100);\r\n     * </pre>\r\n     */\r\n    percentRank (period?: number): ISeries<IndexT, number> {\r\n        if (period === undefined) {\r\n            period = 2;\r\n        }\r\n\r\n        if (!isNumber(period)) {\r\n            throw new Error(\"Expected 'period' parameter to 'Series.percentRank' to be a number that specifies the time period for the ranking.\");\r\n        }\r\n    \r\n        return this.proportionRank(period).select(proportion => proportion * 100);\r\n    }\r\n\r\n    /**\r\n     * Generates a cumulative sum across a series.\r\n     * \r\n     * @returns Returns a new series that is the cumulative sum of values across the input series.\r\n     */\r\n    cumsum (): ISeries<IndexT, number> {\r\n        return new Series<IndexT, number>(() => {\r\n            let working = 0;\r\n            const pairs: any[][] = this.toPairs();\r\n            const output: any = pairs.map(([index, value]) => ([index, working += value]));\r\n            return { pairs: output };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Skip a number of values in the series.\r\n     *\r\n     * @param numValues Number of values to skip.\r\n     * \r\n     * @return Returns a new series with the specified number of values skipped.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithRowsSkipped = series.skip(10); // Skip 10 rows in the original series.\r\n     * </pre>\r\n     */\r\n    skip (numValues: number): ISeries<IndexT, ValueT> {\r\n        return new Series<IndexT, ValueT>(() => ({\r\n            values: new SkipIterable(this.getContent().values, numValues),\r\n            index: new SkipIterable(this.getContent().index, numValues),\r\n            pairs: new SkipIterable(this.getContent().pairs, numValues),\r\n        }));\r\n    }\r\n    \r\n    /**\r\n     * Skips values in the series while a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Returns true/truthy to continue to skip values in the original series.\r\n     * \r\n     * @return Returns a new series with all initial sequential values removed while the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithRowsSkipped = series.skipWhile(salesFigure => salesFigure > 100); // Skip initial sales figure that are less than 100.\r\n     * </pre>\r\n     */\r\n    skipWhile (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT> {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.skipWhile' function to be a predicate function that returns true/false.\");\r\n\r\n        return new Series<IndexT, ValueT>(() => ({\r\n            values: new SkipWhileIterable(this.getContent().values, predicate),\r\n            pairs: new SkipWhileIterable(this.getContent().pairs, pair => predicate(pair[1])),\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Skips values in the series untils a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Return true/truthy to stop skipping values in the original series.\r\n     * \r\n     * @return Returns a new series with all initial sequential values removed until the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithRowsSkipped = series.skipUntil(salesFigure => salesFigure > 100); // Skip initial sales figures unitl we see one greater than 100.\r\n     * </pre>\r\n     */\r\n    skipUntil (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT> {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.skipUntil' function to be a predicate function that returns true/false.\");\r\n\r\n        return this.skipWhile(value => !predicate(value)); \r\n    }\r\n\r\n    /**\r\n     * Take a number of  values from the series.\r\n     *\r\n     * @param numValues Number of values to take.\r\n     * \r\n     * @return Returns a new series with only the specified number of values taken from the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithRowsTaken = series.take(15); // Take only the first 15 values from the original series.\r\n     * </pre>\r\n     */\r\n    take (numRows: number): ISeries<IndexT, ValueT> {\r\n        if (!isNumber(numRows)) throw new Error(\"Expected 'numRows' parameter to 'Series.take' function to be a number.\");\r\n\r\n        return new Series(() => ({\r\n            index: new TakeIterable(this.getContent().index, numRows),\r\n            values: new TakeIterable(this.getContent().values, numRows),\r\n            pairs: new TakeIterable(this.getContent().pairs, numRows)\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Takes values from the series while a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Returns true/truthy to continue to take values from the original series.\r\n     * \r\n     * @return Returns a new series with only the initial sequential values that were taken while the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithRowsTaken = series.takeWhile(salesFigure => salesFigure > 100); // Take only initial sales figures that are greater than 100.\r\n     * </pre>\r\n     */\r\n    takeWhile (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT> {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.takeWhile' function to be a predicate function that returns true/false.\");\r\n\r\n        return new Series(() => ({\r\n            values: new TakeWhileIterable(this.getContent().values, predicate),\r\n            pairs: new TakeWhileIterable(this.getContent().pairs, pair => predicate(pair[1]))\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Takes values from the series until a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Return true/truthy to stop taking values in the original series.\r\n     * \r\n     * @return Returns a new series with only the initial sequential values taken until the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesWithRowsTaken = series.takeUntil(salesFigure => salesFigure > 100); // Take all initial sales figures until we see one that is greater than 100.\r\n     * </pre>\r\n     */\r\n    takeUntil (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT> {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.takeUntil' function to be a predicate function that returns true/false.\");\r\n\r\n        return this.takeWhile(value => !predicate(value));\r\n    }\r\n\r\n    /**\r\n     * Static version of the count function for use with {@link DataFrame.summarize} and {@link DataFrame.pivot} functions.\r\n     * \r\n     * @param series Input series to be counted.\r\n     * \r\n     * @returns Returns the count of values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = dataFrame.summarize({\r\n     *      ColumnToBeCounted: Series.count,\r\n     * });\r\n     * </pre>\r\n     */\r\n    static count<IndexT = any> (series: ISeries<IndexT, number>): number {\r\n        return series.count();\r\n    }\r\n    \r\n    /**\r\n     * Count the number of values in the series.\r\n     *\r\n     * @return Returns the count of all values.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const numValues = series.count();\r\n     * </pre>\r\n     */\r\n    count (): number {\r\n\r\n        let total = 0;\r\n        for (const value of this.getContent().values) {\r\n            ++total;\r\n        }\r\n        return total;\r\n    }\r\n\r\n    /**\r\n     * Get the first value of the series.\r\n     *\r\n     * @return Returns the first value of the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const firstValue = series.first();\r\n     * </pre>\r\n     */\r\n    first (): ValueT {\r\n\r\n        for (const value of this) {\r\n            return value; // Only need the first value.\r\n        }\r\n\r\n        throw new Error(\"Series.first: No values in Series.\");\r\n    }\r\n\r\n    /**\r\n     * Get the last value of the series.\r\n     *\r\n     * @return Returns the last value of the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const lastValue = series.last();\r\n     * </pre>\r\n     */\r\n    last (): ValueT {\r\n\r\n        let lastValue = null;\r\n\r\n        for (const value of this) {\r\n            lastValue = value; // Throw away all values until we get to the last one.\r\n        }\r\n\r\n        if (lastValue === null) {\r\n            throw new Error(\"Series.last: No values in Series.\");\r\n        }\r\n\r\n        return lastValue;\r\n    }    \r\n    \r\n    /**\r\n     * Get the value, if there is one, with the specified index.\r\n     *\r\n     * @param index Index to for which to retreive the value.\r\n     *\r\n     * @return Returns the value from the specified index in the series or undefined if there is no such index in the present in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const value = series.at(5); // Get the value at index 5 (with a default 0-based index).\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const date = ... some date ...\r\n     * // Retreive the value with specified date from a time-series (assuming date indexed has been applied).\r\n     * const value = series.at(date); \r\n     * </pre>\r\n     */\r\n    at (index: IndexT): ValueT | undefined {\r\n\r\n        if (this.none()) {\r\n            return undefined;\r\n        }\r\n\r\n        return this.getRowByIndex(index);\r\n    }\r\n    \r\n    /** \r\n     * Get X value from the start of the series.\r\n     * Pass in a negative value to get all values at the head except for X values at the tail.\r\n     *\r\n     * @param numValues Number of values to take.\r\n     * \r\n     * @return Returns a new series that has only the specified number of values taken from the start of the original series.\r\n     * \r\n     * @examples\r\n     * <pre>\r\n     * \r\n     * const sample = series.head(10); // Take a sample of 10 values from the start of the series.\r\n     * </pre>\r\n     */\r\n    head (numValues: number): ISeries<IndexT, ValueT> {\r\n\r\n        if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'Series.head' function to be a number.\");\r\n\r\n        if (numValues === 0) {\r\n            return new Series<IndexT, ValueT>(); // Empty series.\r\n        }\r\n\r\n        const toTake = numValues < 0 ? this.count() - Math.abs(numValues) : numValues;\r\n        return this.take(toTake);\r\n    }\r\n\r\n    /** \r\n     * Get X values from the end of the series.\r\n     * Pass in a negative value to get all values at the tail except X values at the head.\r\n     *\r\n     * @param numValues Number of values to take.\r\n     * \r\n     * @return Returns a new series that has only the specified number of values taken from the end of the original series.  \r\n     * \r\n     * @examples\r\n     * <pre>\r\n     * \r\n     * const sample = series.tail(12); // Take a sample of 12 values from the end of the series.\r\n     * </pre>\r\n     */\r\n    tail (numValues: number): ISeries<IndexT, ValueT> {\r\n\r\n        if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'Series.tail' function to be a number.\");\r\n\r\n        if (numValues === 0) {\r\n            return new Series<IndexT, ValueT>(); // Empty series.\r\n        }\r\n\r\n        const toSkip = numValues > 0 ? this.count() - numValues : Math.abs(numValues);\r\n        return this.skip(toSkip);\r\n    }\r\n\r\n    /**\r\n     * Filter the series through a user-defined predicate function.\r\n     * \r\n     * `where` is an alias for {@link Series.filter}.\r\n     *\r\n     * This is the same concept as the JavaScript function `Array.filter` but filters a data series rather than an array.\r\n     * \r\n     * @param predicate Predicate function to filter values from the series. Returns true/truthy to keep elements, or false/falsy to omit elements.\r\n     * \r\n     * @return Returns a new series containing only the values from the original series that matched the predicate. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Filter so we only have sales figures greater than 100.\r\n     * const filtered = series.where(salesFigure => salesFigure > 100); \r\n     * console.log(filtered.toArray());\r\n     * </pre>\r\n     */\r\n    where (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT> {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.where' to be a function.\");\r\n\r\n        return this.filter(predicate);\r\n    }\r\n\r\n    /**\r\n     * Filter the series through a user-defined predicate function.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.filter` but filters a data series rather than an array.\r\n     *\r\n     * @param predicate Predicate function to filter values from the series. Returns true/truthy to keep elements, or false/falsy to omit elements.\r\n     * \r\n     * @return Returns a new series containing only the values from the original series that matched the predicate. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Filter so we only have sales figures greater than 100.\r\n     * const filtered = series.filter(salesFigure => salesFigure > 100); \r\n     * console.log(filtered.toArray());\r\n     * </pre>\r\n     */\r\n    filter (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT> {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.filter' to be a function.\");\r\n\r\n        return new Series(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                values: new WhereIterable(this.getContent().values, predicate),\r\n                pairs: new WhereIterable(this.getContent().pairs, pair => predicate(pair[1]))\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Invoke a callback function for each value in the series.\r\n     *\r\n     * @param callback The calback function to invoke for each value.\r\n     * \r\n     * @return Returns the original series with no modifications.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * series.forEach(value => {\r\n     *      // ... do something with the value ...\r\n     * });\r\n     * </pre>\r\n     */\r\n    forEach (callback: CallbackFn<ValueT>): ISeries<IndexT, ValueT> {\r\n        if (!isFunction(callback)) throw new Error(\"Expected 'callback' parameter to 'Series.forEach' to be a function.\");\r\n\r\n        let index = 0;\r\n        for (const value of this) {\r\n            callback(value, index++);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Evaluates a predicate function for every value in the series to determine \r\n     * if some condition is true/truthy for **all** values in the series.\r\n     * \r\n     * @param predicate Predicate function that receives each value. It should returns true/truthy for a match, otherwise false/falsy.\r\n     *\r\n     * @return Returns true if the predicate has returned true or truthy for every value in the series, otherwise returns false. Returns false for an empty series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.all(salesFigure => salesFigure > 100); // Returns true if all sales figures are greater than 100.\r\n     * </pre>\r\n     */\r\n    all (predicate: PredicateFn<ValueT>): boolean {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.all' to be a function.\")\r\n\r\n        let count = 0;\r\n\r\n        for (const value of this) {\r\n            if (!predicate(value)) {\r\n                return false;\r\n            }\r\n\r\n            ++count;\r\n        }\r\n\r\n        return count > 0;\r\n    }\r\n\r\n    /**\r\n     * Evaluates a predicate function for every value in the series to determine \r\n     * if some condition is true/truthy for **any** of values in the series.\r\n     * \r\n     * If no predicate is specified then it simply checks if the series contains more than zero values.\r\n     *\r\n     * @param predicate Optional predicate function that receives each value. It should return true/truthy for a match, otherwise false/falsy.\r\n     *\r\n     * @return Returns true if the predicate has returned truthy for any value in the series, otherwise returns false. \r\n     * If no predicate is passed it returns true if the series contains any values at all.\r\n     * Returns false for an empty series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.any(salesFigure => salesFigure > 100); // Do we have any sales figures greater than 100?\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.any(); // Do we have any sales figures at all?\r\n     * </pre>\r\n     */\r\n    any (predicate?: PredicateFn<ValueT>): boolean {\r\n        if (predicate) {\r\n            if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.any' to be a function.\")\r\n        }\r\n\r\n        if (predicate) {\r\n            // Use the predicate to check each value.\r\n            for (const value of this) {\r\n                if (predicate(value)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // Just check if there is at least one item.\r\n            const iterator = this[Symbol.iterator]()\r\n            return !iterator.next().done;\r\n        }\r\n\r\n        return false; // Nothing passed.\r\n    }\r\n\r\n    /**\r\n     * Evaluates a predicate function for every value in the series to determine \r\n     * if some condition is true/truthy for **none** of values in the series.\r\n     * \r\n     * If no predicate is specified then it simply checks if the series contains zero values.\r\n     *\r\n     * @param predicate Optional predicate function that receives each value. It should return true/truthy for a match, otherwise false/falsy.\r\n     *\r\n     * @return Returns true if the predicate has returned truthy for zero values in the series, otherwise returns false. Returns false for an empty series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.none(salesFigure => salesFigure > 100); // Do we have zero sales figures greater than 100?\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.none(); // Do we have zero sales figures?\r\n     * </pre>\r\n     */\r\n    none (predicate?: PredicateFn<ValueT>): boolean {\r\n\r\n        if (predicate) {\r\n            if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.none' to be a function.\")\r\n        }\r\n\r\n        if (predicate) {\r\n            // Use the predicate to check each value.\r\n            for (const value of this) {\r\n                if (predicate(value)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // Just check if empty.\r\n            const iterator = this[Symbol.iterator]()\r\n            return iterator.next().done;\r\n        }\r\n\r\n        return true; // Nothing failed the predicate.\r\n    }\r\n\r\n    /**\r\n     * Gets a new series containing all values starting at or after the specified index value.\r\n     * \r\n     * @param indexValue The index value at which to start the new series.\r\n     * \r\n     * @return Returns a new series containing all values starting at or after the specified index value. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const lastHalf = series.startAt(2);\r\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeries = ... a series indexed by date/time ...\r\n     * \r\n     * // Get all values starting at (or after) a particular date.\r\n     * const result = timeSeries.startAt(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    startAt (indexValue: IndexT): ISeries<IndexT, ValueT> {\r\n        return new Series<IndexT, ValueT>(() => {\r\n            const lessThan = this.getIndex().getLessThan();\r\n            return {                \r\n                index: new SkipWhileIterable(this.getContent().index, index => lessThan(index, indexValue)),\r\n                pairs: new SkipWhileIterable(this.getContent().pairs, pair => lessThan(pair[0], indexValue)),\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets a new series containing all values up until and including the specified index value (inclusive).\r\n     * \r\n     * @param indexValue The index value at which to end the new series.\r\n     * \r\n     * @return Returns a new series containing all values up until and including the specified index value.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const firstHalf = series.endAt(1);\r\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeries = ... a series indexed by date/time ...\r\n     * \r\n     * // Get all values ending at a particular date.\r\n     * const result = timeSeries.endAt(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    endAt (indexValue: IndexT): ISeries<IndexT, ValueT> {\r\n        return new Series<IndexT, ValueT>(() => {\r\n            const lessThanOrEqualTo = this.getIndex().getLessThanOrEqualTo();\r\n            return {\r\n                index: new TakeWhileIterable(this.getContent().index, index => lessThanOrEqualTo(index, indexValue)),\r\n                pairs: new TakeWhileIterable(this.getContent().pairs, pair => lessThanOrEqualTo(pair[0], indexValue)),\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets a new series containing all values up to the specified index value (exclusive).\r\n     * \r\n     * @param indexValue The index value at which to end the new series.\r\n     * \r\n     * @return Returns a new series containing all values up to (but not including) the specified index value. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const firstHalf = series.before(2);\r\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeries = ... a series indexed by date/time ...\r\n     * \r\n     * // Get all values before the specified date.\r\n     * const result = timeSeries.before(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    before (indexValue: IndexT): ISeries<IndexT, ValueT> {\r\n        return new Series<IndexT, ValueT>(() => {\r\n            const lessThan = this.getIndex().getLessThan();\r\n            return {\r\n                index: new TakeWhileIterable(this.getContent().index, index => lessThan(index, indexValue)),\r\n                pairs: new TakeWhileIterable(this.getContent().pairs, pair => lessThan(pair[0], indexValue)),\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets a new series containing all values after the specified index value (exclusive).\r\n     * \r\n     * @param indexValue The index value after which to start the new series.\r\n     * \r\n     * @return Returns a new series containing all values after the specified index value.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const lastHalf = df.before(1);\r\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSerie = ... a series indexed by date/time ...\r\n     * \r\n     * // Get all values after the specified date.\r\n     * const result = timeSeries.after(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */    \r\n    after (indexValue: IndexT): ISeries<IndexT, ValueT> {\r\n        return new Series<IndexT, ValueT>(() => {\r\n            const lessThanOrEqualTo = this.getIndex().getLessThanOrEqualTo();\r\n            return {\r\n                index: new SkipWhileIterable(this.getContent().index, index => lessThanOrEqualTo(index, indexValue)),\r\n                pairs: new SkipWhileIterable(this.getContent().pairs, pair => lessThanOrEqualTo(pair[0], indexValue)),\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets a new series containing all values between the specified index values (inclusive).\r\n     * \r\n     * @param startIndexValue The index at which to start the new series.\r\n     * @param endIndexValue The index at which to end the new series.\r\n     * \r\n     * @return Returns a new series containing all values between the specified index values (inclusive).\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series({ \r\n     *      index: [0, 1, 2, 3, 4, 6], // This is the default index.\r\n     *      values: [10, 20, 30, 40, 50, 60],\r\n     * });\r\n     * \r\n     * const middleSection = series.between(1, 4);\r\n     * expect(middleSection.toArray()).to.eql([20, 30, 40, 50]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeries = ... a series indexed by date/time ...\r\n     * \r\n     * // Get all values between the start and end dates (inclusive).\r\n     * const result = timeSeries.after(new Date(2016, 5, 4), new Date(2016, 5, 22)); \r\n     * </pre>\r\n     */\r\n    between (startIndexValue: IndexT, endIndexValue: IndexT): ISeries<IndexT, ValueT> {\r\n        return this.startAt(startIndexValue).endAt(endIndexValue); \r\n    }\r\n\r\n    /** \r\n     * Format the series for display as a string.\r\n     * This forces lazy evaluation to complete.\r\n     * \r\n     * @return Generates and returns a string representation of the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * console.log(series.toString());\r\n     * </pre>\r\n     */\r\n    toString (): string {\r\n\r\n        const header = [\"__index__\", \"__value__\"];\r\n        const rows = this.toPairs();\r\n\r\n        const table = new Table();\r\n        for (let rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\r\n            const row = rows[rowIndex];\r\n            for (let cellIndex = 0; cellIndex < row.length; ++cellIndex) {\r\n                const cell = row[cellIndex];\r\n                table.cell(header[cellIndex], cell);\r\n            }\r\n            table.newRow();\r\n        }\r\n\r\n        return table.toString();\r\n    }\r\n\r\n    //\r\n    // Helper function to parse a string to an int.\r\n    //\r\n    static parseInt (value: any | undefined | null, valueIndex: number): number | undefined {\r\n        if (value === undefined || value === null) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            if (!isString(value)) {\r\n                throw new Error(\"Called Series.parseInts, expected all values in the series to be strings, instead found a '\" + typeof(value) + \"' at index \" + valueIndex);\r\n            }\r\n\r\n            if (value.length === 0) {\r\n                return undefined;\r\n            }\r\n\r\n            return parseInt(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse a series with string values and convert it to a series with int values.\r\n     *\r\n     * @return Returns a new series with values parsed from strings to ints.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const parsed = series.parseInts();\r\n     * </pre>\r\n     */\r\n    parseInts (): ISeries<IndexT, number> {\r\n        return <ISeries<IndexT, number>> this.select(Series.parseInt);\r\n    }\r\n\r\n    //\r\n    // Helper function to parse a string to a float.\r\n    //\r\n    static parseFloat (value: any | undefined | null, valueIndex: number): number | undefined {\r\n        if (value === undefined || value === null) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            if (!isString(value)) throw new Error(\"Called Series.parseFloats, expected all values in the series to be strings, instead found a '\" + typeof(value) + \"' at index \" + valueIndex);\r\n\r\n            if (value.length === 0) {\r\n                return undefined;\r\n            }\r\n\r\n            return parseFloat(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse a series with string values and convert it to a series with float values.\r\n     *\r\n     * @return Returns a new series with values parsed from strings to floats.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const parsed = series.parseFloats();\r\n     * </pre>\r\n     */\r\n    parseFloats (): ISeries<IndexT, number> {\r\n        return <ISeries<IndexT, number>> this.select(Series.parseFloat);\r\n    }\r\n\r\n    //\r\n    // Helper function to parse a string to a date.\r\n    //\r\n    static parseDate (value: any | undefined | null, valueIndex: number, formatString?: string): Date | undefined {\r\n        if (value === undefined || value === null) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            if (!isString(value)) throw new Error(\"Called Series.parseDates, expected all values in the series to be strings, instead found a '\" + typeof(value) + \"' at index \" + valueIndex);\r\n\r\n            if (value.length === 0) {\r\n                return undefined;\r\n            }\r\n\r\n            return moment(value, formatString).toDate();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse a series with string values and convert it to a series with date values.\r\n     *\r\n     * @param formatString Optional formatting string for dates.\r\n     * \r\n     * Moment is used for date parsing.\r\n     * https://momentjs.com\r\n     * \r\n     * @return Returns a new series with values parsed from strings to dates.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const parsed = series.parseDates();\r\n     * </pre>\r\n     */\r\n    parseDates (formatString?: string): ISeries<IndexT, Date> {\r\n\r\n        if (formatString) {\r\n            if (!isString(formatString)) throw new Error(\"Expected optional 'formatString' parameter to Series.parseDates to be a string (if specified).\");\r\n        }\r\n\r\n        return <ISeries<IndexT, Date>> this.select((value: any | undefined, valueIndex: number) => Series.parseDate(value, valueIndex, formatString));\r\n    }\r\n\r\n    //\r\n    // Helper function to convert a value to a string.\r\n    //\r\n    static toString(value: any | undefined | null, formatString?: string): string | undefined | null {\r\n        if (value === undefined) {\r\n            return undefined;\r\n        }\r\n        else if (value === null) {\r\n            return null;\r\n        }\r\n        else if (formatString && isDate(value)) {\r\n            return moment(value).format(formatString);\r\n        }\r\n        else if (formatString && isNumber(value)) {\r\n            return numeral(value).format(formatString);\r\n        }\r\n        else {\r\n            return value.toString();\t\r\n        }\t\t\r\n    }\r\n\r\n    /**\r\n     * Convert a series of values of different types to a series containing string values.\r\n     *\r\n     * @param formatString Optional formatting string for dates.\r\n     * \r\n     * Numeral.js is used for number formatting.\r\n     * http://numeraljs.com/\r\n     * \r\n     * Moment is used for date formatting.\r\n     * https://momentjs.com/docs/#/parsing/string-format/\r\n     * \r\n     * @return Returns a new series values converted from values to strings.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.toStrings(\"YYYY-MM-DD\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = series.toStrings(\"0.00\");\r\n     * </pre>\r\n     */\r\n    toStrings (formatString?: string): ISeries<IndexT, string> {\r\n\r\n        if (formatString) {\r\n            if (!isString(formatString)) throw new Error(\"Expected optional 'formatString' parameter to Series.toStrings to be a string (if specified).\");\r\n        }\r\n\r\n        return <ISeries<IndexT, string>> this.select(value => Series.toString(value, formatString));\r\n    }\r\n\r\n    /**\r\n     * Forces lazy evaluation to complete and 'bakes' the series into memory.\r\n     * \r\n     * @return Returns a series that has been 'baked', all lazy evaluation has completed.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const baked = series.bake();\r\n     * </pre>\r\n     */\r\n    bake (): ISeries<IndexT, ValueT> {\r\n\r\n        if (this.getContent().isBaked) {\r\n            // Already baked.\r\n            return this;\r\n        }\r\n\r\n        return new Series<IndexT, ValueT>({\r\n            values: this.toArray(),\r\n            pairs: this.toPairs(),\r\n            baked: true,\r\n        });\r\n    }\r\n\r\n    /** \r\n     * Converts (inflates) a series to a {@link DataFrame}.\r\n     *\r\n     * @param selector Optional user-defined selector function that transforms each value to produce the dataframe.\r\n     *\r\n     * @returns Returns a dataframe that was created from the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dataframe = series.inflate(); // Inflate a series of objects to a dataframe.\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dataframe = series.inflate(value => { AColumn:  value }); // Produces a dataframe with 1 column from a series of values.\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dataframe = series.inflate(value => { AColumn:  value.NestedValue }); // Extract a nested value and produce a dataframe from it.\r\n     * </pre>\r\n     */\r\n    inflate<ToT = ValueT> (selector?: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT> {\r\n\r\n        if (selector) {\r\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to Series.inflate to be a selector function.\");\r\n\r\n            return new DataFrame<IndexT, ToT>(() => {\r\n                const content = this.getContent();\r\n                return {\r\n                    values: new SelectIterable(content.values, selector),\r\n                    index: content.index,\r\n                    pairs: new SelectIterable(content.pairs, (pair: [IndexT, ValueT], index: number): [IndexT, ToT] => [pair[0], selector(pair[1], index)]),\r\n                };\r\n            });\r\n        }\r\n        else {\r\n            return new DataFrame<IndexT, ToT>(() => {\r\n                const content = this.getContent();\r\n                return {\r\n                    values: <Iterable<ToT>> <any> content.values,\r\n                    index: content.index,\r\n                    pairs: <Iterable<[IndexT, ToT]>> <any> content.pairs,\r\n                };\r\n            });\r\n        }\r\n    }\r\n\r\n    //\r\n    // For functions that work with a number series convert this series to a number series.\r\n    // Throws an error if anything other than a number is found.\r\n    //\r\n    private asNumberSeries(): ISeries<IndexT, number> {\r\n        //\r\n        // From here: http://stackoverflow.com/questions/5275115/add-a-median-method-to-a-list\r\n        //\r\n        // Have to assume we are working with a number series here.\r\n        const numberSeries = <ISeries<IndexT, number>> <any> this.filter(value => value !== null && value !== undefined);\r\n\r\n        if (numberSeries.any(value => typeof(value) !== \"number\")) {\r\n            throw new Error(`Expected series to contain only numbers, you should parse this series or filter out non-number values.`);\r\n        }\r\n\r\n        return numberSeries;\r\n    }\r\n\r\n    /**\r\n     * Static version of the sum function for use with {@link DataFrame.summarize} and {@link DataFrame.pivot} functions.\r\n     * \r\n     * @param series Input series to be summed.\r\n     * \r\n     * @returns Returns the sum of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = dataFrame.summarize({\r\n     *      ColumnToBeSummed: Series.sum,\r\n     * });\r\n     * </pre>\r\n     */\r\n    static sum<IndexT = any> (series: ISeries<IndexT, number>): number {\r\n        return series.sum();\r\n    }\r\n\r\n    /**\r\n     * Sum the values in a series and returns the result.\r\n     * \r\n     * @returns Returns the sum of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const totalSales = salesFigures.sum();\r\n     * </pre>\r\n     */\r\n    sum (): number {\r\n\r\n        const numberSeries = this.asNumberSeries();\r\n        if (numberSeries.none()) {\r\n            return 0;\r\n        }\r\n\r\n        let total = 0;\r\n\r\n        for (const value of numberSeries) {\r\n            total += value;\r\n        }\r\n\r\n        return total;\r\n    }\r\n\r\n    /**\r\n     * Static version of the average function for use with {@link DataFrame.summarize} and {@link DataFrame.pivot} functions.\r\n     * \r\n     * @param series Input series to be averaged.\r\n     * \r\n     * @returns Returns the average of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = dataFrame.summarize({\r\n     *      ColumnToBeAveraged: Series.average,\r\n     * });\r\n     * </pre>\r\n     */\r\n    static average<IndexT = any> (series: ISeries<IndexT, number>): number {\r\n        return series.average();\r\n    }\r\n    \r\n    /**\r\n     * Average the values in a series and returns the result\r\n     *\r\n     * `average` is an alias of {@link Series.mean}.\r\n     *  \r\n     * @returns Returns the average of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const averageSales = salesFigures.average();\r\n     * </pre>\r\n     */\r\n    average (): number {\r\n        return this.mean();\r\n    }\r\n\r\n    /**\r\n     * Static version of the mean function for use with {@link DataFrame.summarize} and {@link DataFrame.pivot} functions.\r\n     * \r\n     * @param series Input series for which to compute the mean.\r\n     * \r\n     * @returns Returns the mean of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = dataFrame.summarize({\r\n     *      ColumnToBeAveraged: Series.mean,\r\n     * });\r\n     * </pre>\r\n     */\r\n    static mean<IndexT = any> (series: ISeries<IndexT, number>): number {\r\n        return series.mean();\r\n    }\r\n     \r\n    /**\r\n     * Computes and returns the mean value of a set of values.\r\n     * \r\n     * @returns Returns the mean of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const averageSales = salesFigures.mean();\r\n     * </pre>\r\n     */\r\n     mean (): number {\r\n\r\n        const numberSeries = this.asNumberSeries();\r\n        if (numberSeries.none()) {\r\n            return 0;\r\n        }\r\n\r\n        let total = 0;\r\n        let count = 0;\r\n\r\n        for (const value of numberSeries) {\r\n            count += 1;\r\n            total += value;\r\n        }\r\n\r\n        if (count === 0) {\r\n            return 0;\r\n        }\r\n\r\n        return total / count;\r\n     }\r\n\r\n    /**\r\n     * Static version of the median function for use with {@link DataFrame.summarize} and {@link DataFrame.pivot} functions.\r\n     * \r\n     * @param series Input series to find the median of.\r\n     * \r\n     * @returns Returns the median of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = dataFrame.summarize({\r\n     *      InputColumn: Series.median,\r\n     * });\r\n     * </pre>\r\n     */\r\n    static median<IndexT = any> (series: ISeries<IndexT, number>): number {\r\n        return series.median();\r\n    }\r\n\r\n    /**\r\n     * Get the median value in the series. \r\n     * Note that this sorts the series, which can be expensive.\r\n     * \r\n     * @returns Returns the median of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const medianSales = salesFigures.median();\r\n     * </pre>\r\n     */\r\n    median (): number {\r\n\r\n        const numberSeries = this.asNumberSeries();\r\n        const count = numberSeries.count();\r\n        if (count === 0) {\r\n            return 0;\r\n        }\r\n\r\n        const ordered = numberSeries.orderBy(value => value).toArray();\r\n        if ((count % 2) == 0) {\r\n            // Even.\r\n            const a = ordered[count / 2 - 1];\r\n            const b = ordered[count / 2];\r\n            return (a + b) / 2;\t\r\n        }\r\n\r\n        // Odd\r\n        return ordered[Math.floor(count / 2)];\r\n    }\r\n\r\n    /**\r\n     * Static version of the mode function for use with {@link DataFrame.summarize} and {@link DataFrame.pivot} functions.\r\n     * \r\n     * @param series Input series for which to find the mode.\r\n     * \r\n     * @returns Returns the mode of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = dataFrame.summarize({\r\n     *      InputColumn: Series.mode,\r\n     * });\r\n     * </pre>\r\n     */\r\n    static mode<IndexT = any> (series: ISeries<IndexT, any>): any {\r\n        return series.mode();\r\n    }\r\n\r\n    /**\r\n     * Get the mode of the values in the series. \r\n     * The mode is the most frequent value in the series.\r\n     * Note that this reads the entire series into memory, which can be expensive.\r\n     * \r\n     * @returns Returns the mode of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modeSales = salesFigures.mode();\r\n     * </pre>\r\n     */\r\n    mode (): any {\r\n\r\n        const numberSeries = this.asNumberSeries();\r\n        if (numberSeries.none()) {\r\n            return undefined;\r\n        }\r\n\r\n        const lookup = new Map<any, number>();\r\n\r\n        for (const value of numberSeries) {\r\n            if (lookup.has(value))  {\r\n                lookup.set(value, lookup.get(value)! + 1);\r\n            }\r\n            else {\r\n                lookup.set(value, 1);\r\n            }\r\n        }\r\n\r\n        const entries = Array.from(lookup.entries());\r\n        entries.sort((a, b) => b[1] - a[1]);\r\n        return entries[0][0];\r\n    }\r\n\r\n    //\r\n    // Gets the sum of squares for the series (and the count).\r\n    //\r\n    private sumOfSquares (): [number, number] {\r\n\r\n        if (this.none()) {\r\n            return [0, 1];\r\n        }\r\n\r\n        const average = this.mean();\r\n        let sumOfSquaredDiffs = 0;\r\n        const numberSeries = this.asNumberSeries();\r\n        \r\n        let count = 0;\r\n        for (const value of numberSeries) {\r\n            count += 1;\r\n            const numberValue = value as any as number;\r\n            const diffFromMean = numberValue - average; // Assume input series are numbers.\r\n            const diffFromMeanSqr = diffFromMean * diffFromMean;\r\n            sumOfSquaredDiffs += diffFromMeanSqr;\r\n        }\r\n\r\n        return [sumOfSquaredDiffs, count];\r\n    }\r\n\r\n    /**\r\n     * Static version of the (population) variance function for use with {@link DataFrame.summarize} and {@link DataFrame.pivot} functions.\r\n     * \r\n     * @param series Input series for which to find the (population) variance.\r\n     * \r\n     * @returns Returns the (population) variance of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = dataFrame.summarize({\r\n     *      InputColumn: Series.variance,\r\n     * });\r\n     * </pre>\r\n     */\r\n     static variance<IndexT = any> (series: ISeries<IndexT, number>): number {\r\n        return series.variance();\r\n    }\r\n    \r\n    /**\r\n     * Get the (population) variance of number values in the series. \r\n     * \r\n     * @returns Returns the (population) variance of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesVariance = salesFigures.variance();\r\n     * </pre>\r\n     */\r\n     variance (): number {\r\n\r\n        if (this.none()) {\r\n            return 0;\r\n        }\r\n\r\n        const [sumOfSquaredDiffs, count] = this.sumOfSquares();\r\n        return sumOfSquaredDiffs / count;\r\n    }\r\n\r\n    /**\r\n     * Static version of the (population) standard deviation function for use with {@link DataFrame.summarize} and {@link DataFrame.pivot} functions.\r\n     * \r\n     * @param series Input series for which to find the (population) standard deviation.\r\n     * \r\n     * @returns Returns the (population) standard deviation of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = dataFrame.summarize({\r\n     *      InputColumn: Series.std,\r\n     * });\r\n     * </pre>\r\n     */\r\n    static std<IndexT = any> (series: ISeries<IndexT, number>): number {\r\n        return series.std();\r\n    }\r\n    \r\n    /**\r\n     * Get the (population) standard deviation of number values in the series. \r\n     * \r\n     * @returns Returns the (population) standard deviation of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesStdDev = salesFigures.std();\r\n     * </pre>\r\n     */\r\n    std (): number {\r\n\r\n        if (this.none()) {\r\n            return 0;\r\n        }\r\n\r\n        return Math.sqrt(this.variance());\r\n    }\r\n\r\n    /**\r\n     * Standardize a series of numbers by converting each \"standard deviations from the mean\".\r\n     * This converts the input series to Z scores using the population standard deviation.\r\n     * \r\n     * @returns A new series containing Z scores computed from the input series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const standardizedSeries = series.standardize();\r\n     * </pre>\r\n     */\r\n    standardize (): ISeries<IndexT, number> {\r\n        \r\n        if (this.none()) {\r\n            // There are no values in the input series.\r\n            return new Series<IndexT, number>();\r\n        }\r\n\r\n        const mean = this.mean();\r\n        const std = this.std();\r\n        if (std === 0) {\r\n            throw new Error(`Can't standardize a series that has no variation.`);\r\n        }\r\n\r\n        const numberSeries = this.asNumberSeries();\r\n        return numberSeries.map(value => {\r\n            const zScore = (value - mean) / std;\r\n            return zScore;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Static version of the (sample) variance function for use with {@link DataFrame.summarize} and {@link DataFrame.pivot} functions.\r\n     * \r\n     * @param series Input series for which to find the (sample) variance.\r\n     * \r\n     * @returns Returns the (sample) variance of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = dataFrame.summarize({\r\n     *      InputColumn: Series.sampleVariance,\r\n     * });\r\n     * </pre>\r\n     */\r\n     static sampleVariance<IndexT = any> (series: ISeries<IndexT, number>): number {\r\n        return series.sampleVariance();\r\n    }\r\n    \r\n    /**\r\n     * Get the (sample) variance of number values in the series. \r\n     * \r\n     * @returns Returns the (sample) variance of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesVariance = salesFigures.variance();\r\n     * </pre>\r\n     */\r\n     sampleVariance (): number {\r\n\r\n        if (this.none()) {\r\n            return 0;\r\n        }\r\n\r\n        const [sumOfSquaredDiffs, count] = this.sumOfSquares();\r\n        return sumOfSquaredDiffs / (count - 1);\r\n    }\r\n\r\n    /**\r\n     * Static version of the (sample) standard deviation function for use with {@link DataFrame.summarize} and {@link DataFrame.pivot} functions.\r\n     * \r\n     * @param series Input series for which to find the (sample) standard deviation.\r\n     * \r\n     * @returns Returns the (sample) standard deviation of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = dataFrame.summarize({\r\n     *      InputColumn: Series.sampleStd,\r\n     * });\r\n     * </pre>\r\n     */\r\n    static sampleStd<IndexT = any> (series: ISeries<IndexT, number>): number {\r\n        return series.sampleStd();\r\n    }\r\n    \r\n    /**\r\n     * Get the (sample) standard deviation of number values in the series. \r\n     * \r\n     * @returns Returns the (sample) standard deviation of the values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesStdDev = salesFigures.sampleStd();\r\n     * </pre>\r\n     */\r\n    sampleStd (): number {\r\n\r\n        if (this.none()) {\r\n            return 0;\r\n        }\r\n\r\n        return Math.sqrt(this.sampleVariance());\r\n    }\r\n\r\n    /**\r\n     * Standardize a series of numbers by converting each \"standard deviations from the mean\".\r\n     * This converts the input series to Z scores using the sample standard deviation.\r\n     * \r\n     * @returns A new series containing Z scores computed from the input series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const standardizedSeries = series.sampleStandardize();\r\n     * </pre>\r\n     */\r\n    sampleStandardize (): ISeries<IndexT, number> {\r\n        \r\n        if (this.none()) {\r\n            // There are no values in the input series.\r\n            return new Series<IndexT, number>();\r\n        }\r\n\r\n        const mean = this.mean();\r\n        const std = this.sampleStd();\r\n        if (std === 0) {\r\n            throw new Error(`Can't standardize a series that has no variation.`);\r\n        }\r\n\r\n        const numberSeries = this.asNumberSeries();\r\n        return numberSeries.map(value => {\r\n            const zScore = (value - mean) / std;\r\n            return zScore;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Static version of the min function for use with {@link DataFrame.summarize} and {@link DataFrame.pivot} functions.\r\n     * \r\n     * @param series Input series to find the minimum of.\r\n     * \r\n     * @returns Returns the minimum of number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = dataFrame.summarize({\r\n     *      Column: Series.min,\r\n     * });\r\n     * </pre>\r\n     */\r\n    static min<IndexT = any> (series: ISeries<IndexT, number>): number {\r\n        return series.min();\r\n    }\r\n\r\n    /**\r\n     * Get the min value in the series.\r\n     * \r\n     * @returns Returns the minimum of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const minSales = salesFigures.min();\r\n     * </pre>\r\n     */\r\n    min (): number {\r\n\r\n        let min: number | undefined;\r\n\r\n        for (const value of this.asNumberSeries()) {\r\n            if (min === undefined) {\r\n                min = value;\r\n            }\r\n            else {\r\n                min = Math.min(min, value);\r\n            }\r\n        }\r\n\r\n        if (min === undefined) {\r\n            return 0;\r\n        }\r\n\r\n        return min;\r\n    }\r\n\r\n    /**\r\n     * Static version of the max function for use with {@link DataFrame.summarize} and {@link DataFrame.pivot} functions.\r\n     * \r\n     * @param series Input series to find the maximum of.\r\n     * \r\n     * @returns Returns the maximum of number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = dataFrame.summarize({\r\n     *      Column: Series.max,\r\n     * });\r\n     * </pre>\r\n     */\r\n    static max<IndexT = any> (series: ISeries<IndexT, number>): number {\r\n        return series.max();\r\n    }\r\n    \r\n    /**\r\n     * Get the max value in the series.\r\n     * \r\n     * @returns Returns the maximum of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const maxSales = salesFigures.max();\r\n     * </pre>\r\n     */\r\n    max (): number {\r\n\r\n        let max: number | undefined;\r\n\r\n        for (const value of this.asNumberSeries()) {\r\n            if (max === undefined) {\r\n                max = value;\r\n            }\r\n            else {\r\n                max = Math.max(max, value);\r\n            }\r\n        }\r\n\r\n        if (max === undefined) {\r\n            return 0;\r\n        }\r\n\r\n        return max;\r\n    }\r\n\r\n    /**\r\n     * Static version of the range function for use with {@link DataFrame.summarize} and {@link DataFrame.pivot} functions.\r\n     * \r\n     * @param series Input series for which to find the range of values.\r\n     * \r\n     * @returns Returns the range of number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = dataFrame.summarize({\r\n     *      Column: Series.range,\r\n     * });\r\n     * </pre>\r\n     */\r\n    static range<IndexT = any> (series: ISeries<IndexT, number>): number {\r\n        return series.range();\r\n    }\r\n    \r\n    /**\r\n     * Get the range of values in the series.\r\n     * \r\n     * @returns Returns the range of the number values in the series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const range = salesFigures.range();\r\n     * </pre>\r\n     */\r\n    range (): number {\r\n        return this.max() - this.min();\r\n    }\r\n    \r\n    /**\r\n     * Invert the sign of every number value in the series.\r\n     * This assumes that the input series contains numbers.\r\n     * \r\n     * @returns Returns a new series with all number values inverted.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const inverted = series.invert();\r\n     * </pre>\r\n     */\r\n    invert (): ISeries<IndexT, number> {\r\n        return this\r\n            .asNumberSeries()\r\n            .select(value => {\r\n                return -value;\r\n            }); \r\n    }\r\n\r\n    /**\r\n     * Counts the number of sequential values where the predicate evaluates to truthy.\r\n     * Outputs 0 for values when the predicate evaluates to falsy.\r\n     * \r\n     * @param predicate User-defined function. Should evaluate to truthy to activate the counter or falsy to deactivate it.\r\n     * \r\n     * @returns Returns a new series that counts up the number of sequential values where the predicate evaluates to truthy. 0 values appear when the prediate evaluates to falsy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series([ 1, 10, 3, 15, 8, 5 ]);\r\n     * const counted = series.counter(value => value >= 3);\r\n     * console.log(counted.toString());\r\n     * </pre>\r\n     */\r\n    counter (predicate: PredicateFn<ValueT>): ISeries<IndexT, number> {\r\n        return this.groupSequentialBy(predicate)\r\n            .selectMany((group, i) => {\r\n                if (predicate(group.first())) {\r\n                    // This group matches the predicate.\r\n                    return range(1, group.count())\r\n                        .withIndex(group.getIndex())\r\n                        .toPairs(); //TODO: selectMany wipes the index. It needs to respect it!\r\n                }\r\n                else {\r\n                    // This group doesn't match the predicate.\r\n                    return replicate(0, group.count())\r\n                        .withIndex(group.getIndex())\r\n                        .toPairs(); //TODO: selectMany wipes the index. It needs to respect it!\r\n                }\r\n            }) \r\n            .withIndex(pair => pair[0])\r\n            .select(pair => pair[1]) as any as ISeries<IndexT, number>;\r\n    }\r\n    \r\n    /** \r\n     * Gets a new series in reverse order.\r\n     * \r\n     * @return Returns a new series that is the reverse of the original.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const reversed = series.reverse();\r\n     * </pre>\r\n     */\r\n    reverse (): ISeries<IndexT, ValueT> {\r\n\r\n        return new Series<IndexT, ValueT>(() => ({\r\n            values: new ReverseIterable(this.getContent().values),\r\n            index: new ReverseIterable(this.getContent().index),\r\n            pairs: new ReverseIterable(this.getContent().pairs)\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Returns only the set of values in the series that are distinct.\r\n     * Provide a user-defined selector to specify criteria for determining the distinctness.\r\n     * This can be used to remove duplicate values from the series.\r\n     *\r\n     * @param selector Optional user-defined selector function that specifies the criteria used to make comparisons for duplicate values.\r\n     * \r\n     * @return Returns a series containing only unique values in the series. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const uniqueValues = series.distinct(); // Get only non-duplicated value in the series.\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const bucketedValues = series.distinct(value => Math.floor(value / 10)); // Lump values into buckets of 10.\r\n     * </pre>\r\n     */\r\n    distinct<ToT> (selector?: SelectorFn<ValueT, ToT>): ISeries<IndexT, ValueT> {\r\n\r\n        return new Series<IndexT, ValueT>(() => ({\r\n            values: new DistinctIterable<ValueT, ToT>(this.getContent().values, selector),\r\n            pairs: new DistinctIterable<[IndexT, ValueT],ToT>(this.getContent().pairs, (pair: [IndexT, ValueT]): ToT => selector && selector(pair[1]) || <ToT> <any> pair[1])\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Collects values in the series into a new series of groups according to a user-defined selector function.\r\n     *\r\n     * @param selector User-defined selector function that specifies the criteriay to group by.\r\n     *\r\n     * @return Returns a new series of groups. Each group is a series with values that have been grouped by the 'selector' function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const sales = ... product sales ...\r\n     * const salesByProduct = sales.groupBy(sale => sale.ProductId);\r\n     * for (const productSalesGroup of salesByProduct) {\r\n     *      // ... do something with each product group ...\r\n     *      const productId = productSalesGroup.first().ProductId;\r\n     *      const totalSalesForProduct = productSalesGroup.deflate(sale => sale.Amount).sum();\r\n     *      console.log(totalSalesForProduct);\r\n     * }\r\n     * </pre>\r\n     */\r\n    groupBy<GroupT> (selector: SelectorWithIndexFn<ValueT, GroupT>): ISeries<number, ISeries<IndexT, ValueT>> {\r\n\r\n        if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'Series.groupBy' to be a selector function that determines the value to group the series by.\");\r\n\r\n        return new Series<number, ISeries<IndexT, ValueT>>(() => {\r\n            const groups: any[] = []; // Each group, in order of discovery.\r\n            const groupMap: any = {}; // Group map, records groups by key.\r\n            \r\n            let valueIndex = 0;\r\n    \r\n            for (const pair of this.getContent().pairs) {\r\n                const groupKey = selector(pair[1], valueIndex);\r\n                ++valueIndex;\r\n                const existingGroup = groupMap[groupKey];\r\n                if (existingGroup) {\r\n                    existingGroup.push(pair);\r\n                }\r\n                else {\r\n                    const newGroup: any[] = [];\r\n                    newGroup.push(pair);\r\n                    groups.push(newGroup);\r\n                    groupMap[groupKey] = newGroup;\r\n                }\r\n            }\r\n\r\n            return {\r\n                values: groups.map(group => new Series<IndexT, ValueT>({ pairs: group }))\r\n            };            \r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Collects values in the series into a new series of groups based on if the values are the same or according to a user-defined selector function.\r\n     *\r\n     * @param selector Optional selector that specifies the criteria for grouping.\r\n     *\r\n     * @return Returns a new series of groups. Each group is a series with values that are the same or have been grouped by the 'selector' function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Some ultra simple stock trading strategy backtesting...\r\n     * const dailyStockPrice = ... daily stock price for a company ...\r\n     * const priceGroups  = dailyStockPrice.groupBy(day => day.close > day.movingAverage);\r\n     * for (const priceGroup of priceGroups) {\r\n     *      // ... do something with each stock price group ...\r\n     * \r\n     *      const firstDay = priceGroup.first();\r\n     *      if (firstDay.close > movingAverage) {\r\n     *          // This group of days has the stock price above its moving average.\r\n     *          // ... maybe enter a long trade here ...\r\n     *      }\r\n     *      else {\r\n     *          // This group of days has the stock price below its moving average.\r\n     *          // ... maybe enter a short trade here ...\r\n     *      }\r\n     * }\r\n     * </pre>\r\n     */    \r\n    groupSequentialBy<GroupT> (selector?: SelectorFn<ValueT, GroupT>): ISeries<number, ISeries<IndexT, ValueT>> {\r\n\r\n        if (selector) {\r\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'Series.groupSequentialBy' to be a selector function that determines the value to group the series by.\")\r\n        }\r\n        else {\r\n            selector = value => <GroupT> <any> value;\r\n        }\r\n        \r\n        return this.variableWindow((a: ValueT, b: ValueT): boolean => selector!(a) === selector!(b));\r\n    }\r\n\r\n    /**\r\n     * Concatenate multiple series into a single series.\r\n     *\r\n     * @param series - Array of series to concatenate.\r\n     * \r\n     * @returns Returns a single series concatenated from multiple input series. \r\n     */\r\n    static concat<IndexT = any, ValueT = any> (series: ISeries<IndexT, ValueT>[]): ISeries<IndexT, ValueT> {\r\n        if (!isArray(series)) throw new Error(\"Expected 'series' parameter to 'Series.concat' to be an array of series.\");\r\n\r\n        return new Series(() => {\r\n            const upcast = <Series<IndexT, ValueT>[]> series; // Upcast so that we can access private index, values and pairs.\r\n            const contents = upcast.map(series => series.getContent());\r\n            return {\r\n                values: new ConcatIterable(contents.map(content => content.values)),\r\n                pairs: new ConcatIterable(contents.map(content => content.pairs)),\r\n            };\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Concatenate multiple other series onto this series.\r\n     * \r\n     * @param series Multiple arguments. Each can be either a series or an array of series.\r\n     * \r\n     * @return Returns a single series concatenated from multiple input series. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenated = a.concat(b);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenated = a.concat(b, c);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenated = a.concat([b, c]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenated = a.concat(b, [c, d]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const otherSeries = [... array of series...];\r\n     * const concatenated = a.concat(otherSeries);\r\n     * </pre>\r\n     */    \r\n    concat (...series: (ISeries<IndexT, ValueT>[]|ISeries<IndexT, ValueT>)[]): ISeries<IndexT, ValueT> {\r\n        const concatInput: ISeries<IndexT, ValueT>[] = [this];\r\n\r\n        for (const input of series) {\r\n            if (isArray(input)) {\r\n                for (const subInput of input) {\r\n                    concatInput.push(subInput);\r\n                }\r\n            }\r\n            else {\r\n                concatInput.push(input);\r\n            }\r\n        }\r\n\r\n        return Series.concat<IndexT, ValueT>(concatInput);\r\n    }\r\n   \r\n    /**\r\n    * Zip together multiple series to create a new series.\r\n    * Preserves the index of the first series.\r\n    *\r\n    * @param series - An iterable of series to be zipped.\r\n    * @param zipper - Selector function that produces a new series based on the input series.\r\n    * \r\n    * @returns Returns a single series zipped from multiple input series. \r\n    */\r\n    static zip<IndexT = any, ValueT = any, ResultT = any> (series: Iterable<ISeries<IndexT, ValueT>>, zipper: ZipNFn<ValueT, ResultT>): ISeries<IndexT, ResultT> {\r\n\r\n        const input = Array.from(series);\r\n\r\n        if (input.length === 0) {\r\n            return new Series<IndexT, ResultT>();\r\n        }\r\n\r\n        const firstSeries = input[0];\r\n        if (firstSeries.none()) {\r\n            return new Series<IndexT, ResultT>();\r\n        }\r\n\r\n        return new Series<IndexT, ResultT>(() => {\r\n            const firstSeriesUpCast = <Series<IndexT, ValueT>> firstSeries;\r\n            const upcast = <Series<IndexT, ValueT>[]> input; // Upcast so that we can access private index, values and pairs.\r\n            \r\n            return {\r\n                index: <Iterable<IndexT>> firstSeriesUpCast.getContent().index,\r\n                values: new ZipIterable<ValueT, ResultT>(upcast.map(s => s.getContent().values), zipper),\r\n            };\r\n        });\r\n    }\r\n    \r\n    /**\r\n    * Merge together multiple series to create a new series.\r\n    * Preserves the index of the first series.\r\n    * \r\n    * @param s2, s3, s4, s4 Multiple series to zip.\r\n    * @param zipper User-defined zipper function that merges rows. It produces values for the new series based-on values from the input series.\r\n    * \r\n    * @return Returns a single series merged from multiple input series. \r\n    * \r\n    * @example\r\n    * <pre>\r\n    * \r\n    * const a = new Series([1, 2, 3]);\r\n    * const b = new Series([10, 20, 30]);\r\n    * const zipped = a.zip(b (valueA, valueB) => valueA + valueB);\r\n    * </pre>\r\n    */    \r\n    zip<Index2T, Value2T, ResultT>  (s2: ISeries<Index2T, Value2T>, zipper: Zip2Fn<ValueT, Value2T, ResultT> ): ISeries<IndexT, ResultT>;\r\n    zip<Index2T, Value2T, Index3T, Value3T, ResultT>  (s2: ISeries<Index2T, Value2T>, s3: ISeries<Index3T, Value3T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): ISeries<IndexT, ResultT>;\r\n    zip<Index2T, Value2T, Index3T, Value3T, Index4T, Value4T, ResultT>  (s2: ISeries<Index2T, Value2T>, s3: ISeries<Index3T, Value3T>, s4: ISeries<Index4T, Value4T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): ISeries<IndexT, ResultT>;\r\n    zip<ResultT>  (...args: any[]): ISeries<IndexT, ResultT> {\r\n\r\n        const selector: Function = args[args.length-1];\r\n        const input: ISeries<IndexT, any>[] = [this].concat(args.slice(0, args.length-1));\r\n        return Series.zip<IndexT, any, ResultT>(input, values => selector(...values));\r\n    }    \r\n\r\n    /**\r\n     * Sorts the series in ascending order by a value defined by the user-defined selector function. \r\n     * \r\n     * @param selector User-defined selector function that selects the value to sort by.\r\n     * \r\n     * @return Returns a new series that has been ordered accorrding to the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const orderedSeries = series.orderBy(value => value); \r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const orderedSeries = series.orderBy(value => value.NestedValue); \r\n     * </pre>\r\n     */\r\n    orderBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT> {\r\n        const content = this.getContent();\r\n        return new OrderedSeries<IndexT, ValueT, SortT>({\r\n            values: content.values, \r\n            pairs: content.pairs, \r\n            selector: selector, \r\n            direction: Direction.Ascending, \r\n            parent: null,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sorts the series in descending order by a value defined by the user-defined selector function. \r\n     * \r\n     * @param selector User-defined selector function that selects the value to sort by.\r\n     * \r\n     * @return Returns a new series that has been ordered accorrding to the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const orderedSeries = series.orderByDescending(value => value); \r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const orderedSeries = series.orderByDescending(value => value.NestedValue); \r\n     * </pre>\r\n     */\r\n    orderByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT> {\r\n        const content = this.getContent();\r\n        return new OrderedSeries<IndexT, ValueT, SortT>({\r\n            values: content.values, \r\n            pairs: content.pairs, \r\n            selector: selector, \r\n            direction: Direction.Descending, \r\n            parent: null,\r\n        });\r\n    }\r\n        \r\n    /**\r\n     * Creates a new series by merging two input dataframes.\r\n     * The resulting series contains the union of value from the two input series.\r\n     * These are the unique combination of values in both series.\r\n     * This is basically a concatenation and then elimination of duplicates.\r\n     *\r\n     * @param other The other series to merge.\r\n     * @param selector Optional user-defined selector function that selects the value to compare to determine distinctness.\r\n     * \r\n     * @return Returns the union of the two series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * const seriesA = ...\r\n     * const seriesB = ...\r\n     * const merged = seriesA.union(seriesB);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Merge two sets of customer records that may contain the same\r\n     * // customer record in each set. This is basically a concatenation\r\n     * // of the series and then an elimination of any duplicate records\r\n     * // that result.\r\n     * const customerRecordsA = ...\r\n     * const customerRecordsB = ...\r\n     * const mergedCustomerRecords = customerRecordsA.union(\r\n     *      customerRecordsB, \r\n     *      customerRecord => customerRecord.CustomerId\r\n     * );\r\n     * </pre>\r\n     * \r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Note that you can achieve the exact same result as the previous\r\n     * // example by doing a {@link Series.concat) and {@link Series.distinct}\r\n     * // of the input series and then an elimination of any duplicate records\r\n     * // that result.\r\n     * const customerRecordsA = ...\r\n     * const customerRecordsB = ...\r\n     * const mergedCustomerRecords = customerRecordsA\r\n     *      .concat(customerRecordsB)\r\n     *      .distinct(customerRecord => customerRecord.CustomerId);\r\n     * </pre>\r\n     * \r\n     */\r\n    union<KeyT = ValueT> (\r\n        other: ISeries<IndexT, ValueT>, \r\n        selector?: SelectorFn<ValueT, KeyT>): \r\n            ISeries<IndexT, ValueT> {\r\n\r\n        if (selector) {\r\n            if (!isFunction(selector)) throw new Error(\"Expected optional 'selector' parameter to 'Series.union' to be a selector function.\");\r\n        }\r\n\r\n        return this.concat(other).distinct(selector);\r\n    }\r\n\r\n    /**\r\n     * Creates a new series by merging two input series.\r\n     * The resulting series contains the intersection of values from the two input series.\r\n     * These are only the values that appear in both series.\r\n     *\r\n     * @param inner The inner series to merge (the series you call the function on is the 'outer' series).\r\n     * @param outerSelector Optional user-defined selector function that selects the key from the outer series that is used to match the two series.\r\n     * @param innerSelector Optional user-defined selector function that selects the key from the inner series that is used to match the two series.\r\n     * \r\n     * @return Returns a new series that contains the intersection of values from the two input series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesA = ...\r\n     * const seriesB = ...\r\n     * const mergedDf = seriesA.intersection(seriesB);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Merge two sets of customer records to find only the\r\n     * // customers that appears in both.\r\n     * const customerRecordsA = ...\r\n     * const customerRecordsB = ...\r\n     * const intersectionOfCustomerRecords = customerRecordsA.intersection(\r\n     *      customerRecordsB, \r\n     *      customerRecord => customerRecord.CustomerId\r\n     * );\r\n     * </pre>     \r\n     */    \r\n    intersection<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\r\n        inner: ISeries<InnerIndexT, InnerValueT>, \r\n        outerSelector?: SelectorFn<ValueT, KeyT>,\r\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \r\n            ISeries<IndexT, ValueT> {\r\n\r\n        if (outerSelector) {\r\n            if (!isFunction(outerSelector)) throw new Error(\"Expected optional 'outerSelector' parameter to 'Series.intersection' to be a function.\");\r\n        }\r\n        else {\r\n            outerSelector = value => <KeyT> <any> value;\r\n        }\r\n        \r\n        if (innerSelector) {\r\n            if (!isFunction(innerSelector)) throw new Error(\"Expected optional 'innerSelector' parameter to 'Series.intersection' to be a function.\");\r\n        }\r\n        else {\r\n            innerSelector = value => <KeyT> <any> value;\r\n        }\r\n\r\n        const outer = this;\r\n        return outer.filter(outerValue => {\r\n                const outerKey = outerSelector!(outerValue);\r\n                return inner\r\n                    .filter(innerValue => outerKey === innerSelector!(innerValue))\r\n                    .any();\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Creates a new series by merging two input series.\r\n     * The resulting series contains only the values from the 1st series that don't appear in the 2nd series.\r\n     * This is essentially subtracting the values from the 2nd series from the 1st and creating a new series with the remaining values.\r\n     *\r\n     * @param inner The inner series to merge (the series you call the function on is the 'outer' series).\r\n     * @param outerSelector Optional user-defined selector function that selects the key from the outer series that is used to match the two series.\r\n     * @param innerSelector Optional user-defined selector function that selects the key from the inner series that is used to match the two series.\r\n     * \r\n     * @return Returns a new series that contains only the values from the 1st series that don't appear in the 2nd series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const seriesA = ...\r\n     * const seriesB = ...\r\n     * const remainingDf = seriesA.except(seriesB);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Find the list of customers haven't bought anything recently.\r\n     * const allCustomers = ... list of all customers ...\r\n     * const recentCustomers = ... list of customers who have purchased recently ...\r\n     * const remainingCustomers = allCustomers.except(\r\n     *      recentCustomers, \r\n     *      customerRecord => customerRecord.CustomerId\r\n     * );\r\n     * </pre>\r\n     */    \r\n    except<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\r\n        inner: ISeries<InnerIndexT, InnerValueT>, \r\n        outerSelector?: SelectorFn<ValueT, KeyT>,\r\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \r\n            ISeries<IndexT, ValueT> {\r\n\r\n        if (outerSelector) {\r\n            if (!isFunction(outerSelector)) throw new Error(\"Expected optional 'outerSelector' parameter to 'Series.except' to be a function.\");\r\n        }\r\n        else {\r\n            outerSelector = value => <KeyT> <any> value;\r\n        }\r\n\r\n        if (innerSelector) {\r\n            if (!isFunction(innerSelector)) throw new Error(\"Expected optional 'innerSelector' parameter to 'Series.except' to be a function.\");\r\n        }\r\n        else {\r\n            innerSelector = value => <KeyT> <any> value;\r\n        }\r\n\r\n        const outer = this;\r\n        return outer.filter(outerValue => {\r\n                const outerKey = outerSelector!(outerValue);\r\n                return inner\r\n                    .filter(innerValue => outerKey === innerSelector!(innerValue))\r\n                    .none();\r\n            });\r\n    }\r\n\r\n   /**\r\n     * Creates a new series by merging two input series.\r\n     * The resulting dataframe contains only those value that have matching keys in both input series.\r\n     *\r\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * @return Returns the new merged series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought both product A and product B.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const customersWhoBoughtBothProductsDf = customerWhoBoughtProductA.join(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    join<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: ISeries<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT, InnerValueT, ResultValueT>):\r\n            ISeries<number, ResultValueT> {\r\n\r\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'Series.join' to be a selector function.\");\r\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'Series.join' to be a selector function.\");\r\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'Series.join' to be a selector function.\");\r\n\r\n        const outer = this;\r\n\r\n        return new Series<number, ResultValueT>(() => {\r\n            const innerMap = inner\r\n                .groupBy(innerKeySelector)\r\n                .toObject(\r\n                    group => innerKeySelector(group.first()), \r\n                    group => group\r\n                );\r\n\r\n            const outerContent = outer.getContent();\r\n\r\n            const output: ResultValueT[] = [];\r\n            \r\n            for (const outerValue of outer) { //TODO: There should be an enumerator that does this.\r\n                const outerKey = outerKeySelector(outerValue);\r\n                const innerGroup = innerMap[outerKey];\r\n                if (innerGroup) {\r\n                    for (const innerValue of innerGroup) {\r\n                        output.push(resultSelector(outerValue, innerValue));\r\n                    }    \r\n                }\r\n            }\r\n\r\n            return {\r\n                values: output\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new series by merging two input series.\r\n     * The resulting series contains only those values that are only present in one or the other of the series, not both.\r\n     *\r\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * Implementation from here:\r\n     * \r\n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n     * \r\n     * @return Returns the new merged series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought either product A or product B, not not both.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const customersWhoBoughtEitherProductButNotBothDf = customerWhoBoughtProductA.joinOuter(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */    \r\n    joinOuter<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: ISeries<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\r\n            ISeries<number, ResultValueT> {\r\n\r\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'Series.joinOuter' to be a selector function.\");\r\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'Series.joinOuter' to be a selector function.\");\r\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'Series.joinOuter' to be a selector function.\");\r\n\r\n        // Get the results in the outer that are not in the inner.\r\n        const outer = this;\r\n        const outerResult = outer.except<InnerIndexT, InnerValueT, KeyT>(inner, outerKeySelector, innerKeySelector)\r\n            .select(outer => resultSelector(outer, null))\r\n            .resetIndex();\r\n\r\n        // Get the results in the inner that are not in the outer.\r\n        const innerResult = inner.except<IndexT, ValueT, KeyT>(outer, innerKeySelector, outerKeySelector)\r\n            .select(inner => resultSelector(null, inner))\r\n            .resetIndex();\r\n\r\n        // Get the intersection of results between inner and outer.\r\n        const intersectionResults = outer.join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner, outerKeySelector, innerKeySelector, resultSelector);\r\n\r\n        return outerResult\r\n            .concat(intersectionResults)\r\n            .concat(innerResult)\r\n            .resetIndex();\r\n    }\r\n\r\n    /**\r\n     * Creates a new series by merging two input series.\r\n     * The resulting series contains only those values that are present either in both series or only in the outer (left) series.\r\n     * \r\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * Implementation from here:\r\n     * \r\n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n     * \r\n     * @return Returns the new merged series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought either just product A or both product A and product B.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterLeft(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    joinOuterLeft<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: ISeries<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\r\n            ISeries<number, ResultValueT> {\r\n\r\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'Series.joinOuterLeft' to be a selector function.\");\r\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'Series.joinOuterLeft' to be a selector function.\");\r\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'Series.joinOuterLeft' to be a selector function.\");\r\n\r\n        // Get the results in the outer that are not in the inner.\r\n        const outer = this;\r\n        const outerResult = outer.except<InnerIndexT, InnerValueT, KeyT>(inner, outerKeySelector, innerKeySelector)\r\n            .select(outer => resultSelector(outer, null))\r\n            .resetIndex();\r\n\r\n        // Get the intersection of results between inner and outer.\r\n        const intersectionResults = outer.join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner, outerKeySelector, innerKeySelector, resultSelector);\r\n\r\n        return outerResult\r\n            .concat(intersectionResults)\r\n            .resetIndex();\r\n    }\r\n\r\n    /**\r\n     * Creates a new series by merging two input series.\r\n     * The resulting series contains only those values that are present either in both series or only in the inner (right) series.\r\n     *\r\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * Implementation from here:\r\n     * \r\n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n     * \r\n     * @return Returns the new merged series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought either just product B or both product A and product B.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterRight(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    joinOuterRight<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: ISeries<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\r\n            ISeries<number, ResultValueT> {\r\n\r\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'Series.joinOuterRight' to be a selector function.\");\r\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'Series.joinOuterRight' to be a selector function.\");\r\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'Series.joinOuterRight' to be a selector function.\");\r\n\r\n        // Get the results in the inner that are not in the outer.\r\n        const outer = this;\r\n        const innerResult = inner.except<IndexT, ValueT, KeyT>(outer, innerKeySelector, outerKeySelector)\r\n            .select(inner => resultSelector(null, inner))\r\n            .resetIndex();\r\n\r\n        // Get the intersection of results between inner and outer.\r\n        const intersectionResults = outer.join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner, outerKeySelector, innerKeySelector, resultSelector);\r\n\r\n        return intersectionResults\r\n            .concat(innerResult)\r\n            .resetIndex();\r\n    }    \r\n\r\n    /**\r\n     * Produces a new series with all string values truncated to the requested maximum length.\r\n     *\r\n     * @param maxLength - The maximum length of the string values after truncation.\r\n     * \r\n     * @returns Returns a new series with strings that are truncated to the specified maximum length. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const truncated = series.truncateStrings(10); // Truncate all string values to max length of 10 characters.\r\n     * </pre>\r\n     */\r\n    truncateStrings (maxLength: number): ISeries<IndexT, ValueT> {\r\n\r\n        if (!isNumber(maxLength)) {\r\n            throw new Error(\"Expected 'maxLength' parameter to 'Series.truncateStrings' to be a number.\");\r\n        }\r\n\r\n        return this.select((value: any) => {\r\n            if (isString(value)) {\r\n                if (value.length > maxLength) {\r\n                    return value.substring(0, maxLength);\r\n                }\r\n            }\r\n\r\n            return value;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Produces a new series with all number values rounded to the specified number of places.\r\n     *\r\n     * @param numDecimalPlaces The number of decimal places, defaults to 2.\r\n     * \r\n     * @returns Returns a new series with all number values rounded to the specified number of places.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = ... your data series ...\r\n     * const rounded = series.round(); // Round numbers to two decimal places.\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = ... your data series ...\r\n     * const rounded = series.round(3); // Round numbers to three decimal places.\r\n     * </pre>\r\n     */\r\n    round (numDecimalPlaces?: number): ISeries<IndexT, ValueT> {\r\n\r\n        if (numDecimalPlaces !== undefined) {\r\n            if (!isNumber(numDecimalPlaces)) {\r\n                throw new Error(\"Expected 'numDecimalPlaces' parameter to 'Series.round' to be a number.\");\r\n            }\r\n        }\r\n        else {\r\n            numDecimalPlaces = 2; // Default to two decimal places.\r\n        }\r\n        \r\n        return this.select((value: any) => {\r\n            if (isNumber(value)) {\r\n                return parseFloat(value.toFixed(numDecimalPlaces));\r\n            }\r\n\r\n            return value;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Insert a pair at the start of the series.\r\n     * Doesn't modify the original series! The returned series is entirely new and contains values from the original series plus the inserted pair.\r\n     *\r\n     * @param pair The index/value pair to insert.\r\n     * \r\n     * @return Returns a new series with the specified pair inserted.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const newIndex = ... index of the new row ...\r\n     * const newRow = ... the new data row to insert ...\r\n     * const insertedSeries = series.insertPair([newIndex, newRows]);\r\n     * </pre>\r\n     */\r\n    insertPair (pair: [IndexT, ValueT]): ISeries<IndexT, ValueT> {\r\n        if (!isArray(pair)) throw new Error(\"Expected 'pair' parameter to 'Series.insertPair' to be an array.\");\r\n        if (pair.length !== 2) throw new Error(\"Expected 'pair' parameter to 'Series.insertPair' to be an array with two elements. The first element is the index, the second is the value.\");\r\n\r\n        return (new Series<IndexT, ValueT>({ pairs: [pair] })).concat(this);\r\n    }\r\n\r\n    /**\r\n     * Append a pair to the end of a series.\r\n     * Doesn't modify the original series! The returned series is entirely new and contains values from the original series plus the appended pair.\r\n     *\r\n     * @param pair The index/value pair to append.\r\n     *  \r\n     * @return Returns a new series with the specified pair appended.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const newIndex = ... index of the new row ...\r\n     * const newRow = ... the new data row to append ...\r\n     * const appendedSeries = series.appendPair([newIndex, newRows]);\r\n     * </pre>\r\n     */\r\n    appendPair (pair: [IndexT, ValueT]): ISeries<IndexT, ValueT> {\r\n        if (!isArray(pair)) throw new Error(\"Expected 'pair' parameter to 'Series.appendPair' to be an array.\");\r\n        if (pair.length !== 2) throw new Error(\"Expected 'pair' parameter to 'Series.appendPair' to be an array with two elements. The first element is the index, the second is the value.\");\r\n\r\n        return this.concat(new Series<IndexT, ValueT>({ pairs: [pair] }));\r\n    }\r\n\r\n    /**\r\n     * Removes values from the series by index.\r\n     */\r\n     remove(index: IndexT): ISeries<IndexT, ValueT> {\r\n\r\n        return new Series<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                pairs: new WhereIterable(content.pairs, pair => pair[0] !== index),\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fill gaps in a series.\r\n     *\r\n     * @param comparer User-defined comparer function that is passed pairA and pairB, two consecutive values, return truthy if there is a gap between the value, or falsey if there is no gap.\r\n     * @param generator User-defined generator function that is passed pairA and pairB, two consecutive values, returns an array of pairs that fills the gap between the values.\r\n     *\r\n     * @return Returns a new series with gaps filled in.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     *   var sequenceWithGaps = ...\r\n     *\r\n     *  // Predicate that determines if there is a gap.\r\n     *  var gapExists = (pairA, pairB) => {\r\n     *      // Returns true if there is a gap.\r\n     *      return true;\r\n     *  };\r\n     *\r\n     *  // Generator function that produces new rows to fill the game.\r\n     *  var gapFiller = (pairA, pairB) => {\r\n     *      // Create an array of index, value pairs that fill the gaps between pairA and pairB.\r\n     *      return [\r\n     *          newPair1,\r\n     *          newPair2,\r\n     *          newPair3,\r\n     *      ];\r\n     *  };\r\n     *\r\n     *  var sequenceWithoutGaps = sequenceWithGaps.fillGaps(gapExists, gapFiller);\r\n     * </pre>\r\n     */\r\n    fillGaps (comparer: ComparerFn<[IndexT, ValueT], [IndexT, ValueT]>, generator: GapFillFn<[IndexT, ValueT], [IndexT, ValueT]>): ISeries<IndexT, ValueT> {\r\n        if (!isFunction(comparer)) throw new Error(\"Expected 'comparer' parameter to 'Series.fillGaps' to be a comparer function that compares two values and returns a boolean.\")\r\n        if (!isFunction(generator)) throw new Error(\"Expected 'generator' parameter to 'Series.fillGaps' to be a generator function that takes two values and returns an array of generated pairs to span the gap.\")\r\n\r\n        return this.rollingWindow(2)\r\n            .selectMany((window): [IndexT, ValueT][] => {\r\n                const pairs = window.toPairs();\r\n                const pairA = pairs[0];\r\n                const pairB = pairs[1];\r\n                if (!comparer(pairA, pairB)) {\r\n                    return [pairA];\r\n                }\r\n\r\n                const generatedRows = generator(pairA, pairB);\r\n                if (!isArray(generatedRows)) throw new Error(\"Expected return from 'generator' parameter to 'Series.fillGaps' to be an array of pairs, instead got a \" + typeof(generatedRows));\r\n\r\n                return [pairA].concat(generatedRows);\r\n            })\r\n            .withIndex(pair => pair[0])\r\n            .select(pair => pair[1])\r\n            .concat(this.tail(1));\r\n    }\r\n\r\n    /**\r\n     * Returns the specified default series if the input series is empty. \r\n     *\r\n     * @param defaultSequence Default series to return if the input series is empty.\r\n     * \r\n     * @return Returns 'defaultSequence' if the input series is empty. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const emptySeries = new Series();\r\n     * const defaultSeries = new Series([ 1, 2, 3 ]);\r\n     * expect(emptyDataFrame.defaultIfEmpty(defaultSeries)).to.eql(defaultSeries);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const nonEmptySeries = new Series([ 100 ]);\r\n     * const defaultSeries = new Series([ 1, 2, 3 ]);\r\n     * expect(nonEmptySeries.defaultIfEmpty(defaultSeries)).to.eql(nonEmptySeries);\r\n     * </pre>\r\n     */\r\n    defaultIfEmpty (defaultSequence: ValueT[] | ISeries<IndexT, ValueT>): ISeries<IndexT, ValueT> {\r\n\r\n        if (this.none()) {\r\n            if (defaultSequence instanceof Series) {\r\n                return <ISeries<IndexT, ValueT>> defaultSequence;\r\n            }\r\n            else if (isArray(defaultSequence)) {\r\n                return new Series<IndexT, ValueT>(defaultSequence);\r\n            }\r\n            else {\r\n                throw new Error(\"Expected 'defaultSequence' parameter to 'Series.defaultIfEmpty' to be an array or a series.\");\r\n            }\r\n        } \r\n        else {\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detect the the frequency of the types of the values in the series.\r\n     * This is a good way to understand the shape of your data.\r\n     *\r\n     * @return Returns a {@link DataFrame} with rows that confirm to {@link ITypeFrequency} that describes the data types contained in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dataTypes = series.detectTypes();\r\n     * console.log(dataTypes.toString());\r\n     * </pre>\r\n     */\r\n    detectTypes (): IDataFrame<number, ITypeFrequency> {\r\n\r\n        return new DataFrame<number, ITypeFrequency>(() => {\r\n            const totalValues = this.count();\r\n\r\n            const typeFrequencies = this.select(value => {\r\n                    let valueType: string = typeof(value);\r\n                    if (valueType === \"object\") {\r\n                        if (isDate(value)) {\r\n                            valueType = \"date\";\r\n                        }\r\n                    }\r\n                    return valueType;\r\n                })\r\n                .aggregate({}, (accumulated: any, valueType: string) => {\r\n                    var typeInfo = accumulated[valueType];\r\n                    if (!typeInfo) {\r\n                        typeInfo = {\r\n                            count: 0\r\n                        };\r\n                        accumulated[valueType] = typeInfo;\r\n                    }\r\n                    ++typeInfo.count;\r\n                    return accumulated;\r\n                });\r\n\r\n            return {\r\n                columnNames: [\"Type\", \"Frequency\"],\r\n                rows: Object.keys(typeFrequencies)\r\n                    .map(valueType => {\r\n                        return [\r\n                            valueType,\r\n                            (typeFrequencies[valueType].count / totalValues) * 100\r\n                        ];\r\n                    })\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detect the frequency of the values in the series.\r\n     * This is a good way to understand the shape of your data.\r\n     *\r\n     * @return Returns a {@link DataFrame} with rows that conform to {@link IValueFrequency} that describes the values contained in the original series.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dataValues = series.detectValues();\r\n     * console.log(dataValues.toString());\r\n     * </pre>\r\n     */\r\n    detectValues (): IDataFrame<number, IValueFrequency> {\r\n\r\n        return new DataFrame<number, IValueFrequency>(() => {\r\n            const totalValues = this.count();\r\n            const valueFrequencies = this.aggregate(new Map<any, any>(), (accumulated: Map<any, any>, value: any) => {\r\n                let valueInfo = accumulated.get(value);\r\n                if (!valueInfo) {\r\n                    valueInfo = {\r\n                        count: 0,\r\n                        value: value,\r\n                    };\r\n                    accumulated.set(value, valueInfo);\r\n                }\r\n                ++valueInfo.count;\r\n                return accumulated;\r\n            });\r\n\r\n            return {\r\n                columnNames: [\"Value\", \"Frequency\"],\r\n                rows: Array.from(valueFrequencies.keys())\r\n                    .map(value => {\r\n                        const valueInfo = valueFrequencies.get(value);\r\n                        return [\r\n                            valueInfo.value,\r\n                            (valueInfo.count / totalValues) * 100\r\n                        ];\r\n                    }),\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Organise all values in the series into the specified number of buckets.\r\n     * Assumes that the series is a series of numbers.\r\n     *\r\n     * WARNING: This function is deprecated and will be removed in the future.\r\n     *  \r\n     * @param numBuckets - The number of buckets to create.\r\n     * \r\n     * @returns Returns a dataframe containing bucketed values. The input values are divided up into these buckets.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const buckets = series.bucket(20); // Distribute values into 20 evenly spaced buckets.\r\n     * console.log(buckets.toString());\r\n     * </pre>\r\n     */\r\n    bucket (numBuckets: number): IDataFrame<IndexT, IBucket> {\r\n\r\n        console.warn(`Series.bucket is deprecated and will be removed in the future.`);\r\n\r\n        if (!isNumber(numBuckets)) {\r\n            throw new Error(`Expected 'numBuckets' parameter to 'Series.bucket' to be a number.`);\r\n        }\r\n\r\n        if (this.none()) {\r\n            return new DataFrame();\r\n        }\r\n\r\n        const numberSeries = this as any as ISeries<IndexT, number>;\r\n        var min = numberSeries.min();\r\n        var max = numberSeries.max();\r\n        var range = max - min;\r\n        var width = range / (numBuckets-1);\r\n        return numberSeries.select(v => {\r\n                var bucket = Math.floor((v - min) / width);\r\n                var bucketMin = (bucket * width) + min;\r\n                return {\r\n                    Value: v,\r\n                    Bucket: bucket,\r\n                    Min: bucketMin,\r\n                    Mid: bucketMin + (width*0.5),\r\n                    Max: bucketMin + width,\r\n                };\r\n            })\r\n            .inflate();\r\n    }\r\n\r\n    /**\r\n     * Counts frequencies in the series to produce a frequency table.\r\n     * \r\n     * @param options - Options for computing the frequency table (e.g. `numGroups` which defaults to 10).\r\n     * \r\n     * @returns Returns a dataframe for the frequency table showing the frequency for the band of values in each group.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series([ 1, 2, 3, 4 ]);\r\n     * // Or \r\n     * const series = dataFrame.getSeries(\"SomeColumn\");\r\n     *  \r\n     * const frequencyTable = series.frequency();\r\n     * console.log(frequencyTable.toArray());\r\n     * </pre>\r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = new Series([ 37, 63, 56, 54, 39, 49, 55, 114, 59, 55 ]);\r\n     * const frequencyTable = series.frequency({ \r\n     *      lower: 40,\r\n     *      upper: 90,\r\n     *      interval: 10,\r\n     * })\r\n     * console.log(frequencyTable.toArray());\r\n     * </pre>\r\n     */\r\n    frequency (options?: IFrequencyTableOptions): IDataFrame<number, IFrequencyTableEntry> {\r\n\r\n        if (this.none()) {\r\n            return new DataFrame();\r\n        }\r\n\r\n        return new DataFrame(() => {\r\n            const numberSeries = this as any as ISeries<IndexT, number>;\r\n\r\n            const captureValues = options && options.captureValues || false;\r\n\r\n            let min = Number.MAX_VALUE;\r\n            let max = Number.MIN_VALUE;\r\n            let numValues = 0;\r\n\r\n            //\r\n            // Compute min, max and total.\r\n            //\r\n            for (const value of numberSeries) {\r\n                min = Math.min(value, min);\r\n                max = Math.max(value, max);\r\n                numValues += 1;\r\n            }\r\n\r\n            let lower: number;\r\n            if (options && options.lower !== undefined) {\r\n                lower = options.lower;\r\n            }\r\n            else {\r\n                lower = min;\r\n            }\r\n\r\n            let upper: number;\r\n            if (options && options.upper !== undefined) {\r\n                upper = options.upper;\r\n            }\r\n            else {\r\n                upper = max;\r\n            }\r\n\r\n            let interval = options && options.interval;\r\n\r\n            const range = upper - lower;\r\n            let numGroups: number;\r\n            if (interval !== undefined) {\r\n                numGroups = Math.ceil(range / interval);\r\n            }\r\n            else {\r\n                numGroups = 10;\r\n            }\r\n            \r\n            if (numValues < numGroups) {\r\n                numGroups = numValues;\r\n            }\r\n\r\n            if (interval === undefined) {\r\n                interval = range / (numGroups-1); \r\n            }\r\n\r\n            const groups = new Array<IFrequencyTableEntry>(numGroups);\r\n\r\n            // \r\n            // Initialize groups.\r\n            //\r\n            for (let groupIndex = 0; groupIndex < numGroups; ++groupIndex) {\r\n                const minValue = lower + (groupIndex * interval);\r\n                groups[groupIndex] = {\r\n                    lower: minValue,\r\n                    upper: minValue + interval,\r\n                    count: 0,\r\n                    proportion: 0,  \r\n                    cumulative: 0,\r\n                };\r\n\r\n                if (captureValues) {\r\n                    groups[groupIndex].values = [];\r\n                }\r\n            }\r\n\r\n            const beforeGroup: IFrequencyTableEntry = {\r\n                upper: lower,\r\n                count: 0,\r\n                proportion: 0,  \r\n                cumulative: 0,\r\n            };\r\n            if (captureValues) {\r\n                beforeGroup.values = [];\r\n            }\r\n\r\n            const afterGroup: IFrequencyTableEntry = {\r\n                lower: upper,\r\n                count: 0,\r\n                proportion: 0,  \r\n                cumulative: 0,\r\n            };\r\n            if (captureValues) {\r\n                afterGroup.values = [];\r\n            }\r\n\r\n            //\r\n            // Count groups.\r\n            //\r\n            for (const value of numberSeries) {\r\n                let group: IFrequencyTableEntry;\r\n                if (value < lower) {\r\n                    group = beforeGroup; // Value is less than the body of the data set.\r\n                }\r\n                else if (value > upper) {\r\n                    group = afterGroup; // Value is more than the body of the data set.\r\n                }\r\n                else {\r\n                    const groupIndex = Math.floor((value - lower) / interval);\r\n                    group = groups[groupIndex]; // Value is within the body of the data set.\r\n                }\r\n                group.count += 1;\r\n                if (captureValues) {\r\n                    group.values!.push(value);\r\n                }\r\n            }\r\n\r\n            let cumulative = 0;\r\n\r\n            if (beforeGroup.count > 0) {\r\n                groups.unshift(beforeGroup);\r\n            }\r\n\r\n            if (afterGroup.count > 0) {\r\n                groups.push(afterGroup)\r\n            }\r\n\r\n            //\r\n            // Compute proportions.\r\n            //\r\n            for (const group of groups) {\r\n                group.proportion = group.count / numValues;\r\n                cumulative += group.proportion;\r\n                group.cumulative = cumulative; \r\n            }\r\n\r\n            return {\r\n                values: groups,\r\n            };\r\n        });\r\n    }\r\n\r\n    /***\r\n     * Allows the series to be queried to confirm that it is actually a series.\r\n     * Used from JavaScript to tell the difference between a Series and a DataFrame.\r\n     * \r\n     * @return Returns the string \"series\".\r\n     */\r\n    getTypeCode (): string {\r\n        return \"series\";\r\n    }    \r\n}\r\n\r\n/**\r\n * @hidden\r\n * The configuration for an ordered series.\r\n */\r\ninterface IOrderedSeriesConfig<IndexT, ValueT, SortT> {\r\n\r\n    //\r\n    // The source values for the ordered series.\r\n    //\r\n    values: Iterable<ValueT>;\r\n\r\n    //\r\n    // The source pairs (index,value) for the ordered series.\r\n    //\r\n    pairs: Iterable<[IndexT, ValueT]>;\r\n\r\n    //\r\n    // The selector used to get the sorting key for the orderby operation.\r\n    //\r\n    selector: SelectorWithIndexFn<ValueT, SortT>;\r\n\r\n    //\r\n    // The sort direction, ascending or descending.\r\n    //\r\n    direction: Direction;\r\n\r\n    //\r\n    // The parent series in the orderby operation or null if none.\r\n    //\r\n    parent: OrderedSeries<IndexT, ValueT, any> | null;\r\n}\r\n\r\n/**\r\n * @hidden\r\n * A series that has been ordered.\r\n */\r\nclass OrderedSeries<IndexT = number, ValueT = any, SortT = any> \r\n    extends Series<IndexT, ValueT>\r\n    implements IOrderedSeries<IndexT, ValueT, SortT> {\r\n\r\n    //\r\n    // Configuration for the ordered series.\r\n    //\r\n    config: IOrderedSeriesConfig<IndexT, ValueT, SortT>;\r\n\r\n    //\r\n    // Helper function to create a sort spec.\r\n    //\r\n    private static makeSortSpec (sortLevel: number, selector: SortSelectorFn, direction: Direction): ISortSpec {\r\n        return { sortLevel: sortLevel, selector: selector, direction: direction };\r\n    }\r\n\r\n    //\r\n    // Helper function to make a sort selector for pairs, this captures the parent correct when generating the closure.\r\n    //\r\n    private static makePairsSelector (selector: SortSelectorFn): SortSelectorFn {\r\n        return (pair: any, index: number) => selector(pair[1], index);\r\n    }\r\n\r\n    constructor(config: IOrderedSeriesConfig<IndexT, ValueT, SortT>) {\r\n\r\n        const valueSortSpecs: ISortSpec[] = [];\r\n        const pairSortSpecs: ISortSpec[] = [];\r\n        let sortLevel = 0;\r\n\r\n        let parent = config.parent;\r\n        const parents = [];\r\n        while (parent !== null) {\r\n            parents.push(parent);\r\n            parent = parent.config.parent;\r\n        }\r\n\r\n        parents.reverse();\r\n\r\n        for (const parent of parents) {\r\n            const parentConfig = parent.config;\r\n            valueSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, parentConfig.selector, parentConfig.direction));\r\n            pairSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, OrderedSeries.makePairsSelector(parentConfig.selector), parentConfig.direction));\r\n            ++sortLevel;\r\n        }\r\n\r\n        valueSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, config.selector, config.direction));\r\n        pairSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, OrderedSeries.makePairsSelector(config.selector), config.direction));\r\n\r\n        super({\r\n            values: new OrderedIterable(config.values, valueSortSpecs),\r\n            pairs: new OrderedIterable(config.pairs, pairSortSpecs)\r\n        });\r\n\r\n        this.config = config;\r\n    }\r\n\r\n    /** \r\n     * Applys additional sorting (ascending) to an already sorted series.\r\n     * \r\n     * @param selector User-defined selector that selects the additional value to sort by.\r\n     * \r\n     * @return Returns a new series has been additionally sorted by the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Order sales by salesperson and then by amount (from least to most).\r\n     * const ordered = sales.orderBy(sale => sale.SalesPerson).thenBy(sale => sale.Amount);\r\n     * </pre>\r\n     */\r\n    thenBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT> {\r\n        return new OrderedSeries<IndexT, ValueT, SortT>({\r\n            values: this.config.values, \r\n            pairs: this.config.pairs, \r\n            selector: selector, \r\n            direction: Direction.Ascending, \r\n            parent: this,\r\n        });\r\n    }\r\n\r\n    /** \r\n     * Applys additional sorting (descending) to an already sorted series.\r\n     * \r\n     * @param selector User-defined selector that selects the additional value to sort by.\r\n     * \r\n     * @return Returns a new series has been additionally sorted by the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Order sales by salesperson and then by amount (from most to least).\r\n     * const ordered = sales.orderBy(sale => sale.SalesPerson).thenByDescending(sale => sale.Amount);\r\n     * </pre>\r\n     */\r\n    thenByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT> {\r\n        return new OrderedSeries<IndexT, ValueT, SortT>({\r\n            values: this.config.values,\r\n            pairs: this.config.pairs, \r\n            selector: selector, \r\n            direction: Direction.Descending, \r\n            parent: this\r\n        });\r\n    }\r\n}\r\n","import { ArrayIterable }  from './iterables/array-iterable';\r\nimport { EmptyIterable }  from './iterables/empty-iterable';\r\nimport { CountIterable }  from './iterables/count-iterable';\r\nimport { MultiIterable }  from './iterables/multi-iterable';\r\nimport { SelectIterable }  from './iterables/select-iterable';\r\nimport { SelectManyIterable }  from './iterables/select-many-iterable';\r\nimport { TakeIterable }  from './iterables/take-iterable';\r\nimport { TakeWhileIterable }  from './iterables/take-while-iterable';\r\nimport { WhereIterable }  from './iterables/where-iterable';\r\nimport { ConcatIterable }  from './iterables/concat-iterable';\r\nimport { DataFrameWindowIterable }  from './iterables/dataframe-window-iterable';\r\nimport { ReverseIterable }  from './iterables/reverse-iterable';\r\nimport { ZipIterable }  from './iterables/zip-iterable';\r\nimport { CsvRowsIterable }  from './iterables/csv-rows-iterable';\r\nimport { DistinctIterable }  from './iterables/distinct-iterable';\r\nimport { DataFrameRollingWindowIterable }  from './iterables/dataframe-rolling-window-iterable';\r\nimport { DataFrameVariableWindowIterable }  from './iterables/dataframe-variable-window-iterable';\r\nimport { OrderedIterable, Direction, ISortSpec, SelectorFn as SortSelectorFn }  from './iterables/ordered-iterable';\r\nimport { IIndex, Index } from './index';\r\nimport { ExtractElementIterable } from './iterables/extract-element-iterable';\r\nimport { SkipIterable } from './iterables/skip-iterable';\r\nimport { SkipWhileIterable } from './iterables/skip-while-iterable';\r\nimport { RepeatIterable } from './iterables/repeat-iterable';\r\nimport { TileIterable } from './iterables/tile-iterable';\r\nimport { RavelIterable } from './iterables/ravel-iterable';\r\n// @ts-ignore\r\nimport Table from 'easy-table';\r\n// @ts-ignore\r\nimport moment from \"dayjs\";\r\nimport { ISeries, Series, SelectorWithIndexFn, PredicateFn, ComparerFn, SelectorFn, AggregateFn, Zip2Fn, Zip3Fn, Zip4Fn, Zip5Fn, ZipNFn, CallbackFn, JoinFn, GapFillFn, ISeriesConfig } from './series';\r\nimport { ColumnNamesIterable } from './iterables/column-names-iterable';\r\nimport { toMap, makeDistinct, mapIterable, determineType, toMap2, isArray, isString, isFunction, isObject, isUndefined, isNumber } from './utils';\r\nimport { ISerializedDataFrame } from \"@data-forge/serialization\";\r\nimport JSON5 from 'json5';\r\n\r\n// @ts-ignore\r\nimport PapaParse from 'papaparse';\r\nimport { CachedIteratorIterable } from './iterables/cached-iterator-iterable';\r\n\r\n/** \r\n * An object whose fields specify the data for named columns.\r\n */\r\nexport interface IColumnSpec {\r\n    [index: string]: Iterator<any> | Iterable<any> | ISeries<any, any>,\r\n}\r\n\r\n/**\r\n * Specifies the format per column when converting columns to strings.\r\n */\r\nexport interface IFormatSpec {\r\n    [index: string]: string;\r\n}\r\n\r\n/**\r\n * An function that aggregates a series.\r\n */\r\nexport type SeriesAggregatorFn<IndexT, ValueT, OutputT> = (values: ISeries<IndexT, ValueT>) => OutputT;\r\n\r\n/**\r\n * Specification that can produce multiple output columns from a single input column of a dataframe.\r\n */\r\nexport interface IColumnAggregatorSpec {\r\n    [outputColumnName: string]: SeriesAggregatorFn<any, any, any>,\r\n} \r\n\r\n/**\r\n * Specification that can aggregate multiple input columns in a dataframe to produce multiple output columns.\r\n */\r\nexport interface IMultiColumnAggregatorSpec {\r\n    [inputColumnName: string]: SeriesAggregatorFn<any, any, any> | IColumnAggregatorSpec;\r\n}\r\n\r\n/**\r\n * Defines the configuration for a new column.\r\n */\r\nexport interface IColumnConfig {\r\n    /**\r\n     * The name of the new column.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The series of values for the column.\r\n     */\r\n    series: Iterable<any> | ISeries<any, any>;\r\n}\r\n\r\n/**\r\n * Options for CSV output.\r\n * \r\n * The options object is passed directly to [PapaParse.unparse](https://www.papaparse.com/docs#unparse), please see [PapaParse docs for additional options](https://www.papaparse.com/docs#unparse-config-default).\r\n */\r\nexport interface ICSVOutputOptions {\r\n    /**\r\n     * Enable or disable output of the CSV header line.\r\n     * Defaults to true.\r\n     */\r\n    header?: boolean;\r\n}\r\n\r\n/**\r\n * Used to configure a dataframe.\r\n */\r\nexport interface IDataFrameConfig<IndexT, ValueT> {\r\n    /**\r\n     * Values to put in the dataframe.\r\n     * This should be array or iterable of JavaScript objects.\r\n     * Each element in the array contains fields that match the columns of the dataframe.\r\n     */\r\n    values?: Iterator<ValueT> | Iterable<ValueT>;\r\n\r\n    /**\r\n     * CSV style rows to put in the dataframe.\r\n     * An array of arrays. Each element in the top level array is a row of data.\r\n     * Each row of data contains field values in column order.\r\n     */\r\n    rows?: Iterator<any[]> | Iterable<any[]>;\r\n\r\n    /***\r\n     * The index for the dataframe.\r\n     * If omitted the index will default to a 0-based index.\r\n     */\r\n    index?: Iterator<IndexT> | Iterable<IndexT>;\r\n\r\n    /**\r\n     * Array or iterable of index,value pairs to put in the dataframe.\r\n     * If index and values are not separately specified they can be extracted\r\n     * from the pairs.\r\n     */\r\n    pairs?: Iterator<[IndexT, ValueT]> | Iterable<[IndexT, ValueT]>;\r\n\r\n    /**\r\n     * Array or iterable of column names that are in the dataframe.\r\n     * The order matters. This arrays specifies the ordering of columns which\r\n     * is important when rendering tables or writing out CSV data files.\r\n     * If this is omitted column names will automatically be determined\r\n     * from the fields of the first row/value in the dataframe.\r\n     */\r\n    columnNames?: Iterator<string> | Iterable<string>;\r\n\r\n    /***\r\n     * Set to true when the dataframe has been baked into memory\r\n     * and does not need to be lazily evaluated.\r\n     */\r\n    baked?: boolean;\r\n\r\n    /**\r\n     * Set to true to consider all rows/values in the dataframe when\r\n     * determining the column names. Otherwise only the first row is considered.\r\n     * You should use this if you have irregular fields in the objects that\r\n     * make up the rows/values of the dataframe.\r\n     */\r\n    considerAllRows?: boolean;\r\n\r\n    /**\r\n     * Explicitly specify data for named columns to put in the dataframe.\r\n     */\r\n    columns?: Iterator<IColumnConfig> | Iterable<IColumnConfig> | IColumnSpec;\r\n\r\n    /**\r\n     * Explicitly set this value if you want columnNames to be caseSensitive.\r\n     * Default behaviour is to treat column names as case insensitive\r\n     */\r\n    caseSensitive?: boolean;\r\n}\r\n\r\n/** \r\n * Represents a named column in a dataframe.\r\n */\r\nexport interface IColumn {\r\n    \r\n    /**\r\n     * The name of the column.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The data type of the column.\r\n     */\r\n    type: string;\r\n\r\n    /**\r\n     * The data series from the column.\r\n     */\r\n    series: ISeries<any, any>;\r\n}\r\n\r\n/** \r\n * An object whose fields specify data for named named columns or user-defined generator functions that generate the data for the columns.\r\n */\r\nexport interface IColumnGenSpec { //todo: this should allow iterable as well!\r\n    [index: string]: ISeries<any, any> | SeriesSelectorFn<any, any, any>,\r\n}\r\n\r\n/**\r\n * A string-to-string mapping that specifies how to rename columns.\r\n */\r\nexport interface IColumnRenameSpec {\r\n    [index: string]: string;\r\n}\r\n\r\n/**\r\n * Specifies columns to transform and the user-defined selector function that does the transformation.\r\n */\r\nexport interface IColumnTransformSpec {\r\n    [columnName: string]: SelectorWithIndexFn<any, any>;\r\n}\r\n\r\n/**\r\n * Specifies columns that should be aggregated and a user-defined aggregator function to do the aggregation.\r\n */\r\nexport interface IColumnAggregateSpec {\r\n    [index: string]: AggregateFn<any, any>;\r\n}\r\n\r\n/**\r\n * A selector function that can select a series from a dataframe.\r\n */\r\nexport type SeriesSelectorFn<IndexT, DataFrameValueT, SeriesValueT> = (dataFrame: IDataFrame<IndexT, DataFrameValueT>) => ISeries<IndexT, SeriesValueT>;\r\n\r\n/*\r\n * A function that generates a dataframe content object.\r\n * Used to make it easy to create lazy evaluated dataframes.\r\n */\r\nexport type DataFrameConfigFn<IndexT, ValueT> = () => IDataFrameConfig<IndexT, ValueT>;\r\n\r\n/**\r\n * Represents the frequency of a type in a series or dataframe.\r\n */\r\nexport interface ITypeFrequency {\r\n\r\n    /**\r\n     * Name of the column containing the value.\r\n     */\r\n    Column: string;\r\n\r\n    /**\r\n     * The name of the type.\r\n     */\r\n    Type: string; \r\n\r\n    /**\r\n     * The frequency of the type's appearance in the series or dataframe.\r\n     */\r\n    Frequency: number;\r\n}\r\n\r\n/**\r\n * Represents the frequency of a value in a series or dataframe.\r\n */\r\nexport interface IValueFrequency {\r\n\r\n    /**\r\n     * Name of the column containing the value.\r\n     */\r\n    Column: string;\r\n\r\n    /**\r\n     * The value.\r\n     */\r\n    Value: any; \r\n\r\n    /**\r\n     * The frequency of the value's appearance in the series or dataframe.\r\n     */\r\n    Frequency: number;\r\n}\r\n\r\n/**\r\n * Interface that represents a dataframe.\r\n * A dataframe contains an indexed sequence of data records.\r\n * Think of it as a spreadsheet or CSV file in memory.\r\n * \r\n * Each data record contains multiple named fields, the value of each field represents one row in a column of data.\r\n * Each column of data is a named {@link Series}.\r\n * You think of a dataframe a collection of named data series.\r\n * \r\n * @typeparam IndexT The type to use for the index.\r\n * @typeparam ValueT The type to use for each row/data record.\r\n */\r\nexport interface IDataFrame<IndexT = number, ValueT = any> extends Iterable<ValueT> {\r\n\r\n    /**\r\n     * Get an iterator to enumerate the rows of the dataframe.\r\n     * Enumerating the iterator forces lazy evaluation to complete.\r\n     * This function is automatically called by `for...of`.\r\n     * \r\n     * @return An iterator for the rows in the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * for (const row of df) {\r\n     *     // ... do something with the row ...\r\n     * }\r\n     * </pre>\r\n     */\r\n    [Symbol.iterator] (): Iterator<ValueT>;\r\n\r\n    /**\r\n     * Get the names of the columns in the dataframe.\r\n     * \r\n     * @return Returns an array of the column names in the dataframe.  \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * console.log(df.getColumnNames());\r\n     * </pre>\r\n     */\r\n    getColumnNames (): string[];\r\n\r\n    /** \r\n     * Retreive the collection of all columns in the dataframe.\r\n     * \r\n     * @return Returns a {@link Series} containing the names of the columns in the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * for (const column in df.getColumns()) {\r\n     *      console.log(\"Column name: \");\r\n     *      console.log(column.name);\r\n     * \r\n     *      console.log(\"Data:\");\r\n     *      console.log(column.series.toArray());\r\n     * }\r\n     * </pre>\r\n     */\r\n    getColumns (): ISeries<number, IColumn>;\r\n\r\n    /**\r\n     * Returns true if the dataframe is case sensitive or false if case insensitive.\r\n     * \r\n     * @return true if the dataframe is case sensitive, otherwise false.\r\n     */\r\n    isCaseSensitive (): boolean;\r\n\r\n    /**\r\n     * Cast the value of the dataframe to a new type.\r\n     * This operation has no effect but to retype the r9ws that the dataframe contains.\r\n     * \r\n     * @return The same dataframe, but with the type changed.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const castDf = df.cast<SomeOtherType>();\r\n     * </pre>\r\n     */\r\n    cast<NewValueT> (): IDataFrame<IndexT, NewValueT>;\r\n    \r\n    /**\r\n     * Get the index for the dataframe.\r\n     * \r\n     * @return The {@link Index} for the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const index = df.getIndex();\r\n     * </pre>\r\n     */\r\n    getIndex (): IIndex<IndexT>;\r\n\r\n    /**\r\n     * Set a named column as the {@link Index} of the dataframe.\r\n     *\r\n     * @param columnName Name of the column to use as the new {@link Index} of the returned dataframe.\r\n     *\r\n     * @return Returns a new dataframe with the values of the specified column as the new {@link Index}.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedDf = df.setIndex(\"SomeColumn\");\r\n     * </pre>\r\n     */\r\n    setIndex<NewIndexT = any> (columnName: string): IDataFrame<NewIndexT, ValueT>;\r\n    \r\n    /**\r\n     * Apply a new {@link Index} to the dataframe.\r\n     * \r\n     * @param newIndex The new array or iterable to be the new {@link Index} of the dataframe. Can also be a selector to choose the {@link Index} for each row in the dataframe.\r\n     * \r\n     * @return Returns a new dataframe with the specified {@link Index} attached.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedDf = df.withIndex([10, 20, 30]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedDf = df.withIndex(df.getSeries(\"SomeColumn\"));\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedDf = df.withIndex(row => row.SomeColumn);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedDf = df.withIndex(row => row.SomeColumn + 20);\r\n     * </pre>\r\n     */\r\n    withIndex<NewIndexT> (newIndex: Iterable<NewIndexT> | SelectorFn<ValueT, NewIndexT>): IDataFrame<NewIndexT, ValueT>;\r\n\r\n    /**\r\n     * Resets the {@link Index} of the dataframe back to the default zero-based sequential integer index.\r\n     * \r\n     * @return Returns a new dataframe with the {@link Index} reset to the default zero-based index. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithResetIndex = df.resetIndex();\r\n     * </pre>\r\n     */\r\n    resetIndex (): IDataFrame<number, ValueT>;\r\n    \r\n    /**\r\n     * Extract a {@link Series} from a named column in the dataframe.\r\n     *\r\n     * @param columnName Specifies the name of the column that contains the {@link Series} to retreive.\r\n     * \r\n     * @return Returns the {@link Series} extracted from the named column in the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = df.getSeries(\"SomeColumn\");\r\n     * </pre>\r\n     */\r\n    getSeries<SeriesValueT = any> (columnName: string): ISeries<IndexT, SeriesValueT>;\r\n\r\n    /**\r\n     * Determine if the dataframe contains a {@link Series} the specified named column.\r\n     *\r\n     * @param columnName Name of the column to check for.\r\n     * \r\n     * @return Returns true if the dataframe contains the requested {@link Series}, otherwise returns false.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * if (df.hasSeries(\"SomeColumn\")) {\r\n     *      // ... the dataframe contains a series with the specified column name ...\r\n     * }\r\n     * </pre>\r\n     */\r\n    hasSeries (columnName: string): boolean;\r\n\r\n    /**\r\n     * Verify the existence of a name column and extracts the {@link Series} for it.\r\n     * Throws an exception if the requested column doesn't exist.\r\n     *\r\n     * @param columnName Name of the column to extract.\r\n     * \r\n     * @return Returns the {@link Series} for the column if it exists, otherwise it throws an exception.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * try {\r\n     *      const series = df.expectSeries(\"SomeColumn\");\r\n     *      // ... do something with the series ...\r\n     * }\r\n     * catch (err) {\r\n     *      // ... the dataframe doesn't contain the column \"SomeColumn\" ...\r\n     * }\r\n     * </pre>\r\n     */\r\n    expectSeries<SeriesValueT> (columnName: string): ISeries<IndexT, SeriesValueT>;\r\n\r\n    /**\r\n     * Create a new dataframe with a replaced or additional column specified by the passed-in series.\r\n     *\r\n     * @param columnNameOrSpec The name of the column to add or replace or a {@link IColumnGenSpec} that defines the columns to add.\r\n     * @param series When columnNameOrSpec is a string that identifies the column to add, this specifies the {@link Series} to add to the dataframe or a function that produces a series (given a dataframe).\r\n     *\r\n     * @return Returns a new dataframe replacing or adding a particular named column.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.withSeries(\"ANewColumn\", new Series([1, 2, 3]));\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.withSeries(\"ANewColumn\", df => \r\n     *      df.getSeries(\"SourceData\").select(aTransformation)\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.withSeries({\r\n     *      ANewColumn: new Series([1, 2, 3]),\r\n     *      SomeOtherColumn: new Series([10, 20, 30])\r\n     * });\r\n     * <pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.withSeries({\r\n     *      ANewColumn: df => df.getSeries(\"SourceData\").select(aTransformation))\r\n     * });\r\n     * <pre>\r\n     */\r\n    withSeries<OutputValueT = any, SeriesValueT = any> (columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, OutputValueT>;\r\n\r\n    /**\r\n     * Merge one or more dataframes into this single dataframe.\r\n     * Rows are merged by indexed. \r\n     * Same named columns in subsequent dataframes override columns in earlier dataframes.\r\n     * \r\n     * @param otherDataFrames... One or more dataframes to merge into this dataframe.\r\n     * \r\n     * @returns The merged data frame.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const mergedDF = df1.merge(df2);\r\n     * </pre>\r\n     * \r\n     * <pre>\r\n     * \r\n     * const mergedDF = df1.merge(df2, df3, etc);\r\n     * </pre>\r\n     */\r\n    merge<MergedValueT = any>(...otherDataFrames: IDataFrame<IndexT, any>[]): IDataFrame<IndexT, MergedValueT>;\r\n    \r\n    /**\r\n     * Add a series to the dataframe, but only if it doesn't already exist.\r\n     * \r\n     * @param columnNameOrSpec The name of the series to add or a {@link IColumnGenSpec} that specifies the columns to add.\r\n     * @param series If columnNameOrSpec is a string that specifies the name of the series to add, this specifies the actual {@link Series} to add or a selector that generates the series given the dataframe.\r\n     * \r\n     * @return Returns a new dataframe with the specified series added, if the series didn't already exist. Otherwise if the requested series already exists the same dataframe is returned.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const updatedDf = df.ensureSeries(\"ANewColumn\", new Series([1, 2, 3]));\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const updatedDf = df.ensureSeries(\"ANewColumn\", df => \r\n     *      df.getSeries(\"AnExistingSeries\").select(aTransformation)\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.ensureSeries({\r\n     *      ANewColumn: new Series([1, 2, 3]),\r\n     *      SomeOtherColumn: new Series([10, 20, 30])\r\n     * });\r\n     * <pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.ensureSeries({\r\n     *      ANewColumn: df => df.getSeries(\"SourceData\").select(aTransformation))\r\n     * });\r\n     * <pre>\r\n     */\r\n    ensureSeries<SeriesValueT> (columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Create a new dataframe with just a subset of columns.\r\n     *\r\n     * @param columnNames Array of column names to include in the new dataframe.\r\n     * \r\n     * @return Returns a dataframe with a subset of columns from the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const subsetDf = df.subset([\"ColumnA\", \"ColumnB\"]);\r\n     * </pre>\r\n     */\r\n    subset<NewValueT = ValueT> (columnNames: string[]): IDataFrame<IndexT, NewValueT>;\r\n\r\n    /**\r\n     * Create a new dataframe with the requested column or columns dropped.\r\n     *\r\n     * @param columnOrColumns Specifies the column name (a string) or columns (array of strings) to drop.\r\n     * \r\n     * @return Returns a new dataframe with a particular named column or columns removed.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const modifiedDf = df.dropSeries(\"SomeColumn\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const modifiedDf = df.dropSeries([\"ColumnA\", \"ColumnB\"]);\r\n     * </pre>\r\n     */\r\n    dropSeries<NewValueT = ValueT> (columnOrColumns: string | string[]): IDataFrame<IndexT, NewValueT>;\r\n\r\n    /**\r\n     * Create a new dataframe with columns reordered.\r\n     * New column names create new columns (with undefined values), omitting existing column names causes those columns to be dropped.\r\n     * \r\n     * @param columnNames Specifies the new order for columns.\r\n     * \r\n     * @return Returns a new dataframe with columns reordered according to the order of the array of column names that is passed in.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const reorderedDf = df.reorderSeries([\"FirstColumn\", \"SecondColumn\", \"etc\"]);\r\n     * </pre>\r\n     */\r\n    reorderSeries<NewValueT = ValueT> (columnNames: string[]): IDataFrame<IndexT, NewValueT>;\r\n\r\n    /**\r\n     * Bring the column(s) with specified name(s) to the front of the column order, making it (or them) the first column(s) in the output dataframe.\r\n     *\r\n     * @param columnOrColumns Specifies the column or columns to bring to the front.\r\n     *\r\n     * @return Returns a new dataframe with 1 or more columns bought to the front of the column ordering.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const modifiedDf = df.bringToFront(\"NewFirstColumn\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const modifiedDf = df.bringToFront([\"NewFirstColumn\", \"NewSecondColumn\"]);\r\n     * </pre>\r\n     */\r\n    bringToFront (columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Bring the column(s) with specified name(s) to the back of the column order, making it (or them) the last column(s) in the output dataframe.\r\n     *\r\n     * @param columnOrColumns Specifies the column or columns to bring to the back.\r\n     *\r\n     * @return Returns a new dataframe with 1 or more columns bought to the back of the column ordering.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const modifiedDf = df.bringToBack(\"NewLastColumn\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const modifiedDf = df.bringToBack([\"NewSecondLastColumn, \"\"NewLastColumn\"]);\r\n     * </pre>\r\n     */\r\n    bringToBack (columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Create a new dataframe with 1 or more columns renamed.\r\n     *\r\n     * @param newColumnNames A column rename spec - a JavaScript hash that maps existing column names to new column names.\r\n     * \r\n     * @return Returns a new dataframe with specified columns renamed.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const renamedDf = df.renameSeries({ OldColumnName, NewColumnName });\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const renamedDf = df.renameSeries({ \r\n     *      Column1: ColumnA,\r\n     *      Column2: ColumnB\r\n     * });\r\n     * </pre>\r\n     */\r\n    renameSeries<NewValueT = ValueT> (newColumnNames: IColumnRenameSpec): IDataFrame<IndexT, NewValueT>;\r\n\r\n    /**\r\n    * Extract rows from the dataframe as an array.\r\n    * Each element of the array is one row of the dataframe represented as\r\n    * a JavaScript object with the fields as the dataframe's columns.\r\n    * This forces lazy evaluation to complete.\r\n    * \r\n    * @return Returns an array of the rows contained within the dataframe. \r\n    * \r\n    * @example\r\n    * <pre>\r\n    * const values = df.toArray();\r\n    * </pre>\r\n    */\r\n   toArray (): ValueT[];\r\n\r\n    /**\r\n     * Retreive the index, row pairs from the dataframe as an array.\r\n     * Each pair is [index, row].\r\n     * This forces lazy evaluation to complete.\r\n     * \r\n     * @return Returns an array of pairs that contains the dataframe's rows. Each pair is a two element array that contains an index and a row.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const pairs = df.toPairs();\r\n     * </pre>\r\n     */\r\n    toPairs (): ([IndexT, ValueT])[];\r\n\r\n    /**\r\n     * Convert the dataframe to a JavaScript object.\r\n     *\r\n     * @param keySelector User-defined selector function that selects keys for the resulting object.\r\n     * @param valueSelector User-defined selector function that selects values for the resulting object.\r\n     * \r\n     * @return Returns a JavaScript object generated from the dataframe by applying the key and value selector functions. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const someObject = df.toObject(\r\n     *      row => row.SomeColumn, // Specify the column to use for field names in the output object.\r\n     *      row => row.SomeOtherColumn // Specify the column to use as the value for each field.\r\n     * );\r\n     * </pre>\r\n     */\r\n    toObject<KeyT = any, FieldT = any, OutT = any> (keySelector: (value: ValueT) => KeyT, valueSelector: (value: ValueT) => FieldT): OutT;\r\n\r\n    /**\r\n     * Bake the data frame to an array of rows were each rows is an array of values in column order.\r\n     * \r\n     * @return Returns an array of rows. Each row is an array of values in column order.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const rows = df.toRows();\r\n     * </pre>\r\n     */\r\n    toRows (): any[][];\r\n \r\n    /**\r\n     * Transforms an input dataframe, generating a new dataframe.\r\n     * The transformer function is called for each element of the input and the collection of outputs creates the generated datafarme.\r\n     * \r\n     * `select` is an alias for {@link DataFrame.map}.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.map` but maps over a dataframe rather than an array.\r\n     *\r\n     * @param transformer A user-defined transformer function that transforms each element from the input to generate the output.\r\n     * \r\n     * @return Returns a new dataframe generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = {\r\n     *          // ... construct output from input ...\r\n     *      };\r\n     *\r\n     *      return output;\r\n     * }\r\n     *  \r\n     * const transformed = dataframe.select(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n    select<ToT> (transformer: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT>;\r\n\r\n    /**\r\n     * Transforms an input dataframe, generating a new dataframe.\r\n     * The transformer function is called for each element of the input and the collection of outputs creates the generated datafarme.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.map` but maps over a dataframe rather than an array.\r\n     *\r\n     * @param transformer A user-defined transformer function that transforms each element from the input to generate the output.\r\n     * \r\n     * @return Returns a new dataframe generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = {\r\n     *          // ... construct output from input ...\r\n     *      };\r\n     *\r\n     *      return output;\r\n     * }\r\n     *  \r\n     * const transformed = dataframe.map(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n    map<ToT> (transformer: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT>;\r\n\r\n    /**\r\n     * Transforms and flattens an input dataframe, generating a new dataframe.\r\n     * The transformer function is called for each value in the input dataframe and produces an array that is then flattened into the generated dataframe.\r\n     * \r\n     * `selectMany` is an alias for {@link DataFrame.flatMap}.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.flatMap` but maps over a dataframe rather than an array.\r\n     * \r\n     * @param transformer A user-defined function that transforms each value into an array that is then flattened into the generated dataframe.\r\n     * \r\n     * @return Returns a new dataframe generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = [];\r\n     *      while (someCondition) {\r\n     *          // ... generate zero or more outputs from a single input ...\r\n     *          output.push(... some generated value ...);\r\n     *      }\r\n     *      return output;\r\n     * }\r\n     * \r\n     * const transformed = dataframe.selectMany(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n    selectMany<ToT> (transformer: SelectorWithIndexFn<ValueT, Iterable<ToT>>): IDataFrame<IndexT, ToT>;\r\n\r\n    /**\r\n     * Transforms and flattens an input dataframe, generating a new dataframe.\r\n     * The transformer function is called for each value in the input dataframe and produces an array that is then flattened into the generated dataframe.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.flatMap` but maps over a dataframe rather than an array.\r\n     * \r\n     * @param transformer A user-defined function that transforms each value into an array that is then flattened into the generated dataframe.\r\n     * \r\n     * @return Returns a new dataframe generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = [];\r\n     *      while (someCondition) {\r\n     *          // ... generate zero or more outputs from a single input ...\r\n     *          output.push(... some generated value ...);\r\n     *      }\r\n     *      return output;\r\n     * }\r\n     * \r\n     * const transformed = dataframe.flatMap(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n    flatMap<ToT> (transformer: SelectorWithIndexFn<ValueT, Iterable<ToT>>): IDataFrame<IndexT, ToT>;\r\n\r\n    /**\r\n     * Transform one or more columns. \r\n     * \r\n     * This is equivalent to extracting a {@link Series} with {@link getSeries}, then transforming it with {@link Series.select},\r\n     * and finally plugging it back in as the same column using {@link withSeries}.\r\n     *\r\n     * @param columnSelectors Object with field names for each column to be transformed. Each field specifies a selector function that transforms that column.\r\n     * \r\n     * @return Returns a new dataframe with 1 or more columns transformed.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.transformSeries({ \r\n     *      AColumnToTransform: columnValue => transformRow(columnValue) \r\n     * });\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.transformSeries({ \r\n     *      ColumnA: columnValue => transformColumnA(columnValue),\r\n     *      ColumnB: columnValue => transformColumnB(columnValue)\r\n     * });\r\n     * </pre>\r\n     */\r\n    transformSeries<NewValueT = ValueT> (columnSelectors: IColumnTransformSpec): IDataFrame<IndexT, NewValueT>;\r\n\r\n    /** \r\n     * Generate new columns based on existing rows.\r\n     * \r\n     * This is equivalent to calling {@link select} to transform the original dataframe to a new dataframe with different column,\r\n     * then using {@link withSeries} to merge each the of both the new and original dataframes.\r\n     *\r\n     * @param generator Generator function that transforms each row to produce 1 or more new columns.\r\n     * Or use a column spec that has fields for each column, the fields specify a generate function that produces the value for each new column.\r\n     * \r\n     * @return Returns a new dataframe with 1 or more new columns.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function produceNewColumns (inputRow) {\r\n     *      const newColumns = {\r\n     *          // ... specify new columns and their values based on the input row ...\r\n     *      };\r\n     * \r\n     *      return newColumns;\r\n     * };\r\n     * \r\n     * const dfWithNewSeries = df.generateSeries(row => produceNewColumns(row));\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithNewSeries = df.generateSeries({ \r\n     *      NewColumnA: row => produceNewColumnA(row),\r\n     *      NewColumnB: row => produceNewColumnB(row),\r\n     * })\r\n     * </pre>\r\n     */\r\n    generateSeries<NewValueT = ValueT> (generator: SelectorWithIndexFn<any, any> | IColumnTransformSpec): IDataFrame<IndexT, NewValueT>;\r\n\r\n    /** \r\n     * Converts (deflates) a dataframe to a {@link Series}.\r\n     *\r\n     * @param selector Optional user-defined selector function that transforms each row to produce the series.\r\n     *\r\n     * @return Returns a series that was created from the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = df.deflate(); // Deflate to a series of object.\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = df.deflate(row => row.SomeColumn); // Extract a particular column.\r\n     * </pre>\r\n     */\r\n    deflate<ToT = ValueT> (selector?: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT>;\r\n\r\n    /** \r\n     * Inflate a named {@link Series} in the dataframe to 1 or more new series in the new dataframe.\r\n     * \r\n     * This is the equivalent of extracting the series using {@link getSeries}, transforming them with {@link Series.select}\r\n     * and then running {@link Series.inflate} to create a new dataframe, then merging each column of the new dataframe\r\n     *  into the original dataframe using {@link withSeries}.\r\n     *\r\n     * @param columnName Name of the series to inflate.\r\n     * @param selector Optional selector function that transforms each value in the column to new columns. If not specified it is expected that each value in the column is an object whose fields define the new column names.\r\n     * \r\n     * @return Returns a new dataframe with a column inflated to 1 or more new columns.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function newColumnGenerator (row) {\r\n     *      const newColumns = {\r\n     *          // ... create 1 field per new column ...\r\n     *      };\r\n     * \r\n     *      return row;\r\n     * }\r\n     * \r\n     * const dfWithNewSeries = df.inflateSeries(\"SomeColumn\", newColumnGenerator);\r\n     * </pre>\r\n     */\r\n    inflateSeries<NewValueT = ValueT> (columnName: string, selector?: SelectorWithIndexFn<IndexT, any>): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Partition a dataframe into a {@link Series} of *data windows*. \r\n     * Each value in the new series is a chunk of data from the original dataframe.\r\n     *\r\n     * @param period The number of rows to include in each data window.\r\n     * \r\n     * @return Returns a new series, each value of which is a chunk (data window) of the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const windows = df.window(2); // Get rows in pairs.\r\n     * const pctIncrease = windows.select(pair => (pair.last().SalesAmount - pair.first().SalesAmount) / pair.first().SalesAmount);\r\n     * console.log(pctIncrease.toString());\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesDf = ... // Daily sales data.\r\n     * const weeklySales = salesDf.window(7); // Partition up into weekly data sets.\r\n     * console.log(weeklySales.toString());\r\n     * </pre>\r\n     */\r\n    window (period: number): ISeries<number, IDataFrame<IndexT, ValueT>>;\r\n\r\n    /** \r\n     * Partition a dataframe into a {@link Series} of *rolling data windows*. \r\n     * Each value in the new series is a rolling chunk of data from the original dataframe.\r\n     *\r\n     * @param period The number of data rows to include in each data window.\r\n     * \r\n     * @return Returns a new series, each value of which is a rolling chunk of the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesDf = ... // Daily sales data.\r\n     * const rollingWeeklySales = salesDf.rollingWindow(7); // Get rolling window over weekly sales data.\r\n     * console.log(rollingWeeklySales.toString());\r\n     * </pre>\r\n     */\r\n    rollingWindow (period: number): ISeries<number, IDataFrame<IndexT, ValueT>>;\r\n\r\n    /**\r\n     * Partition a dataframe into a {@link Series} of variable-length *data windows* \r\n     * where the divisions between the data chunks are\r\n     * defined by a user-provided *comparer* function.\r\n     * \r\n     * @param comparer Function that compares two adjacent data rows and returns true if they should be in the same window.\r\n     * \r\n     * @return Returns a new series, each value of which is a chunk of data from the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function rowComparer (rowA, rowB) {\r\n     *      if (... rowA should be in the same data window as rowB ...) {\r\n     *          return true;\r\n     *      }\r\n     *      else {\r\n     *          return false;\r\n     *      }\r\n     * };\r\n     * \r\n     * const variableWindows = df.variableWindow(rowComparer);\r\n     */\r\n    variableWindow (comparer: ComparerFn<ValueT, ValueT>): ISeries<number, IDataFrame<IndexT, ValueT>>;\r\n\r\n    /**\r\n     * Eliminates adjacent duplicate rows.\r\n     * \r\n     * For each group of adjacent values that are equivalent only returns the last index/row for the group, \r\n     * thus adjacent equivalent rows are collapsed down to the last row.\r\n     *\r\n     * @param selector Optional selector function to determine the value used to compare for equivalence.\r\n     * \r\n     * @return Returns a new dataframe with groups of adjacent duplicate rows collapsed to a single row per group.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithDuplicateRowsRemoved = df.sequentialDistinct(row => row.ColumnA);\r\n     * </pre>\r\n     */\r\n    sequentialDistinct<ToT = ValueT> (selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Aggregate the rows in the dataframe to a single result.\r\n     * \r\n     * `aggregate` is similar to {@link DataFrame.reduce}  but the parameters are reversed. \r\n     * Please use {@link DataFrame.reduce} in preference to `aggregate`.\r\n     *\r\n     * @param seed Optional seed value for producing the aggregation.\r\n     * @param selector Function that takes the seed and then each row in the dataframe and produces the aggregate value.\r\n     * \r\n     * @return Returns a new value that has been aggregated from the dataframe using the 'selector' function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dailySalesDf = ... daily sales figures for the past month ...\r\n     * const totalSalesForthisMonth = dailySalesDf.aggregate(\r\n     *      0, // Seed - the starting value.\r\n     *      (accumulator, row) => accumulator + row.SalesAmount // Aggregation function.\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const totalSalesAllTime = 500; // We'll seed the aggregation with this value.\r\n     * const dailySalesDf = ... daily sales figures for the past month ...\r\n     * const updatedTotalSalesAllTime = dailySalesDf.aggregate(\r\n     *      totalSalesAllTime, \r\n     *      (accumulator, row) => accumulator + row.SalesAmount\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * var salesDataSummary = salesDataDf.aggregate({\r\n     *      TotalSales: df => df.count(),\r\n     *      AveragePrice: df => df.deflate(row => row.Price).average(),\r\n     *      TotalRevenue: df => df.deflate(row => row.Revenue).sum(), \r\n     * });\r\n     * </pre>\r\n    */\r\n    aggregate<ToT = ValueT> (seedOrSelector: AggregateFn<ValueT, ToT> | ToT | IColumnAggregateSpec, selector?: AggregateFn<ValueT, ToT>): ToT;\r\n\r\n    /**\r\n     * Reduces the values in the dataframe to a single result.\r\n     *\r\n     * This is the same concept as the JavaScript function `Array.reduce` but reduces a dataframe rather than an array.\r\n\r\n     * @param reducer Function that takes the seed and then each value in the dataframe and produces the reduced value.\r\n     * @param seed Optional initial value, if not specifed the first value in the dataframe is used as the initial value.\r\n     * \r\n     * @return Returns a value that has been reduced from the input dataframe by passing each element through the reducer function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dailyRecords = ... daily records for the past month ...\r\n     * const totalSales = dailyRecords.reduce(\r\n     *      (accumulator, row) => accumulator + row.salesAmount, // Reducer function.\r\n     *      0  // Seed value, the starting value.\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const previousSales = 500; // We'll seed the reduction with this value.\r\n     * const dailyRecords = ... daily records for the past month ...\r\n     * const updatedSales = dailyRecords.reduce(\r\n     *      (accumulator, row) => accumulator + row.salesAmount,\r\n     *      previousSales\r\n     * );\r\n     * </pre>\r\n     */\r\n    reduce<ToT = ValueT> (reducer: AggregateFn<ValueT, ToT>, seed?: ToT): ToT;\r\n   \r\n    /**\r\n     * Skip a number of rows in the dataframe.\r\n     *\r\n     * @param numValues Number of rows to skip.\r\n     * \r\n     * @return Returns a new dataframe with the specified number of rows skipped. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithRowsSkipped = df.skip(10); // Skip 10 rows in the original dataframe.\r\n     * </pre>\r\n     */\r\n    skip (numValues: number): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Skips values in the dataframe while a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Returns true/truthy to continue to skip rows in the original dataframe.\r\n     * \r\n     * @return Returns a new dataframe with all initial sequential rows removed while the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithRowsSkipped = df.skipWhile(row => row.CustomerName === \"Fred\"); // Skip initial customers named Fred.\r\n     * </pre>\r\n     */\r\n    skipWhile (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Skips values in the dataframe untils a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Return true/truthy to stop skipping rows in the original dataframe.\r\n     * \r\n     * @return Returns a new dataframe with all initial sequential rows removed until the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithRowsSkipped = df.skipUntil(row => row.CustomerName === \"Fred\"); // Skip initial customers until we find Fred.\r\n     * </pre>\r\n     */\r\n    skipUntil (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Take a number of rows in the dataframe.\r\n     *\r\n     * @param numValues Number of rows to take.\r\n     * \r\n     * @return Returns a new dataframe with only the specified number of rows taken from the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithRowsTaken = df.take(15); // Take only the first 15 rows from the original dataframe.\r\n     * </pre>\r\n     */\r\n    take (numRows: number): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Takes values from the dataframe while a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Returns true/truthy to continue to take rows from the original dataframe.\r\n     * \r\n     * @return Returns a new dataframe with only the initial sequential rows that were taken while the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithRowsTaken = df.takeWhile(row => row.CustomerName === \"Fred\"); // Take only initial customers named Fred.\r\n     * </pre>\r\n     */\r\n    takeWhile (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Takes values from the dataframe untils a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Return true/truthy to stop taking rows in the original dataframe.\r\n     * \r\n     * @return Returns a new dataframe with only the initial sequential rows taken until the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithRowsTaken = df.takeUntil(row => row.CustomerName === \"Fred\"); // Take all initial customers until we find Fred.\r\n     * </pre>\r\n     */\r\n    takeUntil (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Count the number of rows in the dataframe\r\n     *\r\n     * @return Returns the count of all rows.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const numRows = df.count();\r\n     * </pre>\r\n     */\r\n    count (): number;\r\n\r\n    /**\r\n     * Get the first row of the dataframe.\r\n     *\r\n     * @return Returns the first row of the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const firstRow = df.first();\r\n     * </pre>\r\n     */\r\n    first (): ValueT;\r\n\r\n    /**\r\n     * Get the last row of the dataframe.\r\n     *\r\n     * @return Returns the last row of the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const lastRow = df.last();\r\n     * </pre>\r\n     */\r\n    last (): ValueT;\r\n    \r\n    /**\r\n     * Get the row, if there is one, with the specified index.\r\n     *\r\n     * @param index Index to for which to retreive the row.\r\n     *\r\n     * @return Returns the row from the specified index in the dataframe or undefined if there is no such index in the present in the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const row = df.at(5); // Get the row at index 5 (with a default 0-based index).\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const date = ... some date ...\r\n     * // Retreive the row with specified date from a time-series dataframe (assuming date indexed has been applied).\r\n     * const row = df.at(date); \r\n     * </pre>\r\n     */\r\n    at (index: IndexT): ValueT | undefined;\r\n    \r\n    /** \r\n     * Get X rows from the start of the dataframe.\r\n     * Pass in a negative value to get all rows at the head except for X rows at the tail.\r\n     *\r\n     * @param numValues Number of rows to take.\r\n     * \r\n     * @return Returns a new dataframe that has only the specified number of rows taken from the start of the original dataframe.  \r\n     * \r\n     * @examples\r\n     * <pre>\r\n     * \r\n     * const sample = df.head(10); // Take a sample of 10 rows from the start of the dataframe.\r\n     * </pre>\r\n     */\r\n    head (numValues: number): IDataFrame<IndexT, ValueT>;\r\n\r\n    /** \r\n     * Get X rows from the end of the dataframe.\r\n     * Pass in a negative value to get all rows at the tail except X rows at the head.\r\n     *\r\n     * @param numValues Number of rows to take.\r\n     * \r\n     * @return Returns a new dataframe that has only the specified number of rows taken from the end of the original dataframe.  \r\n     * \r\n     * @examples\r\n     * <pre>\r\n     * \r\n     * const sample = df.tail(12); // Take a sample of 12 rows from the end of the dataframe.\r\n     * </pre>\r\n     */\r\n    tail (numValues: number): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Filter the dataframe through a user-defined predicate function.\r\n     * \r\n     * `where` is an alias for {@link DataFrame.filter}.\r\n     *\r\n     * This is the same concept as the JavaScript function `Array.filter` but filters a dataframe rather than an array.\r\n     * \r\n     * @param predicate Predicate function to filter values from the dataframe. Returns true/truthy to keep elements, or false/falsy to omit elements.\r\n     * \r\n     * @return Returns a new dataframe containing only the values from the original dataframe that matched the predicate. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Filter so we only have sales figures greater than 100.\r\n     * const filtered = dataframe.where(row => row.salesFigure > 100); \r\n     * console.log(filtered.toArray());\r\n     * </pre>\r\n     */\r\n    where (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Filter the dataframe through a user-defined predicate function.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.filter` but filters a dataframe rather than an array.\r\n     *\r\n     * @param predicate Predicate function to filter values from the dataframe. Returns true/truthy to keep elements, or false/falsy to omit elements.\r\n     * \r\n     * @return Returns a new dataframe containing only the values from the original dataframe that matched the predicate. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Filter so we only have sales figures greater than 100.\r\n     * const filtered = dataframe.filter(row => row.salesFigure > 100); \r\n     * console.log(filtered.toArray());\r\n     * </pre>\r\n     */\r\n    filter (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Invoke a callback function for each row in the dataframe.\r\n     *\r\n     * @param callback The calback function to invoke for each row.\r\n     * \r\n     * @return Returns the original dataframe with no modifications.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * df.forEach(row => {\r\n     *      // ... do something with the row ...\r\n     * });\r\n     * </pre>\r\n     */\r\n    forEach (callback: CallbackFn<ValueT>): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Evaluates a predicate function for every row in the dataframe to determine \r\n     * if some condition is true/truthy for **all** rows in the dataframe.\r\n     * \r\n     * @param predicate Predicate function that receives each row. It should returns true/truthy for a match, otherwise false/falsy.\r\n     *\r\n     * @return Returns true if the predicate has returned true or truthy for every row in the dataframe, otherwise returns false. Returns false for an empty dataframe. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const everyoneIsNamedFred = df.all(row => row.CustomerName === \"Fred\"); // Check if all customers are named Fred.\r\n     * </pre>\r\n     */\r\n    all (predicate: PredicateFn<ValueT>): boolean;\r\n\r\n    /**\r\n     * Evaluates a predicate function for every row in the dataframe to determine \r\n     * if some condition is true/truthy for **any** of rows in the dataframe.\r\n     * \r\n     * If no predicate is specified then it simply checks if the dataframe contains more than zero rows.\r\n     *\r\n     * @param predicate Optional predicate function that receives each row. It should return true/truthy for a match, otherwise false/falsy.\r\n     *\r\n     * @return Returns true if the predicate has returned truthy for any row in the sequence, otherwise returns false. \r\n     * If no predicate is passed it returns true if the dataframe contains any rows at all. \r\n     * Returns false for an empty dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const anyFreds = df.any(row => row.CustomerName === \"Fred\"); // Do we have any customers named Fred?\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const anyCustomers = df.any(); // Do we have any customers at all?\r\n     * </pre>\r\n     */\r\n    any (predicate?: PredicateFn<ValueT>): boolean;\r\n\r\n    /**\r\n     * Evaluates a predicate function for every row in the dataframe to determine \r\n     * if some condition is true/truthy for **none** of rows in the dataframe.\r\n     * \r\n     * If no predicate is specified then it simply checks if the dataframe contains zero rows.\r\n     *\r\n     * @param predicate Optional predicate function that receives each row. It should return true/truthy for a match, otherwise false/falsy.\r\n     *\r\n     * @return Returns true if the predicate has returned truthy for zero rows in the dataframe, otherwise returns false. Returns false for an empty dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const noFreds = df.none(row => row.CustomerName === \"Fred\"); // Do we have zero customers named Fred?\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const noCustomers = df.none(); // Do we have zero customers?\r\n     * </pre>\r\n     */\r\n    none (predicate?: PredicateFn<ValueT>): boolean;\r\n\r\n        /**\r\n     * Gets a new dataframe containing all rows starting at and after the specified index value.\r\n     * \r\n     * @param indexValue The index value at which to start the new dataframe.\r\n     * \r\n     * @return Returns a new dataframe containing all rows starting at and after the specified index value. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = new DataFrame({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const lastHalf = df.startAt(2);\r\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n     * \r\n     * // Get all rows starting at (or after) a particular date.\r\n     * const allRowsFromStartDate = df.startAt(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    startAt (indexValue: IndexT): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Gets a new dataframe containing all rows up until and including the specified index value (inclusive).\r\n     * \r\n     * @param indexValue The index value at which to end the new dataframe.\r\n     * \r\n     * @return Returns a new dataframe containing all rows up until and including the specified index value.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = new DataFrame({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const firstHalf = df.endAt(1);\r\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n     * \r\n     * // Get all rows ending at a particular date.\r\n     * const allRowsUpToAndIncludingTheExactEndDate = df.endAt(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    endAt (indexValue: IndexT): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Gets a new dataframe containing all rows up to the specified index value (exclusive).\r\n     * \r\n     * @param indexValue The index value at which to end the new dataframe.\r\n     * \r\n     * @return Returns a new dataframe containing all rows up to (but not including) the specified index value. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = new DataFrame({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const firstHalf = df.before(2);\r\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n     * \r\n     * // Get all rows before the specified date.\r\n     * const allRowsBeforeEndDate = df.before(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    before (indexValue: IndexT): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Gets a new dataframe containing all rows after the specified index value (exclusive).\r\n     * \r\n     * @param indexValue The index value after which to start the new dataframe.\r\n     * \r\n     * @return Returns a new dataframe containing all rows after the specified index value.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = new DataFrame({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const lastHalf = df.before(1);\r\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n     * \r\n     * // Get all rows after the specified date.\r\n     * const allRowsAfterStartDate = df.after(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    after (indexValue: IndexT): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Gets a new dataframe containing all rows between the specified index values (inclusive).\r\n     * \r\n     * @param startIndexValue The index at which to start the new dataframe.\r\n     * @param endIndexValue The index at which to end the new dataframe.\r\n     * \r\n     * @return Returns a new dataframe containing all values between the specified index values (inclusive).\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = new DataFrame({ \r\n     *      index: [0, 1, 2, 3, 4, 6], // This is the default index.\r\n     *      values: [10, 20, 30, 40, 50, 60],\r\n     * });\r\n     * \r\n     * const middleSection = df.between(1, 4);\r\n     * expect(middleSection.toArray()).to.eql([20, 30, 40, 50]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n     * \r\n     * // Get all rows between the start and end dates (inclusive).\r\n     * const allRowsBetweenDates = df.after(new Date(2016, 5, 4), new Date(2016, 5, 22)); \r\n     * </pre>\r\n     */\r\n    between (startIndexValue: IndexT, endIndexValue: IndexT): IDataFrame<IndexT, ValueT>;\r\n\r\n    /** \r\n     * Format the dataframe for display as a string.\r\n     * This forces lazy evaluation to complete.\r\n     * \r\n     * @return Generates and returns a string representation of the dataframe or dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * console.log(df.toString());\r\n     * </pre>\r\n     */\r\n    toString (): string;\r\n\r\n    /**\r\n     * Parse a column with string values and convert it to a column with int values.\r\n     *\r\n     * @param columnNameOrNames Specifies the column name or array of column names to parse.\r\n     * \r\n     * @return Returns a new dataframe with a particular named column parsed as ints.  \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const withParsedColumn = df.parseInts(\"MyIntColumn\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const withParsedColumns = df.parseInts([\"MyIntColumnA\", \"MyIntColumnA\"]);\r\n     * </pre>\r\n     */\r\n    parseInts (columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Parse a column with string values and convert it to a column with float values.\r\n     *\r\n     * @param columnNameOrNames Specifies the column name or array of column names to parse.\r\n     * \r\n     * @return  Returns a new dataframe with a particular named column parsed as floats.  \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const withParsedColumn = df.parseFloats(\"MyFloatColumn\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const withParsedColumns = df.parseFloats([\"MyFloatColumnA\", \"MyFloatColumnA\"]);\r\n     * </pre>\r\n     */\r\n    parseFloats (columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Parse a column with string values and convert it to a column with date values.\r\n     *\r\n     * @param columnNameOrNames -Specifies the column name or array of column names to parse.\r\n     * @param formatString Optional formatting string for dates.\r\n     * \r\n     * @return Returns a new dataframe with a particular named column parsed as dates.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const withParsedColumn = df.parseDates(\"MyDateColumn\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const withParsedColumns = df.parseDates([\"MyDateColumnA\", \"MyDateColumnA\"]);\r\n     * </pre>\r\n     */\r\n    parseDates (columnNameOrNames: string | string[], formatString?: string): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Convert a column of values of different types to a column of string values.\r\n     *\r\n     * @param columnNames Specifies the column name or array of column names to convert to strings. Can also be a format spec that specifies which columns to convert and what their format should be. \r\n     * @param formatString Optional formatting string for dates.\r\n     * \r\n     * Numeral.js is used for number formatting.\r\n     * http://numeraljs.com/\r\n     * \r\n     * Moment is used for date formatting.\r\n     * https://momentjs.com/docs/#/parsing/string-format/\r\n     * \r\n     * @return Returns a new dataframe with a particular named column convert to strings.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const withStringColumn = df.toStrings(\"MyDateColumn\", \"YYYY-MM-DD\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const withStringColumn = df.toStrings(\"MyFloatColumn\", \"0.00\");\r\n     * </pre>\r\n     */\r\n    toStrings (columnNames: string | string[] | IFormatSpec, formatString?: string): IDataFrame<IndexT, ValueT>;    \r\n\r\n    /**\r\n     * Produces a new dataframe with all string values truncated to the requested maximum length.\r\n     *\r\n     * @param maxLength The maximum length of the string values after truncation.\r\n     * \r\n     * @return Returns a new dataframe with all strings truncated to the specified maximum length.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Truncate all string columns to 100 characters maximum.\r\n     * const truncatedDf = df.truncateString(100);\r\n     * </pre>\r\n     */\r\n    truncateStrings (maxLength: number): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Produces a new dataframe with all number values rounded to the specified number of places.\r\n     *\r\n     * @param numDecimalPlaces The number of decimal places, defaults to 2.\r\n     * \r\n     * @returns Returns a new dataframe with all number values rounded to the specified number of places.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = ... your data frame ...\r\n     * const rounded = df.round(); // Round numbers to two decimal places.\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = ... your data frame ...\r\n     * const rounded = df.round(3); // Round numbers to three decimal places.\r\n     * </pre>\r\n     */\r\n    round (numDecimalPlaces?: number): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Forces lazy evaluation to complete and 'bakes' the dataframe into memory.\r\n     * \r\n     * @return Returns a dataframe that has been 'baked', all lazy evaluation has completed.  \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const bakedDf = df.bake();\r\n     * </pre>\r\n     */\r\n    bake (): IDataFrame<IndexT, ValueT>;\r\n\r\n    /** \r\n     * Gets a new dataframe in reverse order.\r\n     * \r\n     * @return Returns a new dataframe that is the reverse of the original.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const reversed = df.reverse();\r\n     * </pre>\r\n     */\r\n    reverse (): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Returns only the set of rows in the dataframe that are distinct according to some criteria.\r\n     * This can be used to remove duplicate rows from the dataframe.\r\n     *\r\n     * @param selector User-defined selector function that specifies the criteria used to make comparisons for duplicate rows.\r\n     * Note that the selector determines the object used for the comparison.  If the selector returns a new instance of an array or a\r\n     * javascript object, distinct will always include all rows since the object instances are different even if the members are the same.  \r\n     * \r\n     * @return Returns a dataframe containing only unique values as determined by the 'selector' function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Remove duplicate rows by customer id. Will return only a single row per customer.\r\n     * const distinctCustomers = salesDf.distinct(sale => sale.CustomerId);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * \r\n     * <pre>\r\n     * // Remove duplicate rows across mutliple columns\r\n     * const safeJoinChar = '$';\r\n     * const distinctCustomers = salesDf.distinct(sale => [sale.CustomerId, sale.MonthOfYear].join(safeJoinChar));\r\n     * </pre>\r\n     */\r\n    distinct<ToT> (selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Collects rows in the dataframe into a {@link Series} of groups according to a user-defined selector function.\r\n     *\r\n     * @param selector User-defined selector function that specifies the criteria to group by.\r\n     *\r\n     * @return Returns a {@link Series} of groups. Each group is a dataframe with rows that have been grouped by the 'selector' function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesDf = ... product sales ...\r\n     * const salesByProduct = salesDf.groupBy(sale => sale.ProductId);\r\n     * for (const productSalesGroup of salesByProduct) {\r\n     *      // ... do something with each product group ...\r\n     *      const productId = productSalesGroup.first().ProductId;\r\n     *      const totalSalesForProduct = productSalesGroup.deflate(sale => sale.Amount).sum();\r\n     *      console.log(totalSalesForProduct);\r\n     * }\r\n     * </pre>\r\n     */\r\n    groupBy<GroupT> (selector: SelectorWithIndexFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>>;\r\n    \r\n    /**\r\n     * Collects values in the series into a new series of groups based on if the values are the same or according to a user-defined selector function.\r\n     *\r\n     * @param selector Optional selector that specifies the criteria for grouping.\r\n     *\r\n     * @return Returns a {@link Series} of groups. Each group is a dataframe with rows that are the same or have been grouped by the 'selector' function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Some ultra simple stock trading strategy backtesting...\r\n     * const dailyStockPriceDf = ... daily stock price for a company ...\r\n     * const priceGroups  = dailyStockPriceDf.groupBy(day => day.close > day.movingAverage);\r\n     * for (const priceGroup of priceGroups) {\r\n     *      // ... do something with each stock price group ...\r\n     * \r\n     *      const firstDay = priceGroup.first();\r\n     *      if (firstDay.close > movingAverage) {\r\n     *          // This group of days has the stock price above its moving average.\r\n     *          // ... maybe enter a long trade here ...\r\n     *      }\r\n     *      else {\r\n     *          // This group of days has the stock price below its moving average.\r\n     *          // ... maybe enter a short trade here ...\r\n     *      }\r\n     * }\r\n     * </pre>\r\n     */\r\n    groupSequentialBy<GroupT> (selector?: SelectorFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>>;\r\n    \r\n    /**\r\n     * Concatenate multiple other dataframes onto this dataframe.\r\n     * \r\n     * @param dataframes Multiple arguments. Each can be either a dataframe or an array of dataframes.\r\n     * \r\n     * @return Returns a single dataframe concatenated from multiple input dataframes. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenated = a.concat(b);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenated = a.concat(b, c);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenated = a.concat([b, c]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenated = a.concat(b, [c, d]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const otherDfs = [... array of dataframes...];\r\n     * const concatenated = a.concat(otherDfs);\r\n     * </pre>\r\n     */    \r\n    concat (...dataframes: (IDataFrame<IndexT, ValueT>[] | IDataFrame<IndexT, ValueT>)[]): IDataFrame<IndexT, ValueT>;\r\n    \r\n    /**\r\n    * Merge together multiple dataframes to create a new dataframe.\r\n    * Preserves the index of the first dataframe.\r\n    * \r\n    * @param s2, s3, s4, s4 Multiple dataframes to zip.\r\n    * @param zipper User-defined zipper function that merges rows. It produces rows for the new dataframe based-on rows from the input dataframes.\r\n    * \r\n    * @return Returns a single dataframe merged from multiple input dataframes. \r\n    * \r\n    * @example\r\n    * <pre>\r\n    * \r\n    * function produceNewRow (rowA, rowB) {\r\n    *       const outputRow = {\r\n    *           ValueA: rowA.Value,\r\n    *           ValueB: rowB.Value,\r\n    *       };\r\n    *       return outputRow;\r\n    * }\r\n    * \r\n    * const dfA = new DataFrame([ { Value: 10 }, { Value: 20 }, { Value: 30 }]);\r\n    * const dfB = new DataFrame([ { Value: 100 }, { Value: 200 }, { Value: 300 }]);\r\n    * const zippedDf = dfA.zip(dfB, produceNewRow);\r\n    * </pre>\r\n    */    \r\n    zip<Index2T, Value2T, ResultT>  (s2: IDataFrame<Index2T, Value2T>, zipper: Zip2Fn<ValueT, Value2T, ResultT> ): IDataFrame<IndexT, ResultT>;\r\n    zip<Index2T, Value2T, Index3T, Value3T, ResultT>  (s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): IDataFrame<IndexT, ResultT>;\r\n    zip<Index2T, Value2T, Index3T, Value3T, Index4T, Value4T, ResultT>  (s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, s4: IDataFrame<Index4T, Value4T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): IDataFrame<IndexT, ResultT>;\r\n    zip<ResultT>  (...args: any[]): IDataFrame<IndexT, ResultT>;\r\n\r\n    /**\r\n     * Sorts the dataframe in ascending order by a value defined by the user-defined selector function. \r\n     * \r\n     * @param selector User-defined selector function that selects the value to sort by.\r\n     * \r\n     * @return Returns a new dataframe that has been ordered accorrding to the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Order sales by amount from least to most.\r\n     * const orderedDf = salesDf.orderBy(sale => sale.Amount); \r\n     * </pre>\r\n     */\r\n    orderBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;\r\n\r\n    /**\r\n     * Sorts the dataframe in descending order by a value defined by the user-defined selector function. \r\n     * \r\n     * @param selector User-defined selector function that selects the value to sort by.\r\n     * \r\n     * @return Returns a new dataframe that has been ordered accorrding to the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Order sales by amount from most to least\r\n     * const orderedDf = salesDf.orderByDescending(sale => sale.Amount); \r\n     * </pre>\r\n     */\r\n    orderByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;\r\n        \r\n    /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains the union of rows from the two input dataframes.\r\n     * These are the unique combination of rows in both dataframe.\r\n     * This is basically a concatenation and then elimination of duplicates.\r\n     *\r\n     * @param other The other dataframes to merge.\r\n     * @param selector Optional user-defined selector function that selects the value to compare to determine distinctness.\r\n     * \r\n     * @return Returns the union of the two dataframes.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * const dfA = ...\r\n     * const dfB = ...\r\n     * const merged = dfA.union(dfB);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Merge two sets of customer records that may contain the same\r\n     * // customer record in each set. This is basically a concatenation\r\n     * // of the dataframes and then an elimination of any duplicate records\r\n     * // that result.\r\n     * const customerRecordsA = ...\r\n     * const customerRecordsB = ...\r\n     * const mergedCustomerRecords = customerRecordsA.union(\r\n     *      customerRecordsB, \r\n     *      customerRecord => customerRecord.CustomerId\r\n     * );\r\n     * </pre>\r\n     * \r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Note that you can achieve the exact same result as the previous\r\n     * // example by doing a {@link DataFrame.concat) and {@link DataFrame.distinct}\r\n     * // of the dataframes and then an elimination of any duplicate records\r\n     * // that result.\r\n     * const customerRecordsA = ...\r\n     * const customerRecordsB = ...\r\n     * const mergedCustomerRecords = customerRecordsA\r\n     *      .concat(customerRecordsB)\r\n     *      .distinct(customerRecord => customerRecord.CustomerId);\r\n     * </pre>\r\n     * \r\n     */\r\n    union<KeyT = ValueT> (\r\n        other: IDataFrame<IndexT, ValueT>, \r\n        selector?: SelectorFn<ValueT, KeyT>): \r\n            IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains the intersection of rows from the two input dataframes.\r\n     * These are only the rows that appear in both dataframes.\r\n     *\r\n     * @param inner The inner dataframe to merge (the dataframe you call the function on is the 'outer' dataframe).\r\n     * @param outerSelector Optional user-defined selector function that selects the key from the outer dataframe that is used to match the two dataframes.\r\n     * @param innerSelector Optional user-defined selector function that selects the key from the inner dataframe that is used to match the two dataframes.\r\n     * \r\n     * @return Returns a new dataframe that contains the intersection of rows from the two input dataframes.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfA = ...\r\n     * const dfB = ...\r\n     * const mergedDf = dfA.intersection(dfB);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Merge two sets of customer records to find only the\r\n     * // customers that appears in both.\r\n     * const customerRecordsA = ...\r\n     * const customerRecordsB = ...\r\n     * const intersectionOfCustomerRecords = customerRecordsA.intersection(\r\n     *      customerRecordsB, \r\n     *      customerRecord => customerRecord.CustomerId\r\n     * );\r\n     * </pre>     \r\n     * */\r\n    intersection<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\r\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \r\n        outerSelector?: SelectorFn<ValueT, KeyT>,\r\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \r\n            IDataFrame<IndexT, ValueT>;\r\n    \r\n    /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains only the rows from the 1st dataframe that don't appear in the 2nd dataframe.\r\n     * This is essentially subtracting the rows from the 2nd dataframe from the 1st and creating a new dataframe with the remaining rows.\r\n     *\r\n     * @param inner The inner dataframe to merge (the dataframe you call the function on is the 'outer' dataframe).\r\n     * @param outerSelector Optional user-defined selector function that selects the key from the outer dataframe that is used to match the two dataframes.\r\n     * @param innerSelector Optional user-defined selector function that selects the key from the inner dataframe that is used to match the two dataframes.\r\n     * \r\n     * @return Returns a new dataframe that contains only the rows from the 1st dataframe that don't appear in the 2nd dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfA = ...\r\n     * const dfB = ...\r\n     * const remainingDf = dfA.except(dfB);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Find the list of customers haven't bought anything recently.\r\n     * const allCustomers = ... list of all customers ...\r\n     * const recentCustomers = ... list of customers who have purchased recently ...\r\n     * const remainingCustomers = allCustomers.except(\r\n     *      recentCustomers, \r\n     *      customerRecord => customerRecord.CustomerId\r\n     * );\r\n     * </pre>\r\n     */\r\n    except<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\r\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \r\n        outerSelector?: SelectorFn<ValueT, KeyT>,\r\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \r\n            IDataFrame<IndexT, ValueT>;\r\n\r\n   /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains only those rows that have matching keys in both input dataframes.\r\n     *\r\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * @return Returns the new merged dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought both product A and product B.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const customersWhoBoughtBothProductsDf = customerWhoBoughtProductA.join(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    join<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT, InnerValueT, ResultValueT>):\r\n            IDataFrame<number, ResultValueT>;\r\n\r\n    /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains only those rows that are only present in one or the other of the dataframes, or both.\r\n     *\r\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * Implementation from here:\r\n     * \r\n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n     * \r\n     * @return Returns the new merged dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought either product A or product B, or both.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const customersWhoBoughtEitherProductButNotBothDf = customerWhoBoughtProductA.joinOuter(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    joinOuter<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\r\n            IDataFrame<number, ResultValueT>;\r\n    \r\n    /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains only those rows that are present either in both dataframes or only in the outer (left) dataframe.\r\n     * \r\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * Implementation from here:\r\n     * \r\n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n     * \r\n     * @return Returns the new merged dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought either just product A or both product A and product B.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterLeft(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    joinOuterLeft<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\r\n            IDataFrame<number, ResultValueT>;\r\n\r\n    /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains only those rows that are present either in both dataframes or only in the inner (right) dataframe.\r\n     *\r\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * Implementation from here:\r\n     * \r\n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n     * \r\n     * @return Returns the new merged dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought either just product B or both product A and product B.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterRight(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    joinOuterRight<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\r\n            IDataFrame<number, ResultValueT>;\r\n\r\n    /**\r\n     * Produces a summary of dataframe.\r\n     * \r\n     * @param spec Optional parameter that specifies which columns to aggregate and how to aggregate them. Leave this out to produce a default summary of all columns.\r\n     * \r\n     * @returns A object with fields that summary the values in the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = df.summarize();\r\n     * console.log(summary);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = df.summarize({ // Summarize using pre-defined functions.\r\n     *      Column1: Series.sum,\r\n     *      Column2: Series.average,\r\n     *      Column3: Series.count,\r\n     * });\r\n     * console.log(summary);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = df.summarize({ // Summarize using custom functions.\r\n     *      Column1: series => series.sum(),\r\n     *      Column2: series => series.std(),\r\n     *      ColumnN: whateverFunctionYouWant,\r\n     * });\r\n     * console.log(summary);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = df.summarize({ // Multiple output fields per column.\r\n     *      Column1: {\r\n     *          OutputField1: Series.sum,\r\n     *          OutputField2: Series.average,\r\n     *      },\r\n     *      Column2: {\r\n     *          OutputField3: series => series.sum(),\r\n     *          OutputFieldN: whateverFunctionYouWant,\r\n     *      },\r\n     * });\r\n     * console.log(summary);\r\n     * </pre>\r\n     */\r\n    summarize<OutputValueT = any> (\r\n        spec?: IMultiColumnAggregatorSpec\r\n            ): OutputValueT;\r\n\r\n    /**\r\n     * Reshape (or pivot) a dataframe based on column values.\r\n     * This is a powerful function that combines grouping, aggregation and sorting.\r\n     *\r\n     * @param columnOrColumns Column name whose values make the new DataFrame's columns.\r\n     * @param valueColumnNameOrSpec Column name or column spec that defines the columns whose values should be aggregated.\r\n     * @param aggregator Optional function used to aggregate pivotted vales. \r\n     *\r\n     * @return Returns a new dataframe that has been pivoted based on a particular column's values. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Simplest example.\r\n     * // Group by the values in 'PivotColumn'.\r\n     * // The column 'ValueColumn' is aggregated for each group and this becomes the \r\n     * // values in the output column.\r\n     * const pivottedDf = df.pivot(\"PivotColumn\", \"ValueColumn\", values => values.average());\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Multiple input column example.\r\n     * // Similar to the previous example except now we are aggregating multiple input columns.\r\n     * // Each group has the average computed for 'ValueColumnA' and the sum for 'ValueColumnB'.\r\n     * const pivottedDf = df.pivot(\"PivotColumn\", { \r\n     *      ValueColumnA: aValues => aValues.average(),\r\n     *      ValueColumnB:  bValues => bValues.sum(),\r\n     * });\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Multiple output column example.\r\n     * // Similar to the previous example except now we are aggregating multiple outputs for each input column.\r\n     * // This example produces an output dataframe with columns OutputColumnA, B, C and D.\r\n     * // OutputColumnA/B are the sum and average of ValueColumnA across each group as defined by PivotColumn.\r\n     * // OutputColumnC/D are the sum and average of ValueColumnB across each group as defined by PivotColumn.\r\n     * const pivottedDf = df.pivot(\"PivotColumn\", { \r\n     *      ValueColumnA: {\r\n     *          OutputColumnA: aValues => aValues.sum(),\r\n     *          OutputColumnB: aValues => aValues.average(),\r\n     *      },\r\n     *      ValueColumnB: {\r\n     *          OutputColumnC: bValues => bValues.sum(),\r\n     *          OutputColumnD: bValues => bValues.average(),\r\n     *      },\r\n     * });\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Full multi-column example.\r\n     * // Similar to the previous example, but now we are pivotting on multiple columns.\r\n     * // We now group by 'PivotColumnA' and then by 'PivotColumnB', effectively creating a \r\n     * // multi-level nested group.\r\n     * const pivottedDf = df.pivot([\"PivotColumnA\", \"PivotColumnB\" ], { \r\n     *      ValueColumnA: aValues => aValues.average(),\r\n     *      ValueColumnB:  bValues => bValues.sum(),\r\n     * });\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // To help understand the pivot function, let's expand it out and look at what it does internally.\r\n     * // Take the simplest example:\r\n     * const pivottedDf = df.pivot(\"PivotColumn\", \"ValueColumn\", values => values.average());\r\n     * \r\n     * // If we expand out the internals of the pivot function, it will look something like this:\r\n     * const pivottedDf = df.groupBy(row => row.PivotColumn)\r\n     *          .select(group => ({\r\n     *              PivotColumn: group.first().PivotColumn,\r\n     *              ValueColumn: group.deflate(row => row.ValueColumn).average()\r\n     *          }))\r\n     *          .orderBy(row  => row.PivotColumn);\r\n     * \r\n     * // You can see that pivoting a dataframe is the same as grouping, aggregating and sorting it.\r\n     * // Does pivoting seem simpler now?\r\n     * \r\n     * // It gets more complicated than that of course, because the pivot function supports multi-level nested \r\n     * // grouping and aggregation of multiple columns. So a full expansion of the pivot function is rather complex.\r\n     * </pre>\r\n     */\r\n    pivot<NewValueT = ValueT> (\r\n        columnOrColumns: string | Iterable<string>, \r\n        valueColumnNameOrSpec: string | IMultiColumnAggregatorSpec, \r\n        aggregator?: (values: ISeries<number, any>) => any\r\n            ): IDataFrame<number, NewValueT>;\r\n\r\n    /**\r\n     * Unpivot a DataFrame from wide to long format, optionally leaving identifiers set.\r\n     * This is a powerful function that combines grouping, aggregation and sorting.\r\n     *\r\n     * @param idColumnOrColumns Column(s) to use as identifier variables.\r\n     * @param valueColumnOrColumns Column(s) to unpivot.\r\n     *\r\n     * @return Returns a new dataframe that has been unpivoted based on a particular column's values. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Use column in 'idColumnOrColumns' as the identity column.\r\n     * // The column name passed in 'valueColumnOrColumns' forms the 'variable' column\r\n     * // and the values are used to populate the 'value' column of the new dataframe.\r\n     * const moltenDf = df.melt(\"A\", \"B\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Multiple value columns example.\r\n     * // Similar to the previous example except now the variable column will constitute\r\n     * // of multiple values.\r\n     * const moltenDf = df.melt(\"A\", [\"B\", \"C\"]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Multiple identity and value columns example.\r\n     * const moltenDf = df.melt([\"A\", \"B\"], [\"C\", \"D\"]);\r\n     * </pre>\r\n     */\r\n    melt<NewValueT = ValueT> (\r\n        idColumnOrColumns: string | Iterable<string>,\r\n        valueColumnOrColumns: string | Iterable<string>\r\n            ): IDataFrame<IndexT, NewValueT>;\r\n\r\n    /**\r\n     * Insert a pair at the start of the dataframe.\r\n     * Doesn't modify the original dataframe! The returned dataframe is entirely new and contains rows from the original dataframe plus the inserted pair.\r\n     *\r\n     * @param pair The index/value pair to insert.\r\n     * \r\n     * @return Returns a new dataframe with the specified pair inserted.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const newIndex = ... index of the new row ...\r\n     * const newRow = ... the new data row to insert ...\r\n     * const insertedDf = df.insertPair([newIndex, newRows]);\r\n     * </pre>\r\n     */\r\n    insertPair (pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Append a pair to the end of a dataframe.\r\n     * Doesn't modify the original dataframe! The returned dataframe is entirely new and contains rows from the original dataframe plus the appended pair.\r\n     *\r\n     * @param pair The index/value pair to append.\r\n     *  \r\n     * @return Returns a new dataframe with the specified pair appended.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const newIndex = ... index of the new row ...\r\n     * const newRow = ... the new data row to append ...\r\n     * const appendedDf = df.appendPair([newIndex, newRows]);\r\n     * </pre>\r\n     */\r\n    appendPair (pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Removes rows from the dataframe by index.\r\n     */\r\n    remove(index: IndexT): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Fill gaps in a dataframe.\r\n     *\r\n     * @param comparer User-defined comparer function that is passed pairA and pairB, two consecutive rows, return truthy if there is a gap between the rows, or falsey if there is no gap.\r\n     * @param generator User-defined generator function that is passed pairA and pairB, two consecutive rows, returns an array of pairs that fills the gap between the rows.\r\n     *\r\n     * @return Returns a new dataframe with gaps filled in.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     *   var sequenceWithGaps = ...\r\n     *\r\n     *  // Predicate that determines if there is a gap.\r\n     *  var gapExists = (pairA, pairB) => {\r\n     *      // Returns true if there is a gap.\r\n     *      return true;\r\n     *  };\r\n     *\r\n     *  // Generator function that produces new rows to fill the game.\r\n     *  var gapFiller = (pairA, pairB) => {\r\n     *      // Create an array of index, value pairs that fill the gaps between pairA and pairB.\r\n     *      return [\r\n     *          newPair1,\r\n     *          newPair2,\r\n     *          newPair3,\r\n     *      ];\r\n     *  };\r\n     *\r\n     *  var sequenceWithoutGaps = sequenceWithGaps.fillGaps(gapExists, gapFiller);\r\n     * </pre>\r\n     */\r\n    fillGaps (comparer: ComparerFn<[IndexT, ValueT], [IndexT, ValueT]>, generator: GapFillFn<[IndexT, ValueT], [IndexT, ValueT]>): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Returns the specified default dataframe if the input dataframe is empty. \r\n     *\r\n     * @param defaultSequence Default dataframe to return if the input dataframe is empty.\r\n     * \r\n     * @return Returns 'defaultSequence' if the input dataframe is empty. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const emptyDataFrame = new DataFrame();\r\n     * const defaultDataFrame = new DataFrame([ { A: 1 }, { A: 2 }, { A: 3 } ]);\r\n     * expect(emptyDataFrame.defaultIfEmpty(defaultDataFrame)).to.eql(defaultDataFrame);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const nonEmptyDataFrame = new DataFrame([ { A: 100 }]);\r\n     * const defaultDataFrame = new DataFrame([ { A: 1 }, { A: 2 }, { A: 3 } ]);\r\n     * expect(nonEmptyDataFrame.defaultIfEmpty(defaultDataFrame)).to.eql(nonEmptyDataFrame);\r\n     * </pre>\r\n     */\r\n    defaultIfEmpty (defaultSequence: ValueT[] | IDataFrame<IndexT, ValueT>): IDataFrame<IndexT, ValueT>;\r\n\r\n    /**\r\n     * Detect the the frequency of the types of the values in the dataframe.\r\n     * This is a good way to understand the shape of your data.\r\n     *\r\n     * @return Returns a dataframe with rows that confirm to {@link ITypeFrequency} that describes the data types contained in the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = dataForge.readFileSync(\"./my-data.json\").parseJSON();\r\n     * const dataTypes = df.detectTypes();\r\n     * console.log(dataTypes.toString());\r\n     * </pre>\r\n     */\r\n    detectTypes (): IDataFrame<number, ITypeFrequency>;\r\n\r\n    /**\r\n     * Detect the frequency of the values in the dataframe.\r\n     * This is a good way to understand the shape of your data.\r\n     *\r\n     * @return Returns a dataframe with rows that conform to {@link IValueFrequency} that describes the values contained in the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = dataForge.readFileSync(\"./my-data.json\").parseJSON();\r\n     * const dataValues = df.detectValues();\r\n     * console.log(dataValues.toString());\r\n     * </pre>\r\n     */\r\n    detectValues (): IDataFrame<number, IValueFrequency>;\r\n\r\n    /**\r\n     * Serialize the dataframe to the JSON data format.\r\n     * \r\n     * @return Returns a string in the JSON data format that represents the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const jsonData = df.toJSON();\r\n     * console.log(jsonData);\r\n     * </pre>\r\n     */\r\n    toJSON (): string;\r\n\r\n    /**\r\n     * Serialize the dataframe to the JSON5 data format.\r\n     * \r\n     * @return Returns a string in the JSON5 data format that represents the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const jsonData = df.toJSON5();\r\n     * console.log(jsonData);\r\n     * </pre>\r\n     */\r\n    toJSON5 (): string;\r\n\r\n    /**\r\n     * Serialize the dataframe to the CSV data format.\r\n     * \r\n     * @param options Options for CSV output. The options object is passed directly to [PapaParse.unparse](https://www.papaparse.com/docs#unparse), please see [PapaParse docs for additional options](https://www.papaparse.com/docs#unparse-config-default).\r\n     * \r\n     * @return Returns a string in the CSV data format that represents the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const csvData = df.toCSV();\r\n     * console.log(csvData);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const csvData = df.toCSV({ header: false });\r\n     * console.log(csvData);\r\n     * </pre>\r\n     */\r\n    toCSV (options?: ICSVOutputOptions): string;\r\n\r\n    /**\r\n     * Serialize the dataframe to HTML.\r\n     * \r\n     * @return Returns a string in HTML format that represents the dataframe.\r\n     */\r\n    toHTML (): string;\r\n    \r\n    /**\r\n     * Serialize the dataframe to an ordinary JavaScript data structure.\r\n     * The resulting data structure is suitable for further serialization to JSON and can be used to \r\n     * transmit a DataFrame and its internal structure over the wire.\r\n     * Use the {@link deserialize} function to later reconstitute the serialized dataframe.\r\n     * \r\n     * @return Returns a JavaScript data structure conforming to {@link ISerializedDataFrame} that represents the dataframe and its internal structure.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const jsDataStructure = df.serialize();\r\n     * const jsonData = JSON.stringify(jsDataStructure);\r\n     * console.log(jsonData);\r\n     * const deserializedJsDataStructure = JSON.parse(jsonData);\r\n     * const deserializedDf = DataFrame.deserialize(deserializedJsDataStructure); // Reconsituted.\r\n     * </pre>\r\n     */\r\n    serialize (): any;\r\n}\r\n\r\n/**\r\n * Interface to a dataframe that has been sorted.\r\n */\r\nexport interface IOrderedDataFrame<IndexT = number, ValueT = any, SortT = any> extends IDataFrame<IndexT, ValueT> {\r\n\r\n    /** \r\n     * Applys additional sorting (ascending) to an already sorted dataframe.\r\n     * \r\n     * @param selector User-defined selector that selects the additional value to sort by.\r\n     * \r\n     * @return Returns a new dataframe has been additionally sorted by the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Order sales by salesperson and then by amount (from least to most).\r\n     * const orderedDf = salesDf.orderBy(sale => sale.SalesPerson).thenBy(sale => sale.Amount);\r\n     * </pre>\r\n     */\r\n    thenBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;\r\n\r\n    /** \r\n     * Applys additional sorting (descending) to an already sorted dataframe.\r\n     * \r\n     * @param selector User-defined selector that selects the additional value to sort by.\r\n     * \r\n     * @return Returns a new dataframe has been additionally sorted by the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Order sales by salesperson and then by amount (from most to least).\r\n     * const orderedDf = salesDf.orderBy(sale => sale.SalesPerson).thenByDescending(sale => sale.Amount);\r\n     * </pre>\r\n     */\r\n    thenByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;\r\n}\r\n\r\n//\r\n// Represents the contents of a dataframe.\r\n//\r\ninterface IDataFrameContent<IndexT, ValueT> {\r\n\r\n    /***\r\n     * Iterates the index for the dataframe.\r\n     */\r\n    index: Iterable<IndexT>;\r\n\r\n    /**\r\n     * Iterates values for each row in the dataframe.\r\n     */\r\n    values: Iterable<ValueT>;\r\n\r\n    /**\r\n     * Iterates the index/value pairs in the dataframe.\r\n     */\r\n    pairs: Iterable<[IndexT, ValueT]>;\r\n\r\n    /**\r\n      * Array or iterable of column names that are in the dataframe.\r\n      * The order matters. This arrays specifies the ordering of columns which\r\n      * is important when rendering tables or writing out CSV data files.\r\n      */\r\n    columnNames: string[] | Iterable<string>,\r\n \r\n    /***\r\n      * Set to true when the dataframe has been baked into memory\r\n      * and does not need to be lazily evaluated.\r\n      */\r\n    isBaked: boolean,\r\n\r\n    /**\r\n     * Set to true to make column names be case sensitive.\r\n     * Default behaviour is to treat column names as case insensitive.\r\n     */\r\n    isCaseSensitive: boolean;\r\n}\r\n\r\n/**\r\n * Class that represents a dataframe.\r\n * A dataframe contains an indexed sequence of data records.\r\n * Think of it as a spreadsheet or CSV file in memory.\r\n * \r\n * Each data record contains multiple named fields, the value of each field represents one row in a column of data.\r\n * Each column of data is a named {@link Series}.\r\n * You think of a dataframe a collection of named data series.\r\n * \r\n * @typeparam IndexT The type to use for the index.\r\n * @typeparam ValueT The type to use for each row/data record.\r\n */\r\nexport class DataFrame<IndexT = number, ValueT = any> implements IDataFrame<IndexT, ValueT> {\r\n\r\n    //\r\n    // Function to lazy evaluate the configuration of the dataframe.\r\n    //\r\n    private configFn: DataFrameConfigFn<IndexT, ValueT> | null = null;\r\n    \r\n    //\r\n    // The content of the dataframe.\r\n    // When this is null it means the dataframe is yet to be lazy initialised.\r\n    //\r\n    private content: IDataFrameContent<IndexT, ValueT> | null = null;\r\n    \r\n    // \r\n    // Indexed content of the dataframe.\r\n    // \r\n    private indexedContent: Map<any, ValueT> | null = null;\r\n    \r\n    private static readonly defaultCountIterable = new CountIterable();\r\n    private static readonly defaultEmptyIterable = new EmptyIterable();\r\n    \r\n    //\r\n    // Initialise a series from an iterator (or generator object).\r\n    //\r\n    private static initFromIterator<IndexT, ValueT>(iterator: Iterator<ValueT>): IDataFrameContent<IndexT, ValueT> {\r\n        return DataFrame.initFromIterable<IndexT, ValueT>(new CachedIteratorIterable(iterator));\r\n    }\r\n\r\n    //\r\n    // Initialise dataframe content from an iterable of values.\r\n    //\r\n    private static initFromIterable<IndexT, ValueT>(arr: Iterable<ValueT>): IDataFrameContent<IndexT, ValueT> {\r\n        const firstResult = arr[Symbol.iterator]().next();\r\n        const columnNames = !firstResult.done ? Object.keys(firstResult.value) : [];\r\n        return {\r\n            index: DataFrame.defaultCountIterable,\r\n            values: arr,\r\n            pairs: new MultiIterable([DataFrame.defaultCountIterable, arr]),\r\n            isBaked: true,\r\n            columnNames: columnNames,\r\n            isCaseSensitive: false,\r\n        };\r\n    }\r\n\r\n    //\r\n    // Initialise an empty dataframe.\r\n    //\r\n    private static initEmpty<IndexT, ValueT>(): IDataFrameContent<IndexT, ValueT> {\r\n        return {\r\n            index: DataFrame.defaultEmptyIterable,\r\n            values: DataFrame.defaultEmptyIterable,\r\n            pairs: DataFrame.defaultEmptyIterable,\r\n            isBaked: true,\r\n            columnNames: [],\r\n            isCaseSensitive: false,\r\n        };\r\n    }\r\n\r\n    //\r\n    // Initialise dataframe column names.\r\n    //\r\n    private static initColumnNames(inputColumnNames: Iterable<string>, isCaseSensitive?: boolean): Iterable<string> {\r\n        const outputColumnNames: string[] = [];\r\n        const columnNamesMap: any = {};\r\n\r\n        // Convert column names to strings.\r\n        const columnNames = Array.from(inputColumnNames).map(columnName => columnName.toString());\r\n\r\n        // Search for duplicate column names.\r\n        for (const columnName of columnNames) {\r\n            const columnNameLwr = isCaseSensitive !== undefined  && isCaseSensitive ? columnName : columnName.toLowerCase();\r\n\r\n            if (columnNamesMap[columnNameLwr] === undefined) {\r\n                columnNamesMap[columnNameLwr] = 1;\r\n            }\r\n            else {\r\n                columnNamesMap[columnNameLwr] += 1;\r\n            }\r\n        }\r\n\r\n        const columnNoMap: any = {};\r\n\r\n        for (const columnName of columnNames) {\r\n            const columnNameLwr = isCaseSensitive !== undefined  && isCaseSensitive ? columnName : columnName.toLowerCase();\r\n            if (columnNamesMap[columnNameLwr] > 1) {\r\n                let curColumnNo = 1;\r\n\r\n                // There are duplicates of this column.\r\n                if (columnNoMap[columnNameLwr] !== undefined) {\r\n                    curColumnNo = columnNoMap[columnNameLwr];\r\n                }\r\n\r\n                outputColumnNames.push(columnName + \".\" + curColumnNo);\r\n                columnNoMap[columnNameLwr] = curColumnNo + 1;\r\n            }\r\n            else {\r\n                // No duplicates.\r\n                outputColumnNames.push(columnName);\r\n            }\r\n        }\r\n\r\n        return outputColumnNames;\r\n    }\r\n\r\n    //\r\n    // Returns true if the input is an iterator.\r\n    //\r\n    private static isIterator(input: any): boolean {\r\n        return isObject(input) && isFunction(input.next);\r\n    }\r\n\r\n    //\r\n    // Returns true if the input is an iterable.\r\n    //\r\n    private static isIterable(input: any): boolean {\r\n        return isArray(input) || \r\n               (isObject(input) && isFunction(input[Symbol.iterator]));\r\n    }\r\n\r\n    //\r\n    // Check that a value is an interable.\r\n    //\r\n    private static checkIterable<T>(input: any, fieldName: string): void {\r\n        if (DataFrame.isIterable(input)) {\r\n            // Assume it's an iterable.\r\n            // Ok\r\n        }\r\n        else {\r\n            // Not ok\r\n            throw new Error(\"Expected '\" + fieldName + \"' field of DataFrame config object to be an array of values or an iterable of values.\");\r\n        }\r\n    }\r\n\r\n    //\r\n    // Initialise dataframe content from a config object.\r\n    //\r\n    private static initFromConfig<IndexT, ValueT>(config: IDataFrameConfig<IndexT, ValueT>): IDataFrameContent<IndexT, ValueT> {\r\n\r\n        let index: Iterable<IndexT>;\r\n        let values: Iterable<ValueT>;\r\n        let pairs: Iterable<[IndexT, ValueT]> | undefined;\r\n        let isBaked = false;\r\n        let columnNames: Iterable<string>;\r\n\r\n        if (config.pairs) {\r\n            if (DataFrame.isIterator(config.pairs)) {\r\n                pairs = new CachedIteratorIterable(config.pairs as Iterator<[IndexT, ValueT]>);\r\n            }\r\n            else {\r\n                DataFrame.checkIterable<[IndexT, ValueT]>(config.pairs, \"pairs\");\r\n                pairs = config.pairs as Iterable<[IndexT, ValueT]>;\r\n            }\r\n        }\r\n        \r\n        if (config.columns) {\r\n            let columnsConfig: any = config.columns;\r\n\r\n            if (DataFrame.isIterator(columnsConfig)) {\r\n                columnsConfig = new CachedIteratorIterable(columnsConfig as Iterator<IColumnConfig>);\r\n            }\r\n\r\n            if (DataFrame.isIterable(columnsConfig)) {\r\n                const iterableColumnsConfig = columnsConfig as Iterable<IColumnConfig>;\r\n                columnNames = Array.from(iterableColumnsConfig).map(column => column.name);\r\n                columnsConfig = toMap(iterableColumnsConfig, column => column.name, column => column.series);\r\n            }\r\n            else {\r\n                if (!isObject(columnsConfig)) throw new Error(\"Expected 'columns' member of 'config' parameter to DataFrame constructor to be an object with fields that define columns.\");\r\n\r\n                columnNames = Object.keys(columnsConfig);\r\n            }\r\n\r\n            const columnIterables: any[] = [];\r\n            for (const columnName of columnNames) {\r\n                let columnConfig = columnsConfig[columnName];\r\n                if (DataFrame.isIterator(columnConfig)) {\r\n                    columnConfig = new CachedIteratorIterable(columnConfig as Iterator<any>);\r\n                }\r\n                else {\r\n                    DataFrame.checkIterable(columnConfig, columnName);\r\n                }\r\n                columnIterables.push(columnConfig);\r\n            }\r\n\r\n            values = new CsvRowsIterable(columnNames, new MultiIterable(columnIterables));\r\n        }\r\n        else {\r\n            if (config.columnNames) {\r\n                if (DataFrame.isIterator(config.columnNames)) {\r\n                    columnNames = new CachedIteratorIterable(config.columnNames as Iterator<string>);\r\n                }\r\n                else {\r\n                    columnNames = config.columnNames as Iterable<string>;\r\n                }\r\n\r\n                columnNames = this.initColumnNames(columnNames, config.caseSensitive);\r\n            }\r\n\r\n            if (config.rows) {\r\n                if (!config.columnNames) {\r\n                    columnNames = new SelectIterable(new CountIterable(), c => \"Column.\" + c.toString());\r\n                }\r\n\r\n                let rows: Iterable<any>\r\n                if (DataFrame.isIterator(config.rows)) {\r\n                    rows = new CachedIteratorIterable(config.rows as Iterator<any>);\r\n                }\r\n                else {\r\n                    DataFrame.checkIterable<any[][]>(config.rows, 'rows')\r\n                    rows = config.rows as Iterable<any>;\r\n                }\r\n                    \r\n                values = new CsvRowsIterable(columnNames!, rows); // Convert data from rows to columns.\r\n            }\r\n            else if (config.values) {\r\n                if (DataFrame.isIterator(config.values)) {\r\n                    values = new CachedIteratorIterable(config.values as Iterator<ValueT>);\r\n                }\r\n                else {\r\n                    DataFrame.checkIterable<ValueT>(config.values, \"values\");\r\n                    values = config.values as Iterable<ValueT>;\r\n                }\r\n\r\n                if (!config.columnNames) {\r\n                    columnNames = new ColumnNamesIterable(values, config.considerAllRows || false);\r\n                }\r\n            }\r\n            else if (pairs) {\r\n                values = new ExtractElementIterable(pairs, 1);\r\n                if (!config.columnNames) {\r\n                    columnNames = new ColumnNamesIterable(values, config.considerAllRows || false);\r\n                }\r\n            }\r\n            else {\r\n                values = DataFrame.defaultEmptyIterable;\r\n                if (!config.columnNames) {\r\n                    columnNames = DataFrame.defaultEmptyIterable;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (config.index) {\r\n            if (DataFrame.isIterator(config.index)) {\r\n                index = new CachedIteratorIterable(config.index as Iterator<IndexT>);\r\n            }\r\n            else {\r\n                DataFrame.checkIterable<IndexT>(config.index, 'index');\r\n                index = config.index as Iterable<IndexT>;\r\n            }\r\n        }\r\n        else if (pairs) {\r\n            index = new ExtractElementIterable(pairs, 0);\r\n        }\r\n        else {\r\n            index = DataFrame.defaultCountIterable;\r\n        }\r\n\r\n        if (!pairs) {\r\n            pairs = new MultiIterable([index, values]);\r\n        }\r\n\r\n        if (config.baked !== undefined) {\r\n            isBaked = config.baked;\r\n        }\r\n\r\n        return {\r\n            index: index,\r\n            values: values,\r\n            pairs: pairs,\r\n            isBaked: isBaked,\r\n            columnNames: columnNames!,\r\n            isCaseSensitive: config.caseSensitive || false,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create a dataframe.\r\n     * \r\n     * @param config This can be an array, a configuration object or a function that lazily produces a configuration object. \r\n     * \r\n     * It can be an array that specifies the data records that the dataframe contains.\r\n     * \r\n     * It can be a {@link IDataFrameConfig} that defines the data and configuration of the dataframe.\r\n     * \r\n     * Or it can be a function that lazily produces a {@link IDataFrameConfig}.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = new DataFrame();\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = new DataFrame([ { A: 10 }, { A: 20 }, { A: 30 }, { A: 40 }]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = new DataFrame({ index: [1, 2, 3, 4], values: [ { A: 10 }, { A: 20 }, { A: 30 }, { A: 40 }] });\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const lazyInit = () => ({ index: [1, 2, 3, 4], values: [ { A: 10 }, { A: 20 }, { A: 30 }, { A: 40 }] });\r\n     * const df = new DataFrame(lazyInit);\r\n     * </pre>\r\n     */\r\n    constructor(config?: Iterator<ValueT> | Iterable<ValueT> | IDataFrameConfig<IndexT, ValueT> | DataFrameConfigFn<IndexT, ValueT> | IDataFrame | ISeries) {\r\n        if (config) {\r\n            const configAsAny = config as any;\r\n            if (configAsAny.getTypeCode !== undefined) {\r\n                const typeCode = configAsAny.getTypeCode();\r\n                if (typeCode === \"dataframe\" || typeCode === \"series\") {\r\n                    if (configAsAny.content !== undefined) {\r\n                        this.content = configAsAny.content;\r\n                    }\r\n                    else {\r\n                        this.configFn = configAsAny.configFn;\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            \r\n            if (isFunction(config)) {\r\n                this.configFn = config;\r\n            }\r\n            else if (DataFrame.isIterator(config)) {\r\n                this.content = DataFrame.initFromIterator(config as Iterator<ValueT>);\r\n            }\r\n            else if (DataFrame.isIterable(config)) {\r\n                this.content = DataFrame.initFromIterable(config as Iterable<ValueT>);\r\n            }\r\n            else {\r\n                this.content = DataFrame.initFromConfig(config as IDataFrameConfig<IndexT, ValueT>);\r\n            }\r\n        }\r\n        else {\r\n            this.content = DataFrame.initEmpty();\r\n        }\r\n    }\r\n\r\n    //\r\n    // Ensure the dataframe content has been initialised.\r\n    //\r\n    private lazyInit() {\r\n        if (this.content === null && this.configFn !== null) {\r\n            this.content = DataFrame.initFromConfig(this.configFn());\r\n        }\r\n    }\r\n\r\n    //\r\n    // Ensure the dataframe content is lazy initialised and return it.\r\n    //\r\n    private getContent(): IDataFrameContent<IndexT, ValueT> { \r\n        this.lazyInit();\r\n        return this.content!;\r\n    }\r\n    \r\n    // \r\n    // Lazy builds content index, does basic hash lookup.\r\n    //\r\n    private getRowByIndex(index: IndexT): ValueT | undefined {\r\n        if (!this.indexedContent) {\r\n            this.indexedContent = new Map<any, ValueT>();\r\n            for (const pair of this.getContent().pairs) {\r\n                this.indexedContent.set(pair[0], pair[1]);\r\n            }\r\n        }\r\n       \r\n        return this.indexedContent.get(index);\r\n    }\r\n    \r\n    /**\r\n     * Get an iterator to enumerate the rows of the dataframe.\r\n     * Enumerating the iterator forces lazy evaluation to complete.\r\n     * This function is automatically called by `for...of`.\r\n     * \r\n     * @return An iterator for the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * for (const row of df) {\r\n     *     // ... do something with the row ...\r\n     * }\r\n     * </pre>\r\n     */\r\n    [Symbol.iterator](): Iterator<any> {\r\n        return this.getContent().values[Symbol.iterator]();\r\n    }\r\n\r\n    /**\r\n     * Get the names of the columns in the dataframe.\r\n     * \r\n     * @return Returns an array of the column names in the dataframe.  \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * console.log(df.getColumnNames());\r\n     * </pre>\r\n     */\r\n    getColumnNames (): string[] {\r\n        return Array.from(this.getContent().columnNames);\r\n    }\r\n\r\n    /** \r\n     * Retreive the collection of all columns in the dataframe.\r\n     * \r\n     * @return Returns a {@link Series} containing the names of the columns in the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * for (const column in df.getColumns()) {\r\n     *      console.log(\"Column name: \");\r\n     *      console.log(column.name);\r\n     * \r\n     *      console.log(\"Data:\");\r\n     *      console.log(column.series.toArray());\r\n     * }\r\n     * </pre>\r\n     */\r\n    getColumns (): ISeries<number, IColumn> {\r\n        return new Series<number, IColumn>(() => {\r\n            const columnNames = this.getColumnNames();\r\n            return {\r\n                values: columnNames.map(columnName => {\r\n                    const series = this.getSeries(columnName).skipWhile(value => value === undefined || value === null);\r\n                    const firstValue = series.any() ? series.first() : undefined;\r\n                    return {\r\n                        name: columnName,\r\n                        type: determineType(firstValue), //TODO: Should cache the type.\r\n                        series: series,\r\n                    };\r\n                }),\r\n            };\r\n        });\r\n    }    \r\n\r\n    /**\r\n     * Returns true if the dataframe is case sensitive or false if case insensitive.\r\n     * \r\n     * @return true if the dataframe is case sensitive, otherwise false.\r\n     */\r\n    isCaseSensitive (): boolean {\r\n        return this.getContent().isCaseSensitive;\r\n    }\r\n\r\n    /**\r\n     * Cast the value of the dataframe to a new type.\r\n     * This operation has no effect but to retype the value that the dataframe contains.\r\n     * \r\n     * @return The same dataframe, but with the type changed.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const castDf = df.cast<SomeOtherType>();\r\n     * </pre>\r\n     */\r\n    cast<NewValueT> (): IDataFrame<IndexT, NewValueT> {\r\n        return this as any as IDataFrame<IndexT, NewValueT>;\r\n    }\r\n    \r\n    /**\r\n     * Get the index for the dataframe.\r\n     * \r\n     * @return The {@link Index} for the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const index = df.getIndex();\r\n     * </pre>\r\n     */\r\n    getIndex (): IIndex<IndexT> {\r\n        return new Index<IndexT>(() => ({ values: this.getContent().index }));\r\n    }\r\n\r\n    /**\r\n     * Set a named column as the {@link Index} of the dataframe.\r\n     *\r\n     * @param columnName Name of the column to use as the new {@link Index} of the returned dataframe.\r\n     *\r\n     * @return Returns a new dataframe with the values of the specified column as the new {@link Index}.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedDf = df.setIndex(\"SomeColumn\");\r\n     * </pre>\r\n     */\r\n    setIndex<NewIndexT = any> (columnName: string): IDataFrame<NewIndexT, ValueT> {\r\n        if (!isString(columnName)) throw new Error(\"Expected 'columnName' parameter to 'DataFrame.setIndex' to be a string that specifies the name of the column to set as the index for the dataframe.\");\r\n\r\n        return this.withIndex<NewIndexT>(this.getSeries(columnName));\r\n    }\r\n    \r\n    /**\r\n     * Apply a new {@link Index} to the dataframe.\r\n     * \r\n     * @param newIndex The new array or iterable to be the new {@link Index} of the dataframe. Can also be a selector to choose the {@link Index} for each row in the dataframe.\r\n     * \r\n     * @return Returns a new dataframe or dataframe with the specified {@link Index} attached.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedDf = df.withIndex([10, 20, 30]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedDf = df.withIndex(df.getSeries(\"SomeColumn\"));\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedDf = df.withIndex(row => row.SomeColumn);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const indexedDf = df.withIndex(row => row.SomeColumn + 20);\r\n     * </pre>\r\n     */\r\n    withIndex<NewIndexT> (newIndex: Iterable<NewIndexT> | SelectorFn<ValueT, NewIndexT>): IDataFrame<NewIndexT, ValueT> {\r\n\r\n        if (isFunction(newIndex)) {\r\n            return new DataFrame<NewIndexT, ValueT>(() => {\r\n                const content = this.getContent();\r\n                return {\r\n                    columnNames: content.columnNames,\r\n                    values: content.values,\r\n                    index: this.deflate(newIndex),\r\n                };\r\n            });\r\n        }\r\n        else {\r\n            DataFrame.checkIterable(newIndex as Iterable<NewIndexT>, 'newIndex');\r\n\r\n            return new DataFrame<NewIndexT, ValueT>(() => {\r\n                const content = this.getContent();\r\n                return {\r\n                    columnNames: content.columnNames,\r\n                    values: content.values,\r\n                    index: newIndex as Iterable<NewIndexT>,\r\n                };\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the {@link Index} of the dataframe back to the default zero-based sequential integer index.\r\n     * \r\n     * @return Returns a new dataframe with the {@link Index} reset to the default zero-based index. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithResetIndex = df.resetIndex();\r\n     * </pre>\r\n     */\r\n    resetIndex (): IDataFrame<number, ValueT> {\r\n        return new DataFrame<number, ValueT>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                columnNames: content.columnNames,\r\n                values: content.values,\r\n                // Strip the index.\r\n            };\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Extract a {@link Series} from a named column in the dataframe.\r\n     *\r\n     * @param columnName Specifies the name of the column that contains the {@link Series} to retreive.\r\n     * \r\n     * @return Returns the {@link Series} extracted from the named column in the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = df.getSeries(\"SomeColumn\");\r\n     * </pre>\r\n     */\r\n    getSeries<SeriesValueT = any> (columnName: string): ISeries<IndexT, SeriesValueT> {\r\n\r\n        if (!isString(columnName)) throw new Error(\"Expected 'columnName' parameter to 'DataFrame.getSeries' function to be a string that specifies the name of the column to retreive.\");\r\n\r\n        return new Series<IndexT, SeriesValueT>(() => ({\r\n            values: new SelectIterable<ValueT, SeriesValueT>(\r\n                this.getContent().values, \r\n                (row: any) => row[columnName],\r\n            ),\r\n            index: this.getContent().index,\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Determine if the dataframe contains a {@link Series} the specified named column.\r\n     *\r\n     * @param columnName Name of the column to check for.\r\n     * \r\n     * @return Returns true if the dataframe contains the requested {@link Series}, otherwise returns false.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * if (df.hasSeries(\"SomeColumn\")) {\r\n     *      // ... the dataframe contains a series with the specified column name ...\r\n     * }\r\n     * </pre>\r\n     */\r\n    hasSeries (columnName: string): boolean {\r\n        const columnNameLwr = columnName.toLowerCase();\r\n        for (const existingColumnName of this.getColumnNames()) {\r\n            if (existingColumnName.toLowerCase() === columnNameLwr) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Verify the existence of a name column and extracts the {@link Series} for it.\r\n     * Throws an exception if the requested column doesn't exist.\r\n     *\r\n     * @param columnName Name of the column to extract.\r\n     * \r\n     * @return Returns the {@link Series} for the column if it exists, otherwise it throws an exception.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * try {\r\n     *      const series = df.expectSeries(\"SomeColumn\");\r\n     *      // ... do something with the series ...\r\n     * }\r\n     * catch (err) {\r\n     *      // ... the dataframe doesn't contain the column \"SomeColumn\" ...\r\n     * }\r\n     * </pre>\r\n     */\r\n    expectSeries<SeriesValueT> (columnName: string): ISeries<IndexT, SeriesValueT> {\r\n        if (!this.hasSeries(columnName)) {\r\n            throw new Error(\"Expected dataframe to contain series with column name: '\" + columnName + \"'.\");\r\n        }\r\n\r\n        return this.getSeries(columnName);\r\n    }\r\n\r\n    /**\r\n     * Create a new dataframe with a replaced or additional column specified by the passed-in series.\r\n     *\r\n     * @param columnNameOrSpec The name of the column to add or replace or a {@link IColumnGenSpec} that defines the columns to add.\r\n     * @param series When columnNameOrSpec is a string that identifies the column to add, this specifies the {@link Series} to add to the dataframe or a function that produces a series (given a dataframe).\r\n     *\r\n     * @return Returns a new dataframe replacing or adding a particular named column.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.withSeries(\"ANewColumn\", new Series([1, 2, 3]));\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.withSeries(\"ANewColumn\", df => \r\n     *      df.getSeries(\"SourceData\").select(aTransformation)\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.withSeries({\r\n     *      ANewColumn: new Series([1, 2, 3]),\r\n     *      SomeOtherColumn: new Series([10, 20, 30])\r\n     * });\r\n     * <pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.withSeries({\r\n     *      ANewColumn: df => df.getSeries(\"SourceData\").select(aTransformation))\r\n     * });\r\n     * <pre>\r\n     */\r\n    withSeries<OutputValueT = any, SeriesValueT = any> (columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, OutputValueT> {\r\n\r\n        if (!isObject(columnNameOrSpec)) {\r\n            if (!isString(columnNameOrSpec)) throw new Error(\"Expected 'columnNameOrSpec' parameter to 'DataFrame.withSeries' function to be a string that specifies the column to set or replace.\");\r\n            if (!isFunction(series as Object)) {\r\n                if (!isObject(series)) throw new Error(\"Expected 'series' parameter to 'DataFrame.withSeries' to be a Series object or a function that takes a dataframe and produces a Series.\");\r\n            }\r\n        }\r\n        else {\r\n            if (!isUndefined(series)) throw new Error(\"Expected 'series' parameter to 'DataFrame.withSeries' to not be set when 'columnNameOrSpec is an object.\");\r\n        }\r\n\r\n        if (isObject(columnNameOrSpec)) {\r\n            const columnSpec: IColumnGenSpec = <IColumnGenSpec> columnNameOrSpec;\r\n            const columnNames = Object.keys(columnSpec);\r\n            let workingDataFrame: IDataFrame<IndexT, ValueT> = this;\r\n            for (const columnName of columnNames) {\r\n                workingDataFrame = workingDataFrame.withSeries(columnName, columnSpec[columnName]);\r\n            }\r\n\r\n            return workingDataFrame.cast<OutputValueT>();\r\n        }\r\n\r\n        const columnName: string = <string> columnNameOrSpec;\r\n\r\n        if (this.none()) { // We have an empty data frame.\r\n            let importSeries: ISeries<IndexT, SeriesValueT>;\r\n    \r\n            if (isFunction(series as Object)) {\r\n                importSeries = (series! as SeriesSelectorFn<IndexT, ValueT, SeriesValueT>)(this);\r\n            }\r\n            else { \r\n                importSeries = series! as ISeries<IndexT, SeriesValueT>;\r\n            }\r\n                \r\n            \r\n            return importSeries.inflate<ValueT>(value => {\r\n                    var row: any = {};\r\n                    row[columnName] = value;\r\n                    return row;\r\n                })\r\n                .cast<OutputValueT>();\r\n        }\r\n\r\n        return new DataFrame<IndexT, OutputValueT>(() => {    \r\n            let importSeries: ISeries<IndexT, SeriesValueT>;\r\n    \r\n            if (isFunction(series as Object)) {\r\n                importSeries = (series! as SeriesSelectorFn<IndexT, ValueT, SeriesValueT>)(this);\r\n            }\r\n            else { \r\n                importSeries = series! as ISeries<IndexT, SeriesValueT>;\r\n            }\r\n\r\n            const seriesValueMap = toMap2(importSeries.toPairs(), pair => pair[0], pair => pair[1]);\r\n            const newColumnNames =  makeDistinct(this.getColumnNames().concat([columnName]));\r\n    \r\n            return {\r\n                columnNames: newColumnNames,\r\n                index: this.getContent().index,\r\n                pairs: new SelectIterable<[IndexT, ValueT], [IndexT, OutputValueT]>(this.getContent().pairs, pair => {\r\n                    const index = pair[0];\r\n                    const value = pair[1];\r\n                    const modified: any = Object.assign({}, value);\r\n                    modified[columnName] = seriesValueMap.get(index);\r\n                    return [\r\n                        index,\r\n                        modified\r\n                    ];\r\n                }),\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Merge multiple dataframes into a single dataframe.\r\n     * Rows are merged by indexed. \r\n     * Same named columns in subsequent dataframes override columns earlier dataframes.\r\n     * \r\n     * @param dataFrames An array or series of dataframes to merge.\r\n     * \r\n     * @returns The merged data frame.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const mergedDF = DataFrame.merge([df1, df2, etc]);\r\n     * </pre>\r\n     */\r\n    static merge<MergedValueT = any, IndexT = any, ValueT = any>(dataFrames: Iterable<IDataFrame<IndexT, ValueT>>): IDataFrame<IndexT, MergedValueT> {\r\n\r\n        let resultIsCaseSensitive = false;\r\n\r\n        const rowMap = new Map<IndexT, any>();\r\n        for (const dataFrame of dataFrames) {\r\n            if (dataFrame.isCaseSensitive()) {\r\n                resultIsCaseSensitive = true;\r\n            }\r\n\r\n            for (const pair of dataFrame.toPairs()) {\r\n                const index = pair[0];\r\n                if (!rowMap.has(index)) {\r\n                    const clone = Object.assign({}, pair[1]);\r\n                    rowMap.set(index, clone);\r\n                }\r\n                else {\r\n                    rowMap.set(index, Object.assign(rowMap.get(index), pair[1]));\r\n                }\r\n            }\r\n        }\r\n\r\n        const allColumnNames = Array.from(dataFrames)\r\n            .map(dataFrame => dataFrame.getColumnNames())\r\n            .reduce((prev, next) => prev.concat(next), []);\r\n        const newColumnNames =  makeDistinct(allColumnNames);\r\n        const mergedPairs = Array.from(rowMap.keys()).map(index => [index, rowMap.get(index)]);\r\n\r\n        mergedPairs.sort((a, b) => { // Sort by index, ascending.\r\n            if (a[0] === b[0]) {\r\n                return 0;\r\n            }\r\n            else if (a[0] > b[0]) {\r\n                return 1;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        });\r\n\r\n        return new DataFrame<IndexT, MergedValueT>({\r\n            columnNames: newColumnNames,\r\n            pairs: mergedPairs as [IndexT, MergedValueT][],\r\n            caseSensitive: resultIsCaseSensitive,\r\n        });\r\n    }  \r\n\r\n    /**\r\n     * Merge one or more dataframes into this dataframe.\r\n     * Rows are merged by indexed. \r\n     * Same named columns in subsequent dataframes override columns in earlier dataframes.\r\n     * \r\n     * @param otherDataFrames... One or more dataframes to merge into this dataframe.\r\n     * \r\n     * @returns The merged data frame.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const mergedDF = df1.merge(df2);\r\n     * </pre>\r\n     * \r\n     * <pre>\r\n     * \r\n     * const mergedDF = df1.merge(df2, df3, etc);\r\n     * </pre>\r\n     */\r\n    merge<MergedValueT = ValueT>(...otherDataFrames: IDataFrame<IndexT, any>[]): IDataFrame<IndexT, MergedValueT> {\r\n        return DataFrame.merge<MergedValueT, IndexT, any>([this as IDataFrame<IndexT, ValueT>].concat(otherDataFrames));\r\n    }\r\n    \r\n    /**\r\n     * Add a series to the dataframe, but only if it doesn't already exist.\r\n     * \r\n     * @param columnNameOrSpec The name of the series to add or a {@link IColumnGenSpec} that specifies the columns to add.\r\n     * @param series If columnNameOrSpec is a string that specifies the name of the series to add, this specifies the actual {@link Series} to add or a selector that generates the series given the dataframe.\r\n     * \r\n     * @return Returns a new dataframe with the specified series added, if the series didn't already exist. Otherwise if the requested series already exists the same dataframe is returned.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const updatedDf = df.ensureSeries(\"ANewColumn\", new Series([1, 2, 3]));\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const updatedDf = df.ensureSeries(\"ANewColumn\", df => \r\n     *      df.getSeries(\"AnExistingSeries\").select(aTransformation)\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.ensureSeries({\r\n     *      ANewColumn: new Series([1, 2, 3]),\r\n     *      SomeOtherColumn: new Series([10, 20, 30])\r\n     * });\r\n     * <pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.ensureSeries({\r\n     *      ANewColumn: df => df.getSeries(\"SourceData\").select(aTransformation))\r\n     * });\r\n     * <pre>\r\n     */\r\n    ensureSeries<SeriesValueT> (columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, ValueT> {\r\n\r\n        if (!isObject(columnNameOrSpec)) {\r\n            if (!isString(columnNameOrSpec)) throw new Error(\"Expected 'columnNameOrSpec' parameter to 'DataFrame.ensureSeries' function to be a string that specifies the column to set or replace.\");\r\n            if (!isFunction(series as Object)) {\r\n                if (!isObject(series)) throw new Error(\"Expected 'series' parameter to 'DataFrame.ensureSeries' to be a Series object or a function that takes a dataframe and produces a Series.\");\r\n            }\r\n        }\r\n        else {\r\n            if (!isUndefined(series)) throw new Error(\"Expected 'series' parameter to 'DataFrame.ensureSeries' to not be set when 'columnNameOrSpec is an object.\");\r\n        }\r\n\r\n        if (isObject(columnNameOrSpec)) {\r\n            const columnSpec: IColumnGenSpec = <IColumnGenSpec> columnNameOrSpec;\r\n            const columnNames = Object.keys(columnNameOrSpec);\r\n            let workingDataFrame = <IDataFrame<IndexT,any>> this;\r\n            for (const columnName of columnNames) {\r\n                workingDataFrame = workingDataFrame.ensureSeries(columnName, columnSpec[columnName]);\r\n            }\r\n\r\n            return workingDataFrame;\r\n        }\r\n\r\n        const columnName: string = <string> columnNameOrSpec;\r\n        if (this.hasSeries(columnName)) {\r\n            return this; // Already have the series.\r\n        }\r\n        else {\r\n            return this.withSeries(columnName, series);\r\n        }\r\n    }    \r\n\r\n    /**\r\n     * Create a new dataframe with just a subset of columns.\r\n     *\r\n     * @param columnNames Array of column names to include in the new dataframe.\r\n     * \r\n     * @return Returns a dataframe with a subset of columns from the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const subsetDf = df.subset([\"ColumnA\", \"ColumnB\"]);\r\n     * </pre>\r\n     */\r\n    subset<NewValueT = ValueT> (columnNames: string[]): IDataFrame<IndexT, NewValueT> {\r\n        if (!isArray(columnNames)) throw new Error(\"Expected 'columnNames' parameter to 'DataFrame.subset' to be an array of column names to keep.\");\t\r\n\r\n        return new DataFrame<IndexT, NewValueT>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                columnNames: columnNames,\r\n                index: content.index,\r\n                values: new SelectIterable<ValueT, NewValueT>(content.values, (value: any) => {\r\n                    const output: any = {};\r\n                    for (const columnName of columnNames) {\r\n                        output[columnName] = value[columnName];\r\n                    }\r\n                    return output;\r\n                }),\r\n                pairs: new SelectIterable<[IndexT, ValueT], [IndexT, NewValueT]>(content.pairs, (pair: any) => {\r\n                    const output: any = {};\r\n                    const value = pair[1];\r\n                    for (const columnName of columnNames) {\r\n                        output[columnName] = value[columnName];\r\n                    }\r\n                    return [pair[0], output];\r\n                }),\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Create a new dataframe with the requested column or columns dropped.\r\n     *\r\n     * @param columnOrColumns Specifies the column name (a string) or columns (array of strings) to drop.\r\n     * \r\n     * @return Returns a new dataframe with a particular named column or columns removed.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const modifiedDf = df.dropSeries(\"SomeColumn\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const modifiedDf = df.dropSeries([\"ColumnA\", \"ColumnB\"]);\r\n     * </pre>\r\n     */\r\n    dropSeries<NewValueT = ValueT> (columnOrColumns: string | string[]): IDataFrame<IndexT, NewValueT> {\r\n\r\n        if (!isArray(columnOrColumns)) {\r\n            if (!isString(columnOrColumns)) throw new Error(\"'DataFrame.dropSeries' expected either a string or an array or strings.\");\r\n\r\n            columnOrColumns = [columnOrColumns]; // Convert to array for coding convenience.\r\n        }\r\n\r\n        return new DataFrame<IndexT, NewValueT>(() => {\r\n            const content = this.getContent();\r\n            const newColumnNames = [];\r\n            for (const columnName of content.columnNames) {\r\n                if (columnOrColumns.indexOf(columnName) === -1) {\r\n                    newColumnNames.push(columnName); // This column is not being dropped.\r\n                }\r\n            }\r\n\r\n            return {\r\n                columnNames: newColumnNames,\r\n                index: content.index,\r\n                values: new SelectIterable<ValueT, NewValueT>(content.values, value => {\r\n                    const clone: any = Object.assign({}, value);\r\n                    for (const droppedColumnName of columnOrColumns) {\r\n                        delete clone[droppedColumnName];\r\n                    }\r\n                    return clone;\r\n                }),\r\n                pairs: new SelectIterable<[IndexT, ValueT], [IndexT, NewValueT]>(content.pairs, pair => {\r\n                    const clone: any = Object.assign({}, pair[1]);\r\n                    for (const droppedColumnName of columnOrColumns) {\r\n                        delete clone[droppedColumnName];\r\n                    }\r\n                    return [pair[0], clone];\r\n                }),\r\n            };\r\n        });\r\n    }\r\n        \r\n    /**\r\n     * Create a new dataframe with columns reordered.\r\n     * New column names create new columns (with undefined values), omitting existing column names causes those columns to be dropped.\r\n     * \r\n     * @param columnNames Specifies the new order for columns.\r\n     * \r\n     * @return Returns a new dataframe with columns reordered according to the order of the array of column names that is passed in.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const reorderedDf = df.reorderSeries([\"FirstColumn\", \"SecondColumn\", \"etc\"]);\r\n     * </pre>\r\n     */\r\n    reorderSeries<NewValueT = ValueT> (columnNames: string[]): IDataFrame<IndexT, NewValueT> {\r\n\r\n        if (!isArray(columnNames)) throw new Error(\"Expected parameter 'columnNames' to 'DataFrame.reorderSeries' to be an array with column names.\");\r\n\r\n        for (const columnName of columnNames) {\r\n            if (!isString(columnName)) throw new Error(\"Expected parameter 'columnNames' to 'DataFrame.reorderSeries' to be an array with column names.\");\r\n        }\r\n\r\n        return new DataFrame<IndexT, NewValueT>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                columnNames: columnNames,\r\n                index: content.index,\r\n                values: new SelectIterable<ValueT, NewValueT>(content.values, (value: any) => {\r\n                    const output: any = {};\r\n                    for (const columnName of columnNames) {\r\n                        output[columnName] = value[columnName];\r\n                    }\r\n\r\n                    return <NewValueT> output;\r\n                }),\r\n                pairs:  new SelectIterable<[IndexT, ValueT], [IndexT, NewValueT]>(content.pairs, (pair: [IndexT, ValueT]) => {\r\n                    const value: any = <any> pair[1];\r\n                    const output: any = {};\r\n                    for (const columnName of columnNames) {\r\n                        output[columnName] = value[columnName];\r\n                    }\r\n\r\n                    return [pair[0], <NewValueT> output];\r\n                }),\r\n                caseSensitive: content.isCaseSensitive,\r\n            };\r\n        });\r\n    }   \r\n\r\n    /**\r\n     * Bring the column(s) with specified name(s) to the front of the column order, making it (or them) the first column(s) in the output dataframe.\r\n     *\r\n     * @param columnOrColumns Specifies the column or columns to bring to the front.\r\n     *\r\n     * @return Returns a new dataframe with 1 or more columns bought to the front of the column ordering.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const modifiedDf = df.bringToFront(\"NewFirstColumn\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const modifiedDf = df.bringToFront([\"NewFirstColumn\", \"NewSecondColumn\"]);\r\n     * </pre>\r\n     */\r\n    bringToFront (columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT> {\r\n\r\n        if (isArray(columnOrColumns)) {\r\n            for (const columnName of columnOrColumns) {\r\n                if (!isString(columnName)) {\r\n                    throw new Error(\"Expect 'columnOrColumns' parameter to 'DataFrame.bringToFront' function to specify a column or columns via a string or an array of strings.\");\t\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (!isString(columnOrColumns)) {\r\n                throw new Error(\"Expect 'columnOrColumns' parameter to 'DataFrame.bringToFront' function to specify a column or columns via a string or an array of strings.\");\r\n            }\r\n\r\n            columnOrColumns = [columnOrColumns]; // Convert to array for coding convenience.\r\n        }\r\n\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            const existingColumns = Array.from(content.columnNames);\r\n            const columnsToMove: string[] = [];\r\n            for (const columnToMove of columnOrColumns) {\r\n                if (existingColumns.indexOf(columnToMove) !== -1) {\r\n                    // The request column actually exists, so we will move it.\r\n                    columnsToMove.push(columnToMove);\r\n                }\r\n            }\r\n\r\n            const untouchedColumnNames: string[] = [];\r\n            for (const existingColumnName of existingColumns) {\r\n                if (columnOrColumns.indexOf(existingColumnName) === -1) {\r\n                    untouchedColumnNames.push(existingColumnName);\r\n                }\r\n            }\r\n            \r\n            return {\r\n                columnNames: columnsToMove.concat(untouchedColumnNames),\r\n                index: content.index,\r\n                values: content.values,\r\n                pairs: content.pairs,\r\n            };\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Bring the column(s) with specified name(s) to the back of the column order, making it (or them) the last column(s) in the output dataframe.\r\n     *\r\n     * @param columnOrColumns Specifies the column or columns to bring to the back.\r\n     *\r\n     * @return Returns a new dataframe with 1 or more columns bought to the back of the column ordering.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const modifiedDf = df.bringToBack(\"NewLastColumn\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const modifiedDf = df.bringToBack([\"NewSecondLastColumn, \"\"NewLastColumn\"]);\r\n     * </pre>\r\n     */\r\n    bringToBack (columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT> {\r\n\r\n        if (isArray(columnOrColumns)) {\r\n            for (const columnName of columnOrColumns) {\r\n                if (!isString(columnName)) {\r\n                    throw new Error(\"Expect 'columnOrColumns' parameter to 'DataFrame.bringToBack' function to specify a column or columns via a string or an array of strings.\");\t\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (!isString(columnOrColumns)) {\r\n                throw new Error(\"Expect 'columnOrColumns' parameter to 'DataFrame.bringToBack' function to specify a column or columns via a string or an array of strings.\");\r\n            }\r\n\r\n            columnOrColumns = [columnOrColumns]; // Convert to array for coding convenience.\r\n        }\r\n\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            const existingColumns = Array.from(content.columnNames);\r\n            const columnsToMove: string[] = [];\r\n            for (const columnToMove of columnOrColumns) {\r\n                if (existingColumns.indexOf(columnToMove) !== -1) {\r\n                    // The request column actually exists, so we will move it.\r\n                    columnsToMove.push(columnToMove);\r\n                }\r\n            }\r\n\r\n            const untouchedColumnNames: string[] = [];\r\n            for (const existingColumnName of existingColumns) {\r\n                if (columnOrColumns.indexOf(existingColumnName) === -1) {\r\n                    untouchedColumnNames.push(existingColumnName);\r\n                }\r\n            }\r\n            \r\n            return {\r\n                columnNames: untouchedColumnNames.concat(columnsToMove),\r\n                index: content.index,\r\n                values: content.values,\r\n                pairs: content.pairs,\r\n            };\r\n        })\r\n    }\r\n    \r\n    /**\r\n     * Create a new dataframe with 1 or more columns renamed.\r\n     *\r\n     * @param newColumnNames A column rename spec - a JavaScript hash that maps existing column names to new column names.\r\n     * \r\n     * @return Returns a new dataframe with specified columns renamed.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const renamedDf = df.renameSeries({ OldColumnName, NewColumnName });\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const renamedDf = df.renameSeries({ \r\n     *      Column1: ColumnA,\r\n     *      Column2: ColumnB\r\n     * });\r\n     * </pre>\r\n     */\r\n    renameSeries<NewValueT = ValueT> (newColumnNames: IColumnRenameSpec): IDataFrame<IndexT, NewValueT> {\r\n\r\n        if (!isObject(newColumnNames)) throw new Error(\"Expected parameter 'newColumnNames' to 'DataFrame.renameSeries' to be an array with column names.\");\r\n\r\n        const existingColumnsToRename = Object.keys(newColumnNames);\r\n        for (const existingColumnName of existingColumnsToRename) {\r\n            if (!isString(existingColumnName)) throw new Error(\"Expected existing column name '\" + existingColumnName + \"' of 'newColumnNames' parameter to 'DataFrame.renameSeries' to be a string.\");\r\n            if (!isString(newColumnNames[existingColumnName])) throw new Error(\"Expected new column name '\" + newColumnNames[existingColumnName] + \"' for existing column '\" + existingColumnName + \"' of 'newColumnNames' parameter to 'DataFrame.renameSeries' to be a string.\");\r\n        }\r\n\r\n        return new DataFrame<IndexT, NewValueT>(() => {\r\n            const content = this.getContent();\r\n            const renamedColumns: string[] = [];\r\n\r\n            for (const existingColumnName of content.columnNames) { // Convert the column rename spec to array of new column names.\r\n                const columnIndex = existingColumnsToRename.indexOf(existingColumnName);\r\n                if (columnIndex === -1) {\r\n                    renamedColumns.push(existingColumnName); // This column is not renamed.                    \r\n                }\r\n                else {\r\n                    renamedColumns.push(newColumnNames[existingColumnName]); // This column is renamed.\r\n                }\r\n            }\r\n    \r\n            //\r\n            // Remap each row of the data frame to the new column names.\r\n            //\r\n            function remapValue (value: any): any {\r\n                const clone = Object.assign({}, value);\r\n    \r\n                for (const existingColumName of existingColumnsToRename) {\r\n                    clone[newColumnNames[existingColumName]] = clone[existingColumName];\r\n                    delete clone[existingColumName];\r\n                }\r\n    \r\n                return clone;\r\n            }\r\n    \r\n            return {\r\n                columnNames: renamedColumns,\r\n                index: content.index,\r\n                values: new SelectIterable<ValueT, NewValueT>(content.values, remapValue),\r\n                pairs: new SelectIterable<[IndexT, ValueT], [IndexT, NewValueT]>(content.pairs, pair => {\r\n                    return [pair[0], remapValue(pair[1])];\r\n                }),\r\n            };\r\n        });\r\n    }\r\n    \r\n    /**\r\n    * Extract values from the dataframe as an array.\r\n    * This forces lazy evaluation to complete.\r\n    * \r\n    * @return Returns an array of the values contained within the dataframe. \r\n    * \r\n    * @example\r\n    * <pre>\r\n    * const values = df.toArray();\r\n    * </pre>\r\n    */\r\n    toArray (): any[] {\r\n        const values = [];\r\n        for (const value of this.getContent().values) {\r\n            if (value !== undefined && value !== null) {\r\n                values.push(value);\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n\r\n    /**\r\n     * Retreive the index and values pairs from the dataframe as an array.\r\n     * Each pair is [index, value].\r\n     * This forces lazy evaluation to complete.\r\n     * \r\n     * @return Returns an array of pairs that contains the dataframe content. Each pair is a two element array that contains an index and a value.  \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const pairs = df.toPairs();\r\n     * </pre>\r\n     */\r\n    toPairs (): ([IndexT, ValueT])[] {\r\n        const pairs = [];\r\n        for (const pair of this.getContent().pairs) {\r\n            if (pair[1] != undefined && pair[1] !== null) {\r\n                pairs.push(pair);\r\n            }\r\n        }\r\n        return pairs;\r\n    }\r\n\r\n    /**\r\n     * Convert the dataframe to a JavaScript object.\r\n     *\r\n     * @param keySelector Function that selects keys for the resulting object.\r\n     * @param valueSelector Function that selects values for the resulting object.\r\n     * \r\n     * @return Returns a JavaScript object generated from the dataframe by applying the key and value selector functions. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const someObject = df.toObject(\r\n     *      row => row.SomeColumn, // Specify the column to use for fields in the object.\r\n     *      row => row.SomeOtherColumn // Specify the column to use as the value for each field.\r\n     * );\r\n     * </pre>\r\n     */\r\n    toObject<KeyT = any, FieldT = any, OutT = any> (keySelector: (value: ValueT) => KeyT, valueSelector: (value: ValueT) => FieldT): OutT {\r\n\r\n        if (!isFunction(keySelector)) throw new Error(\"Expected 'keySelector' parameter to DataFrame.toObject to be a function.\");\r\n        if (!isFunction(valueSelector)) throw new Error(\"Expected 'valueSelector' parameter to DataFrame.toObject to be a function.\");\r\n\r\n        return toMap(this, keySelector, valueSelector);\r\n    }\r\n    \r\n    /**\r\n     * Bake the data frame to an array of rows were each rows is an array of values in column order.\r\n     * \r\n     * @return Returns an array of rows. Each row is an array of values in column order.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * const rows = df.toRows();\r\n     * </pre>\r\n     */\r\n    toRows (): any[][] {\r\n        const columnNames = this.getColumnNames();\r\n        const rows = [];\r\n        for (const value of this.getContent().values) {\r\n            const row = [];\r\n            for (let columnIndex = 0; columnIndex < columnNames.length; ++columnIndex) {\r\n                row.push((<any>value)[columnNames[columnIndex]]);\r\n            }\r\n\r\n            rows.push(row);\r\n        }\r\n        \r\n        return rows;\r\n    }\r\n\r\n    /**\r\n     * Transforms an input dataframe, generating a new dataframe.\r\n     * The transformer function is called for each element of the input and the collection of outputs creates the generated datafarme.\r\n     * \r\n     * `select` is an alias for {@link DataFrame.map}.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.map` but maps over a dataframe rather than an array.\r\n     *\r\n     * @param transformer A user-defined transformer function that transforms each element from the input to generate the output.\r\n     * \r\n     * @return Returns a new dataframe generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = {\r\n     *          // ... construct output from input ...\r\n     *      };\r\n     *\r\n     *      return output;\r\n     * }\r\n     *  \r\n     * const transformed = dataframe.select(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n    select<ToT> (transformer: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT> {\r\n        if (!isFunction(transformer)) throw new Error(\"Expected 'transformer' parameter to 'Series.select' to be a function.\");\r\n\r\n        return this.map<ToT>(transformer);\r\n    }\r\n\r\n    /**\r\n     * Transforms an input dataframe, generating a new dataframe.\r\n     * The transformer function is called for each element of the input and the collection of outputs creates the generated datafarme.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.map` but maps over a dataframe rather than an array.\r\n     *\r\n     * @param transformer A user-defined transformer function that transforms each element from the input to generate the output.\r\n     * \r\n     * @return Returns a new dataframe generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = {\r\n     *          // ... construct output from input ...\r\n     *      };\r\n     *\r\n     *      return output;\r\n     * }\r\n     *  \r\n     * const transformed = dataframe.map(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n     map<ToT> (transformer: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT> {\r\n        if (!isFunction(transformer)) throw new Error(\"Expected 'transformer' parameter to 'DataFrame.map' to be a function.\");\r\n\r\n        return new DataFrame(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                values: new SelectIterable<ValueT, ToT>(content.values, transformer),\r\n                index: content.index,    \r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Transforms and flattens an input dataframe, generating a new dataframe.\r\n     * The transformer function is called for each value in the input dataframe and produces an array that is then flattened into the generated dataframe.\r\n     * \r\n     * `selectMany` is an alias for {@link DataFrame.flatMap}.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.flatMap` but maps over a dataframe rather than an array.\r\n     * \r\n     * @param transformer A user-defined function that transforms each value into an array that is then flattened into the generated dataframe.\r\n     * \r\n     * @return Returns a new dataframe generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = [];\r\n     *      while (someCondition) {\r\n     *          // ... generate zero or more outputs from a single input ...\r\n     *          output.push(... some generated value ...);\r\n     *      }\r\n     *      return output;\r\n     * }\r\n     * \r\n     * const transformed = dataframe.selectMany(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n    selectMany<ToT> (transformer: SelectorWithIndexFn<ValueT, Iterable<ToT>>): IDataFrame<IndexT, ToT> {\r\n        if (!isFunction(transformer)) throw new Error(\"Expected 'transformer' parameter to 'DataFrame.selectMany' to be a function.\");\r\n\r\n        return this.flatMap<ToT>(transformer);\r\n    }\r\n\r\n    /**\r\n     * Transforms and flattens an input dataframe, generating a new dataframe.\r\n     * The transformer function is called for each value in the input dataframe and produces an array that is then flattened into the generated dataframe.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.flatMap` but maps over a dataframe rather than an array.\r\n     * \r\n     * @param transformer A user-defined function that transforms each value into an array that is then flattened into the generated dataframe.\r\n     * \r\n     * @return Returns a new dataframe generated by calling the transformer function over each element of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function transformer (input) {\r\n     *      const output = [];\r\n     *      while (someCondition) {\r\n     *          // ... generate zero or more outputs from a single input ...\r\n     *          output.push(... some generated value ...);\r\n     *      }\r\n     *      return output;\r\n     * }\r\n     * \r\n     * const transformed = dataframe.flatMap(transformer);\r\n     * console.log(transformed.toString());\r\n     * </pre>\r\n     */\r\n    flatMap<ToT> (transformer: SelectorWithIndexFn<ValueT, Iterable<ToT>>): IDataFrame<IndexT, ToT> {\r\n        if (!isFunction(transformer)) throw new Error(\"Expected 'transformer' parameter to 'DataFrame.flatMap' to be a function.\");\r\n\r\n        return new DataFrame(() => ({\r\n            pairs: new SelectManyIterable(\r\n                this.getContent().pairs, \r\n                (pair: [IndexT, ValueT], index: number): Iterable<[IndexT, ToT]> => {\r\n                    const outputPairs: [IndexT, ToT][] = [];\r\n                    for (const transformed of transformer(pair[1], index)) {\r\n                        outputPairs.push([\r\n                            pair[0],\r\n                            transformed\r\n                        ]);\r\n                    }\r\n                    return outputPairs;\r\n                }\r\n            )\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Transform one or more columns. \r\n     * \r\n     * This is equivalent to extracting a {@link Series} with {@link getSeries}, then transforming it with {@link Series.select},\r\n     * and finally plugging it back in as the same column using {@link withSeries}.\r\n     *\r\n     * @param columnSelectors Object with field names for each column to be transformed. Each field specifies a selector function that transforms that column.\r\n     * \r\n     * @return Returns a new dataframe with 1 or more columns transformed.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.transformSeries({ \r\n     *      AColumnToTransform: columnValue => transformRow(columnValue) \r\n     * });\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const modifiedDf = df.transformSeries({ \r\n     *      ColumnA: columnValue => transformColumnA(columnValue),\r\n     *      ColumnB: columnValue => transformColumnB(columnValue)\r\n     * });\r\n     * </pre>\r\n     */\r\n    transformSeries<NewValueT = ValueT> (columnSelectors: IColumnTransformSpec): IDataFrame<IndexT, NewValueT> {\r\n\r\n        if (!isObject(columnSelectors)) throw new Error(\"Expected 'columnSelectors' parameter of 'DataFrame.transformSeries' function to be an object. Field names should specify columns to transform. Field values should be selector functions that specify the transformation for each column.\");\r\n\r\n        let working: IDataFrame<IndexT, any> = this;\r\n\r\n        for (const columnName of Object.keys(columnSelectors)) {\r\n            if (working.hasSeries(columnName)) {\r\n                working = working.withSeries(\r\n                    columnName, \r\n                    working.getSeries(columnName)\r\n                        .select(columnSelectors[columnName])\r\n                );\r\n            }\r\n        }\r\n\r\n        return working;\r\n    }\r\n\r\n    /** \r\n     * Generate new columns based on existing rows.\r\n     * \r\n     * This is equivalent to calling {@link select} to transform the original dataframe to a new dataframe with different column,\r\n     * then using {@link withSeries} to merge each the of both the new and original dataframes.\r\n     *\r\n     * @param generator Generator function that transforms each row to produce 1 or more new columns.\r\n     * Or use a column spec that has fields for each column, the fields specify a generate function that produces the value for each new column.\r\n     * \r\n     * @return Returns a new dataframe with 1 or more new columns.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function produceNewColumns (inputRow) {\r\n     *      const newColumns = {\r\n     *          // ... specify new columns and their values based on the input row ...\r\n     *      };\r\n     * \r\n     *      return newColumns;\r\n     * };\r\n     * \r\n     * const dfWithNewSeries = df.generateSeries(row => produceNewColumns(row));\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithNewSeries = df.generateSeries({ \r\n     *      NewColumnA: row => produceNewColumnA(row),\r\n     *      NewColumnB: row => produceNewColumnB(row),\r\n     * })\r\n     * </pre>\r\n     */\r\n    generateSeries<NewValueT = ValueT>(generator: SelectorWithIndexFn<any, any> | IColumnTransformSpec): IDataFrame<IndexT, NewValueT> {\r\n\r\n        if (!isObject(generator)) {\r\n            if (!isFunction(generator)) {\r\n                throw new Error(\"Expected 'generator' parameter to 'DataFrame.generateSeries' function to be a function or an object.\");\r\n            }\r\n\r\n            const selector = generator as SelectorWithIndexFn<any, any>;\r\n            const newColumns = this.select(selector) // Build a new dataframe.\r\n                .bake(); //TODO: Bake should be needed here, but it causes problems if not.\r\n            const newColumnNames = newColumns.getColumnNames();\r\n\r\n            let working: IDataFrame<IndexT, any> = this;\r\n\r\n            //TODO: There must be a cheaper implementation!\r\n            for (const newColumnName of newColumnNames) {\r\n                working = working.withSeries(newColumnName, newColumns.getSeries(newColumnName));\r\n            }\r\n\r\n            return working;\r\n        }\r\n        else {\r\n            const columnTransformSpec = generator as IColumnTransformSpec;\r\n            const newColumnNames = Object.keys(columnTransformSpec);\r\n            \r\n            let working: IDataFrame<IndexT, any> = this;\r\n\r\n            for (const newColumnName of newColumnNames) {\r\n                working = working.withSeries(newColumnName, working.select(columnTransformSpec[newColumnName]).deflate());\r\n            }\r\n\r\n            return working;\r\n        }\r\n    }    \r\n\r\n    /** \r\n     * Converts (deflates) a dataframe to a {@link Series}.\r\n     *\r\n     * @param selector Optional selector function that transforms each row to produce the series.\r\n     *\r\n     * @return Returns a series that was created from the deflated from  the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = df.deflate(); // Deflate to a series of object.\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const series = df.deflate(row => row.SomeColumn); // Extract a particular column.\r\n     * </pre>\r\n     */\r\n    deflate<ToT = ValueT> (selector?: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT> {\r\n\r\n        if (selector) {\r\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.deflate' function to be a selector function.\");\r\n        }\r\n\r\n        return new Series<IndexT, ToT>(() => {\r\n            const content = this.getContent();\r\n            if (selector) {\r\n                return {\r\n                    index: content.index,\r\n                    values: new SelectIterable<ValueT, ToT>(content.values, selector),\r\n                    pairs: new SelectIterable<[IndexT, ValueT], [IndexT, ToT]>(content.pairs, (pair, index) => {\r\n                        return [\r\n                            pair[0],\r\n                            selector(pair[1], index)\r\n                        ];\r\n                    }),\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    index: content.index,\r\n                    values: content.values as any as Iterable<ToT>,\r\n                    pairs: content.pairs as any as Iterable<[IndexT, ToT]>,\r\n                };\r\n            }\r\n        });\r\n    }\r\n\r\n    /** \r\n     * Inflate a named {@link Series} in the dataframe to 1 or more new series in the new dataframe.\r\n     * \r\n     * This is the equivalent of extracting the series using {@link getSeries}, transforming them with {@link Series.select}\r\n     * and then running {@link Series.inflate} to create a new dataframe, then merging each column of the new dataframe\r\n     *  into the original dataframe using {@link withSeries}.\r\n     *\r\n     * @param columnName Name of the series to inflate.\r\n     * @param selector Optional selector function that transforms each value in the column to new columns. If not specified it is expected that each value in the column is an object whose fields define the new column names.\r\n     * \r\n     * @return Returns a new dataframe with a column inflated to 1 or more new columns.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function newColumnGenerator (row) {\r\n     *      const newColumns = {\r\n     *          // ... create 1 field per new column ...\r\n     *      };\r\n     * \r\n     *      return row;\r\n     * }\r\n     * \r\n     * const dfWithNewSeries = df.inflateSeries(\"SomeColumn\", newColumnGenerator);\r\n     * </pre>\r\n     */\r\n    inflateSeries<NewValueT = ValueT>(columnName: string, selector?: SelectorWithIndexFn<IndexT, any>): IDataFrame<IndexT, ValueT> {\r\n\r\n        if (!isString(columnName)) throw new Error(\"Expected 'columnName' parameter to 'DataFrame.inflateSeries' to be a string that is the name of the column to inflate.\");\r\n\r\n        if (selector) {\r\n            if (!isFunction(selector)) throw new Error(\"Expected optional 'selector' parameter to 'DataFrame.inflateSeries' to be a selector function, if it is specified.\");\r\n        }\r\n\r\n        return this.zip(\r\n            this.getSeries(columnName).inflate(selector),\r\n            (row1, row2) => Object.assign({}, row1, row2) //todo: this be should zip's default operation.\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Partition a dataframe into a {@link Series} of *data windows*. \r\n     * Each value in the new series is a rolling chunk of data from the original dataframe.\r\n     *\r\n     * @param period The number of data rows to include in each data window.\r\n     * \r\n     * @return Returns a new series, each value of which is a chunk of the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const windows = df.window(2); // Get values in pairs.\r\n     * const pctIncrease = windows.select(pair => (pair.last() - pair.first()) / pair.first());\r\n     * console.log(pctIncrease.toString());\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesDf = ... // Daily sales data.\r\n     * const weeklySales = salesDf.window(7); // Partition up into weekly data sets.\r\n     * console.log(weeklySales.toString());\r\n     * </pre>\r\n     */\r\n    window (period: number): ISeries<number, IDataFrame<IndexT, ValueT>> {\r\n\r\n        if (!isNumber(period)) throw new Error(\"Expected 'period' parameter to 'DataFrame.window' to be a number.\");\r\n\r\n        return new Series<number, IDataFrame<IndexT, ValueT>>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                values: new DataFrameWindowIterable<IndexT, ValueT>(content.columnNames, content.pairs, period)\r\n            };            \r\n        });\r\n    }\r\n\r\n    /** \r\n     * Partition a dataframe into a {@link Series} of *rolling data windows*. \r\n     * Each value in the new series is a rolling chunk of data from the original dataframe.\r\n     *\r\n     * @param period The number of data rows to include in each data window.\r\n     * \r\n     * @return Returns a new series, each value of which is a rolling chunk of the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesDf = ... // Daily sales data.\r\n     * const rollingWeeklySales = salesDf.rollingWindow(7); // Get rolling window over weekly sales data.\r\n     * console.log(rollingWeeklySales.toString());\r\n     * </pre>\r\n     */\r\n    rollingWindow (period: number): ISeries<number, IDataFrame<IndexT, ValueT>> {\r\n\r\n        if (!isNumber(period)) throw new Error(\"Expected 'period' parameter to 'DataFrame.rollingWindow' to be a number.\");\r\n\r\n        return new Series<number, IDataFrame<IndexT, ValueT>>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                values: new DataFrameRollingWindowIterable<IndexT, ValueT>(content.columnNames, content.pairs, period)\r\n            };            \r\n        });\r\n    }\r\n\r\n    /**\r\n     * Partition a dataframe into a {@link Series} of variable-length *data windows* \r\n     * where the divisions between the data chunks are\r\n     * defined by a user-provided *comparer* function.\r\n     * \r\n     * @param comparer Function that compares two adjacent data rows and returns true if they should be in the same window.\r\n     * \r\n     * @return Returns a new series, each value of which is a chunk of data from the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * function rowComparer (rowA, rowB) {\r\n     *      if (... rowA should be in the same data window as rowB ...) {\r\n     *          return true;\r\n     *      }\r\n     *      else {\r\n     *          return false;\r\n     *      }\r\n     * };\r\n     * \r\n     * const variableWindows = df.variableWindow(rowComparer);\r\n     */\r\n    variableWindow (comparer: ComparerFn<ValueT, ValueT>): ISeries<number, IDataFrame<IndexT, ValueT>> {\r\n        \r\n        if (!isFunction(comparer)) throw new Error(\"Expected 'comparer' parameter to 'DataFrame.variableWindow' to be a function.\")\r\n\r\n        return new Series<number, IDataFrame<IndexT, ValueT>>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                values: new DataFrameVariableWindowIterable<IndexT, ValueT>(content.columnNames, content.pairs, comparer)\r\n            };            \r\n        });\r\n    }\r\n\r\n    /**\r\n     * Eliminates adjacent duplicate rows.\r\n     * \r\n     * For each group of adjacent rows that are equivalent only returns the last index/row for the group, \r\n     * thus adjacent equivalent rows are collapsed down to the last row.\r\n     *\r\n     * @param selector Optional selector function to determine the value used to compare for equivalence.\r\n     * \r\n     * @return Returns a new dataframe with groups of adjacent duplicate rows collapsed to a single row per group.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithDuplicateRowsRemoved = df.sequentialDistinct(row => row.ColumnA);\r\n     * </pre>\r\n     */\r\n    sequentialDistinct<ToT = ValueT> (selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT> {\r\n        \r\n        if (selector) {\r\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.sequentialDistinct' to be a selector function that determines the value to compare for duplicates.\")\r\n        }\r\n        else {\r\n            selector = (value: ValueT): ToT => <ToT> <any> value;\r\n        }\r\n\r\n        return this.variableWindow((a, b) => selector!(a) === selector!(b))\r\n            .select((window): [IndexT, ValueT] => {\r\n                return [window.getIndex().first(), window.first()];\r\n            })\r\n            .withIndex(pair => pair[0])\r\n            .inflate(pair => pair[1]); //TODO: Should this be select?\r\n    }\r\n\r\n    /**\r\n     * Aggregate the rows in the dataframe to a single result.\r\n     *\r\n     * `aggregate` is similar to {@link DataFrame.reduce}  but the parameters are reversed. \r\n     * Please use {@link DataFrame.reduce} in preference to `aggregate`.\r\n\r\n     * @param seed Optional seed value for producing the aggregation.\r\n     * @param selector Function that takes the seed and then each row in the dataframe and produces the aggregated value.\r\n     * \r\n     * @return Returns a new value that has been aggregated from the dataframe using the 'selector' function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dailySalesDf = ... daily sales figures for the past month ...\r\n     * const totalSalesForthisMonth = dailySalesDf.aggregate(\r\n     *      0, // Seed - the starting value.\r\n     *      (accumulator, row) => accumulator + row.SalesAmount // Aggregation function.\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const totalSalesAllTime = 500; // We'll seed the aggregation with this value.\r\n     * const dailySalesDf = ... daily sales figures for the past month ...\r\n     * const updatedTotalSalesAllTime = dailySalesDf.aggregate(\r\n     *      totalSalesAllTime, \r\n     *      (accumulator, row) => accumulator + row.SalesAmount\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * var salesDataSummary = salesDataDf.aggregate({\r\n     *      TotalSales: df => df.count(),\r\n     *      AveragePrice: df => df.deflate(row => row.Price).average(),\r\n     *      TotalRevenue: df => df.deflate(row => row.Revenue).sum(), \r\n     * });\r\n     * </pre>\r\n    */\r\n    aggregate<ToT = ValueT> (seedOrSelector: AggregateFn<ValueT, ToT> | ToT | IColumnAggregateSpec, selector?: AggregateFn<ValueT, ToT>): ToT {\r\n\r\n        if (isFunction(seedOrSelector) && !selector) {\r\n            return this.skip(1).aggregate(<ToT> <any> this.first(), seedOrSelector);\r\n        }\r\n        else if (selector) {\r\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to aggregate to be a function.\");\r\n\r\n            let accum = <ToT> seedOrSelector;\r\n\r\n            for (const value of this) {\r\n                accum = selector!(accum, value);                \r\n            }\r\n\r\n            return accum;\r\n        }\r\n        else {\r\n            //\r\n            //TODO:\r\n            // This approach is fairly limited because I can't provide a seed.\r\n            // Consider removing this and replacing it with a 'summarize' function.\r\n            //\r\n            if (!isObject(seedOrSelector)) throw new Error(\"Expected 'seed' parameter to aggregate to be an object.\");\r\n\r\n            const columnAggregateSpec = seedOrSelector as IColumnAggregateSpec;\r\n            const columnNames = Object.keys(columnAggregateSpec);\r\n            const aggregatedColumns = columnNames.map(columnName => {\r\n                var columnSelector = columnAggregateSpec[columnName];\r\n                if (!isFunction(columnSelector)) throw new Error(\"Expected column/selector pairs in 'seed' parameter to aggregate.\");\r\n                return [columnName, this.getSeries(columnName).aggregate(columnSelector)];\r\n            });\r\n\r\n            return toMap(aggregatedColumns, pair => pair[0], pair => pair[1]);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Reduces the values in the dataframe to a single result.\r\n     *\r\n     * This is the same concept as the JavaScript function `Array.reduce` but reduces a dataframe rather than an array.\r\n\r\n     * @param reducer Function that takes the seed and then each value in the dataframe and produces the reduced value.\r\n     * @param seed Optional initial value, if not specifed the first value in the dataframe is used as the initial value.\r\n     * \r\n     * @return Returns a value that has been reduced from the input dataframe by passing each element through the reducer function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dailyRecords = ... daily records for the past month ...\r\n     * const totalSales = dailyRecords.reduce(\r\n     *      (accumulator, row) => accumulator + row.salesAmount, // Reducer function.\r\n     *      0  // Seed value, the starting value.\r\n     * );\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const previousSales = 500; // We'll seed the reduction with this value.\r\n     * const dailyRecords = ... daily records for the past month ...\r\n     * const updatedSales = dailyRecords.reduce(\r\n     *      (accumulator, row) => accumulator + row.salesAmount,\r\n     *      previousSales\r\n     * );\r\n     * </pre>\r\n     */\r\n    reduce<ToT = ValueT> (reducer: AggregateFn<ValueT, ToT>, seed?: ToT): ToT {\r\n        if (!isFunction(reducer)) throw new Error(\"Expected 'reducer' parameter to `DataFrame.reduce` to be a function.\");\r\n\r\n        let accum = <ToT> seed;\r\n        let dataframe: IDataFrame<any, ValueT> = this;\r\n        if (accum === undefined) {\r\n            if (dataframe.any()) {\r\n                accum = dataframe.first() as any as ToT;\r\n                dataframe = dataframe.skip(1);\r\n            }\r\n        }\r\n\r\n        for (const value of dataframe) {\r\n            accum = reducer(accum, value);\r\n        }\r\n\r\n        return accum;\r\n    }\r\n\r\n    /**\r\n     * Skip a number of rows in the dataframe.\r\n     *\r\n     * @param numValues Number of rows to skip.\r\n     * \r\n     * @return Returns a new dataframe with the specified number of rows skipped. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithRowsSkipped = df.skip(10); // Skip 10 rows in the original dataframe.\r\n     * </pre>\r\n     */\r\n    skip (numValues: number): IDataFrame<IndexT, ValueT> {\r\n        if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'DataFrame.skip' to be a number.\");\r\n\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                columnNames: content.columnNames,\r\n                values: new SkipIterable(content.values, numValues),\r\n                index: new SkipIterable(content.index, numValues),\r\n                pairs: new SkipIterable(content.pairs, numValues),\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Skips rows in the dataframe while a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Returns true/truthy to continue to skip rows in the original dataframe.\r\n     * \r\n     * @return Returns a new dataframe with all initial sequential rows removed while the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithRowsSkipped = df.skipWhile(row => row.CustomerName === \"Fred\"); // Skip initial customers named Fred.\r\n     * </pre>\r\n     */\r\n    skipWhile (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT> {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.skipWhile' function to be a predicate function that returns true/false.\");\r\n\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                columnNames: content.columnNames,\r\n                values: new SkipWhileIterable(content.values, predicate),\r\n                pairs: new SkipWhileIterable(content.pairs, pair => predicate(pair[1])),\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Skips rows in the dataframe untils a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Return true/truthy to stop skipping rows in the original dataframe.\r\n     * \r\n     * @return Returns a new dataframe with all initial sequential rows removed until the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithRowsSkipped = df.skipUntil(row => row.CustomerName === \"Fred\"); // Skip initial customers until we find Fred.\r\n     * </pre>\r\n     */\r\n    skipUntil (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT> {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.skipUntil' function to be a predicate function that returns true/false.\");\r\n\r\n        return this.skipWhile(value => !predicate(value)); \r\n    }\r\n\r\n    /**\r\n     * Take a number of rows from the dataframe.\r\n     *\r\n     * @param numValues Number of rows to take.\r\n     * \r\n     * @return Returns a new dataframe with only the specified number of rows taken from the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithRowsTaken = df.take(15); // Take only the first 15 rows from the original dataframe.\r\n     * </pre>\r\n     */\r\n    take (numRows: number): IDataFrame<IndexT, ValueT> {\r\n        if (!isNumber(numRows)) throw new Error(\"Expected 'numRows' parameter to 'DataFrame.take' function to be a number.\");\r\n\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                columnNames: content.columnNames,\r\n                index: new TakeIterable(content.index, numRows),\r\n                values: new TakeIterable(content.values, numRows),\r\n                pairs: new TakeIterable(content.pairs, numRows)\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Takes rows from the dataframe while a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Returns true/truthy to continue to take rows from the original dataframe.\r\n     * \r\n     * @return Returns a new dataframe with only the initial sequential rows that were taken while the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithRowsTaken = df.takeWhile(row => row.CustomerName === \"Fred\"); // Take only initial customers named Fred.\r\n     * </pre>\r\n     */\r\n    takeWhile (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT> {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.takeWhile' function to be a predicate function that returns true/false.\");\r\n\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                columnNames: content.columnNames,\r\n                values: new TakeWhileIterable(content.values, predicate),\r\n                pairs: new TakeWhileIterable(content.pairs, pair => predicate(pair[1]))\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Takes rows from the dataframe untils a condition evaluates to true or truthy.\r\n     *\r\n     * @param predicate Return true/truthy to stop taking rows in the original dataframe.\r\n     * \r\n     * @return Returns a new dataframe with only the initial sequential rows taken until the predicate returned true/truthy.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfWithRowsTaken = df.takeUntil(row => row.CustomerName === \"Fred\"); // Take all initial customers until we find Fred.\r\n     * </pre>\r\n     */\r\n    takeUntil (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT> {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.takeUntil' function to be a predicate function that returns true/false.\");\r\n\r\n        return this.takeWhile(value => !predicate(value));\r\n    }\r\n\r\n    /**\r\n     * Count the number of rows in the dataframe\r\n     *\r\n     * @return Returns the count of all rows.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const numRows = df.count();\r\n     * </pre>\r\n     */\r\n    count (): number {\r\n\r\n        let total = 0;\r\n        for (const value of this.getContent().values) {\r\n            ++total;\r\n        }\r\n        return total;\r\n    }\r\n\r\n    /**\r\n     * Get the first row of the dataframe.\r\n     *\r\n     * @return Returns the first row of the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const firstRow = df.first();\r\n     * </pre>\r\n     */\r\n    first (): ValueT {\r\n\r\n        for (const value of this) {\r\n            return value; // Only need the first value.\r\n        }\r\n\r\n        throw new Error(\"DataFrame.first: No values in DataFrame.\");\r\n    }\r\n\r\n    /**\r\n     * Get the last row of the dataframe.\r\n     *\r\n     * @return Returns the last row of the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const lastRow = df.last();\r\n     * </pre>\r\n     */\r\n    last (): ValueT {\r\n\r\n        let lastValue = null;\r\n\r\n        for (const value of this) {\r\n            lastValue = value; // Throw away all values until we get to the last one.\r\n        }\r\n\r\n        if (lastValue === null) {\r\n            throw new Error(\"DataFrame.last: No values in DataFrame.\");\r\n        }\r\n\r\n        return lastValue;\r\n    }    \r\n    \r\n    /**\r\n     * Get the row, if there is one, with the specified index.\r\n     *\r\n     * @param index Index to for which to retreive the row.\r\n     *\r\n     * @return Returns the row from the specified index in the dataframe or undefined if there is no such index in the present in the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const row = df.at(5); // Get the row at index 5 (with a default 0-based index).\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const date = ... some date ...\r\n     * // Retreive the row with specified date from a time-series dataframe (assuming date indexed has been applied).\r\n     * const row = df.at(date); \r\n     * </pre>\r\n     */\r\n    at (index: IndexT): ValueT | undefined {\r\n\r\n        if (this.none()) {\r\n            return undefined;\r\n        }\r\n\r\n        return this.getRowByIndex(index);\r\n    }\r\n    \r\n    /** \r\n     * Get X rows from the start of the dataframe.\r\n     * Pass in a negative value to get all rows at the head except for X rows at the tail.\r\n     *\r\n     * @param numValues Number of rows to take.\r\n     * \r\n     * @return Returns a new dataframe that has only the specified number of rows taken from the start of the original dataframe.  \r\n     * \r\n     * @examples\r\n     * <pre>\r\n     * \r\n     * const sample = df.head(10); // Take a sample of 10 rows from the start of the dataframe.\r\n     * </pre>\r\n     */\r\n    head (numValues: number): IDataFrame<IndexT, ValueT> {\r\n\r\n        if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'DataFrame.head' function to be a number.\");\r\n\r\n        if (numValues === 0) {\r\n            return new DataFrame<IndexT, ValueT>(); // Empty dataframe.\r\n        }\r\n\r\n        const toTake = numValues < 0 ? this.count() - Math.abs(numValues) : numValues;\r\n        return this.take(toTake);\r\n    }\r\n\r\n    /** \r\n     * Get X rows from the end of the dataframe.\r\n     * Pass in a negative value to get all rows at the tail except X rows at the head.\r\n     *\r\n     * @param numValues Number of rows to take.\r\n     * \r\n     * @return Returns a new dataframe that has only the specified number of rows taken from the end of the original dataframe.  \r\n     * \r\n     * @examples\r\n     * <pre>\r\n     * \r\n     * const sample = df.tail(12); // Take a sample of 12 rows from the end of the dataframe.\r\n     * </pre>\r\n     */\r\n    tail (numValues: number): IDataFrame<IndexT, ValueT> {\r\n\r\n        if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'DataFrame.tail' function to be a number.\");\r\n\r\n        if (numValues === 0) {\r\n            return new DataFrame<IndexT, ValueT>(); // Empty dataframe.\r\n        }\r\n\r\n        const toSkip = numValues > 0 ? this.count() - numValues : Math.abs(numValues);\r\n        return this.skip(toSkip);\r\n    }\r\n\r\n    /**\r\n     * Filter the dataframe through a user-defined predicate function.\r\n     * \r\n     * `where` is an alias for {@link DataFrame.filter}.\r\n     *\r\n     * This is the same concept as the JavaScript function `Array.filter` but filters a dataframe rather than an array.\r\n     * \r\n     * @param predicate Predicate function to filter values from the dataframe. Returns true/truthy to keep elements, or false/falsy to omit elements.\r\n     * \r\n     * @return Returns a new dataframe containing only the values from the original dataframe that matched the predicate. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Filter so we only have sales figures greater than 100.\r\n     * const filtered = dataframe.where(row => row.salesFigure > 100); \r\n     * console.log(filtered.toArray());\r\n     * </pre>\r\n     */\r\n     where (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT> {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.where' to be a function.\");\r\n\r\n        return this.filter(predicate);\r\n    }\r\n\r\n    /**\r\n     * Filter the dataframe through a user-defined predicate function.\r\n     * \r\n     * This is the same concept as the JavaScript function `Array.filter` but filters a dataframe rather than an array.\r\n     *\r\n     * @param predicate Predicate function to filter values from the dataframe. Returns true/truthy to keep elements, or false/falsy to omit elements.\r\n     * \r\n     * @return Returns a new dataframe containing only the values from the original dataframe that matched the predicate. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Filter so we only have sales figures greater than 100.\r\n     * const filtered = dataframe.filter(row => row.salesFigure > 100); \r\n     * console.log(filtered.toArray());\r\n     * </pre>\r\n     */\r\n    filter (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT> {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.filter' to be a function.\");\r\n\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                columnNames: content.columnNames,\r\n                values: new WhereIterable(content.values, predicate),\r\n                pairs: new WhereIterable(content.pairs, pair => predicate(pair[1]))\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Invoke a callback function for each row in the dataframe.\r\n     *\r\n     * @param callback The calback function to invoke for each row.\r\n     * \r\n     * @return Returns the original dataframe with no modifications.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * df.forEach(row => {\r\n     *      // ... do something with the row ...\r\n     * });\r\n     * </pre>\r\n     */\r\n    forEach (callback: CallbackFn<ValueT>): IDataFrame<IndexT, ValueT> {\r\n        if (!isFunction(callback)) throw new Error(\"Expected 'callback' parameter to 'DataFrame.forEach' to be a function.\");\r\n\r\n        let index = 0;\r\n        for (const value of this) {\r\n            callback(value, index++);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Evaluates a predicate function for every row in the dataframe to determine \r\n     * if some condition is true/truthy for **all** rows in the dataframe.\r\n     * \r\n     * @param predicate Predicate function that receives each row. It should returns true/truthy for a match, otherwise false/falsy.\r\n     *\r\n     * @return Returns true if the predicate has returned true or truthy for every row in the dataframe, otherwise returns false. Returns false for an empty dataframe. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const everyoneIsNamedFred = df.all(row => row.CustomerName === \"Fred\"); // Check if all customers are named Fred.\r\n     * </pre>\r\n     */\r\n    all (predicate: PredicateFn<ValueT>): boolean {\r\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.all' to be a function.\")\r\n\r\n        let count = 0;\r\n\r\n        for (const value of this) {\r\n            if (!predicate(value)) {\r\n                return false;\r\n            }\r\n\r\n            ++count;\r\n        }\r\n\r\n        return count > 0;\r\n    }\r\n\r\n    /**\r\n     * Evaluates a predicate function for every row in the dataframe to determine \r\n     * if some condition is true/truthy for **any** of rows in the dataframe.\r\n     * \r\n     * If no predicate is specified then it simply checks if the dataframe contains more than zero rows.\r\n     *\r\n     * @param predicate Optional predicate function that receives each row. It should return true/truthy for a match, otherwise false/falsy.\r\n     *\r\n     * @return Returns true if the predicate has returned truthy for any row in the dataframe, otherwise returns false. \r\n     * If no predicate is passed it returns true if the dataframe contains any rows at all. \r\n     * Returns false for an empty dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const anyFreds = df.any(row => row.CustomerName === \"Fred\"); // Do we have any customers named Fred?\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const anyCustomers = df.any(); // Do we have any customers at all?\r\n     * </pre>\r\n     */\r\n    any (predicate?: PredicateFn<ValueT>): boolean {\r\n        if (predicate) {\r\n            if (!isFunction(predicate)) throw new Error(\"Expected optional 'predicate' parameter to 'DataFrame.any' to be a function.\")\r\n        }\r\n\r\n        if (predicate) {\r\n            // Use the predicate to check each value.\r\n            for (const value of this) {\r\n                if (predicate(value)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // Just check if there is at least one item.\r\n            const iterator = this[Symbol.iterator]()\r\n            return !iterator.next().done;\r\n        }\r\n\r\n        return false; // Nothing passed.\r\n    }\r\n\r\n    /**\r\n     * Evaluates a predicate function for every row in the dataframe to determine \r\n     * if some condition is true/truthy for **none** of rows in the dataframe.\r\n     * \r\n     * If no predicate is specified then it simply checks if the dataframe contains zero rows.\r\n     *\r\n     * @param predicate Optional predicate function that receives each row. It should return true/truthy for a match, otherwise false/falsy.\r\n     *\r\n     * @return Returns true if the predicate has returned truthy for zero rows in the dataframe, otherwise returns false. Returns false for an empty dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const noFreds = df.none(row => row.CustomerName === \"Fred\"); // Do we have zero customers named Fred?\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const noCustomers = df.none(); // Do we have zero customers?\r\n     * </pre>\r\n     */\r\n    none (predicate?: PredicateFn<ValueT>): boolean {\r\n\r\n        if (predicate) {\r\n            if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.none' to be a function.\")\r\n        }\r\n\r\n        if (predicate) {\r\n            // Use the predicate to check each value.\r\n            for (const value of this) {\r\n                if (predicate(value)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // Just check if empty.\r\n            const iterator = this[Symbol.iterator]()\r\n            return iterator.next().done || false;\r\n        }\r\n\r\n        return true; // Nothing failed the predicate.\r\n    }\r\n\r\n    //TODO: Improve this example (and subsequent examples, they look like series setup rather than dataframe)..\r\n    /**\r\n     * Gets a new dataframe containing all rows starting at or after the specified index value.\r\n     * \r\n     * @param indexValue The index value at which to start the new dataframe.\r\n     * \r\n     * @return Returns a new dataframe containing all rows starting at or after the specified index value. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = new DataFrame({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const lastHalf = df.startAt(2);\r\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n     * \r\n     * // Get all rows starting at (or after) a particular date.\r\n     * const result = timeSeriesDf.startAt(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    startAt (indexValue: IndexT): IDataFrame<IndexT, ValueT> {\r\n\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            const lessThan = this.getIndex().getLessThan();\r\n            return {                \r\n                columnNames: content.columnNames,\r\n                index: new SkipWhileIterable(content.index, index => lessThan(index, indexValue)),\r\n                pairs: new SkipWhileIterable(content.pairs, pair => lessThan(pair[0], indexValue)),\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets a new dataframe containing all rows up until and including the specified index value (inclusive).\r\n     * \r\n     * @param indexValue The index value at which to end the new dataframe.\r\n     * \r\n     * @return Returns a new dataframe containing all rows up until and including the specified index value.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = new DataFrame({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const firstHalf = df.endAt(1);\r\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n     * \r\n     * // Get all rows ending at a particular date.\r\n     * const result = timeSeriesDf.endAt(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    endAt (indexValue: IndexT): IDataFrame<IndexT, ValueT> {\r\n\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            const lessThanOrEqualTo = this.getIndex().getLessThanOrEqualTo();\r\n            return {\r\n                columnNames: content.columnNames,\r\n                index: new TakeWhileIterable(content.index, index => lessThanOrEqualTo(index, indexValue)),\r\n                pairs: new TakeWhileIterable(content.pairs, pair => lessThanOrEqualTo(pair[0], indexValue)),\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets a new dataframe containing all rows up to the specified index value (exclusive).\r\n     * \r\n     * @param indexValue The index value at which to end the new dataframe.\r\n     * \r\n     * @return Returns a new dataframe containing all rows up to (but not including) the specified index value. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = new DataFrame({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const firstHalf = df.before(2);\r\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n     * \r\n     * // Get all rows before the specified date.\r\n     * const result = timeSeriesDf.before(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    before (indexValue: IndexT): IDataFrame<IndexT, ValueT> {\r\n\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            const lessThan = this.getIndex().getLessThan();\r\n            return {\r\n                columnNames: content.columnNames,\r\n                index: new TakeWhileIterable(content.index, index => lessThan(index, indexValue)),\r\n                pairs: new TakeWhileIterable(content.pairs, pair => lessThan(pair[0], indexValue)),\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets a new dataframe containing all rows after the specified index value (exclusive).\r\n     * \r\n     * @param indexValue The index value after which to start the new dataframe.\r\n     * \r\n     * @return Returns a new dataframe containing all rows after the specified index value.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = new DataFrame({ \r\n     *      index: [0, 1, 2, 3], // This is the default index.\r\n     *      values: [10, 20, 30, 40],\r\n     * });\r\n     * \r\n     * const lastHalf = df.before(1);\r\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n     * \r\n     * // Get all rows after the specified date.\r\n     * const result = timeSeriesDf.after(new Date(2016, 5, 4)); \r\n     * </pre>\r\n     */\r\n    after (indexValue: IndexT): IDataFrame<IndexT, ValueT> {\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            const lessThanOrEqualTo = this.getIndex().getLessThanOrEqualTo();\r\n            return {\r\n                columnNames: content.columnNames,\r\n                index: new SkipWhileIterable(content.index, index => lessThanOrEqualTo(index, indexValue)),\r\n                pairs: new SkipWhileIterable(content.pairs, pair => lessThanOrEqualTo(pair[0], indexValue)),\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets a new dataframe containing all rows between the specified index values (inclusive).\r\n     * \r\n     * @param startIndexValue The index at which to start the new dataframe.\r\n     * @param endIndexValue The index at which to end the new dataframe.\r\n     * \r\n     * @return Returns a new dataframe containing all values between the specified index values (inclusive).\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = new DataFrame({ \r\n     *      index: [0, 1, 2, 3, 4, 6], // This is the default index.\r\n     *      values: [10, 20, 30, 40, 50, 60],\r\n     * });\r\n     * \r\n     * const middleSection = df.between(1, 4);\r\n     * expect(middleSection.toArray()).to.eql([20, 30, 40, 50]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\r\n     * \r\n     * // Get all rows between the start and end dates (inclusive).\r\n     * const result = timeSeriesDf.after(new Date(2016, 5, 4), new Date(2016, 5, 22)); \r\n     * </pre>\r\n     */\r\n    between (startIndexValue: IndexT, endIndexValue: IndexT): IDataFrame<IndexT, ValueT> {\r\n        return this.startAt(startIndexValue).endAt(endIndexValue); \r\n    }\r\n\r\n    /** \r\n     * Format the dataframe for display as a string.\r\n     * This forces lazy evaluation to complete.\r\n     * \r\n     * @return Generates and returns a string representation of the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * console.log(df.toString());\r\n     * </pre>\r\n     */\r\n    toString (): string {\r\n\r\n        const columnNames = this.getColumnNames();\r\n        const header = [\"__index__\"].concat(columnNames);\r\n\r\n        const table = new Table();\r\n        //TODO: for (const pair of this.asPairs()) {\r\n        for (const pair of this.toPairs()) {\r\n            const index = pair[0];\r\n            const value = pair[1] as any;\r\n            table.cell(header[0], index);\r\n            for (let columnIndex = 0; columnIndex < columnNames.length; ++columnIndex) {\r\n                const columnName = columnNames[columnIndex];\r\n                table.cell(header[columnIndex+1], value[columnName]);\r\n            }\r\n            table.newRow();\r\n        }\r\n\r\n        return table.toString();\r\n    }\r\n\r\n    /**\r\n     * Parse a column with string values and convert it to a column with int values.\r\n     *\r\n     * @param columnNameOrNames Specifies the column name or array of column names to parse.\r\n     * \r\n     * @return Returns a new dataframe with values of particular named column(s) parsed from strings to ints.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const parsed = df.parseInts(\"MyIntColumn\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const parsed = df.parseInts([\"MyIntColumnA\", \"MyIntColumnA\"]);\r\n     * </pre>\r\n     */\r\n    parseInts (columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT> {\r\n\r\n        if (isArray(columnNameOrNames)) {\r\n            let working: IDataFrame<IndexT, ValueT> = this;\r\n            for (const columnName of columnNameOrNames) {\r\n                working = working.parseInts(columnName);\r\n            }\r\n            \r\n            return working;\r\n        }\r\n        else {\r\n            return this.withSeries(columnNameOrNames, this.getSeries(columnNameOrNames).parseInts());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse a column with string values and convert it to a column with float values.\r\n     *\r\n     * @param columnNameOrNames Specifies the column name or array of column names to parse.\r\n     * \r\n     * @return Returns a new dataframe with values of particular named column(s) parsed from strings to floats.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const parsed = df.parseFloats(\"MyFloatColumn\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const parsed = df.parseFloats([\"MyFloatColumnA\", \"MyFloatColumnA\"]);\r\n     * </pre>\r\n     */\r\n    parseFloats (columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT> {\r\n\r\n        if (isArray(columnNameOrNames)) {\r\n            let working: IDataFrame<IndexT, ValueT> = this;\r\n            for (const columnName of columnNameOrNames) {\r\n                working = working.parseFloats(columnName);\r\n            }\r\n            \r\n            return working;\r\n        }\r\n        else {\r\n            return this.withSeries(columnNameOrNames, this.getSeries(columnNameOrNames).parseFloats());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse a column with string values and convert it to a column with date values.\r\n     *\r\n     * @param columnNameOrNames Specifies the column name or array of column names to parse.\r\n     * @param formatString Optional formatting string for dates.\r\n     * \r\n     * Moment is used for date parsing.\r\n     * https://momentjs.com\r\n     * \r\n     * @return Returns a new dataframe with values of particular named column(s) parsed from strings to dates.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const parsed = df.parseDates(\"MyDateColumn\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const parsed = df.parseDates([\"MyDateColumnA\", \"MyDateColumnA\"]);\r\n     * </pre>\r\n     */\r\n    parseDates (columnNameOrNames: string | string[], formatString?: string): IDataFrame<IndexT, ValueT> {\r\n\r\n        if (formatString) {\r\n            if (!isString(formatString)) throw new Error(\"Expected optional 'formatString' parameter to 'DataFrame.parseDates' to be a string (if specified).\");\r\n        }\r\n\r\n        if (isArray(columnNameOrNames)) {\r\n            let working: IDataFrame<IndexT, ValueT> = this;\r\n            for (const columnName of columnNameOrNames) {\r\n                working = working.parseDates(columnName, formatString);\r\n            }\r\n            \r\n            return working;\r\n        }\r\n        else {\r\n            return this.withSeries(columnNameOrNames, this.getSeries(columnNameOrNames).parseDates(formatString));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert a column of values of different types to a column of string values.\r\n     *\r\n     * @param columnNames Specifies the column name or array of column names to convert to strings. Can also be a format spec that specifies which columns to convert and what their format should be. \r\n     * @param formatString Optional formatting string for dates.\r\n     * \r\n     * Numeral.js is used for number formatting.\r\n     * http://numeraljs.com/\r\n     * \r\n     * Moment is used for date formatting.\r\n     * https://momentjs.com/docs/#/parsing/string-format/\r\n     * \r\n     * @return Returns a new dataframe with a particular named column converted from values to strings.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = df.toStrings(\"MyDateColumn\", \"YYYY-MM-DD\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const result = df.toStrings(\"MyFloatColumn\", \"0.00\");\r\n     * </pre>\r\n     */\r\n    toStrings (columnNames: string | string[] | IFormatSpec, formatString?: string): IDataFrame<IndexT, ValueT> {\r\n\r\n        if (isObject(columnNames)) {\r\n            for (const columnName of Object.keys(columnNames)) {\r\n                if (!isString((columnNames as any)[columnName])) throw new Error(\"Expected values of 'columnNames' parameter to be strings when a format spec is passed in.\");\r\n            }\r\n\r\n            if (!isUndefined(formatString)) throw new Error(\"Optional 'formatString' parameter to 'DataFrame.toStrings' should not be set when passing in a format spec.\");\r\n        }\r\n        else {\r\n            if (!isArray(columnNames)) {\r\n                if (!isString(columnNames)) throw new Error(\"Expected 'columnNames' parameter to 'DataFrame.toStrings' to be a string, array of strings or format spec that specifes which columns should be converted to strings.\");\r\n            }\r\n\r\n            if (formatString) {\r\n                if (!isString(formatString)) throw new Error(\"Expected optional 'formatString' parameter to 'DataFrame.toStrings' to be a string (if specified).\");\r\n            }    \r\n        }\r\n\r\n        if (isObject(columnNames)) {\r\n            let working: IDataFrame<IndexT, ValueT> = this;\r\n            for (const columnName of Object.keys(columnNames)) {\r\n                const columnFormatString = (columnNames as any)[columnName];\r\n                working = working.toStrings(columnName, columnFormatString)\r\n            }\r\n            \r\n            return working;\r\n        }\r\n        else if (isArray(columnNames)) {\r\n            let working: IDataFrame<IndexT, ValueT> = this;\r\n            for (const columnName of columnNames) {\r\n                working = working.toStrings(columnName, formatString);\r\n            }\r\n            \r\n            return working;\r\n        }\r\n        else {\r\n            const singleColumnName = columnNames as string;\r\n            return this.withSeries(singleColumnName, this.getSeries(singleColumnName).toStrings(formatString));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Produces a new dataframe with all string values truncated to the requested maximum length.\r\n     *\r\n     * @param maxLength The maximum length of the string values after truncation.\r\n     * \r\n     * @return Returns a new dataframe with all strings truncated to the specified maximum length.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Truncate all string columns to 100 characters maximum.\r\n     * const truncatedDf = df.truncateString(100);\r\n     * </pre>\r\n     */\r\n    truncateStrings (maxLength: number): IDataFrame<IndexT, ValueT> {\r\n        if (!isNumber(maxLength)) throw new Error(\"Expected 'maxLength' parameter to 'truncateStrings' to be an integer.\");\r\n\r\n        return this.select((row: any) => {\r\n            const output: any = {};\r\n            for (const key of Object.keys(row)) {\r\n                const value = row[key];\r\n                if (isString(value)) {\r\n                    output[key] = value.substring(0, maxLength);\r\n                }\r\n                else {\r\n                    output[key] = value;\r\n                }\r\n            }\r\n           return <ValueT> output;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Produces a new dataframe with all number values rounded to the specified number of places.\r\n     *\r\n     * @param numDecimalPlaces The number of decimal places, defaults to 2.\r\n     * \r\n     * @returns Returns a new dataframe with all number values rounded to the specified number of places.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = ... your data frame ...\r\n     * const rounded = df.round(); // Round numbers to two decimal places.\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = ... your data frame ...\r\n     * const rounded = df.round(3); // Round numbers to three decimal places.\r\n     * </pre>\r\n     */\r\n    round (numDecimalPlaces?: number): IDataFrame<IndexT, ValueT> {\r\n\r\n        if (numDecimalPlaces !== undefined) {\r\n            if (!isNumber(numDecimalPlaces)) {\r\n                throw new Error(\"Expected 'numDecimalPlaces' parameter to 'DataFrame.round' to be a number.\");\r\n            }\r\n        }\r\n        else {\r\n            numDecimalPlaces = 2; // Default to two decimal places.\r\n        }\r\n\r\n        return this.select((row: any) => {\r\n            const output: any = {};\r\n            for (const key of Object.keys(row)) {\r\n                const value = row[key];\r\n                if (isNumber(value)) {\r\n                    output[key] = parseFloat(value.toFixed(numDecimalPlaces));\r\n                }\r\n                else {\r\n                    output[key] = value;\r\n                }\r\n            }\r\n           return <ValueT> output;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Forces lazy evaluation to complete and 'bakes' the dataframe into memory.\r\n     * \r\n     * @return Returns a dataframe that has been 'baked', all lazy evaluation has completed.  \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const baked = df.bake();\r\n     * </pre>\r\n     */\r\n    bake (): IDataFrame<IndexT, ValueT> {\r\n\r\n        if (this.getContent().isBaked) {\r\n            // Already baked.\r\n            return this;\r\n        }\r\n\r\n        return new DataFrame({\r\n            columnNames: this.getColumnNames(),\r\n            values: this.toArray(),\r\n            pairs: this.toPairs(),\r\n            baked: true,\r\n        });\r\n    }\r\n\r\n    /** \r\n     * Gets a new dataframe in reverse order.\r\n     * \r\n     * @return Returns a new dataframe that is the reverse of the input.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const reversedDf = df.reverse();\r\n     * </pre>\r\n     */\r\n    reverse (): IDataFrame<IndexT, ValueT> {\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                columnNames: content.columnNames,\r\n                values: new ReverseIterable(content.values),\r\n                index: new ReverseIterable(content.index),\r\n                pairs: new ReverseIterable(content.pairs)\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns only the set of rows in the dataframe that are distinct according to some criteria.\r\n     * This can be used to remove duplicate rows from the dataframe.\r\n     *\r\n     * @param selector User-defined selector function that specifies the criteria used to make comparisons for duplicate rows.\r\n     * Note that the selector determines the object used for the comparison.  If the selector returns a new instance of an array or a\r\n     * javascript object, distinct will always include all rows since the object instances are different even if the members are the same.  \r\n     * \r\n     * @return Returns a dataframe containing only unique values as determined by the 'selector' function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Remove duplicate rows by customer id. Will return only a single row per customer.\r\n     * const distinctCustomers = salesDf.distinct(sale => sale.CustomerId);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * \r\n     * <pre>\r\n     * // Remove duplicate rows across mutliple columns\r\n     * const safeJoinChar = '$';\r\n     * const distinctCustomers = salesDf.distinct(sale => [sale.CustomerId, sale.MonthOfYear].join(safeJoinChar));\r\n     * </pre>\r\n     */\r\n    distinct<ToT> (selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT> {\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                columnNames: content.columnNames,\r\n                values: new DistinctIterable<ValueT, ToT>(content.values, selector),\r\n                pairs: new DistinctIterable<[IndexT, ValueT],ToT>(content.pairs, (pair: [IndexT, ValueT]): ToT => selector && selector(pair[1]) || <ToT> <any> pair[1])\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Collects rows in the dataframe into a series of groups according to the user-defined selector function that defines the group for each row.\r\n     *\r\n     * @param selector User-defined selector function that defines the value to group by.\r\n     *\r\n     * @return Returns a {@link Series} of groups. Each group is a dataframe with values that have been grouped by the 'selector' function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const salesDf = ... product sales ...\r\n     * const salesByProduct = salesDf.groupBy(sale => sale.ProductId);\r\n     * for (const productSalesGroup of salesByProduct) {\r\n     *      // ... do something with each product group ...\r\n     *      const productId = productSalesGroup.first().ProductId;\r\n     *      const totalSalesForProduct = productSalesGroup.deflate(sale => sale.Amount).sum();\r\n     *      console.log(totalSalesForProduct);\r\n     * }\r\n     * </pre>\r\n     */\r\n    groupBy<GroupT> (selector: SelectorWithIndexFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>> {\r\n\r\n        if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.groupBy' to be a selector function that determines the value to group the series by.\");\r\n\r\n        return new Series<number, IDataFrame<IndexT, ValueT>>(() => {\r\n            const groups: any[] = []; // Each group, in order of discovery.\r\n            const groupMap: any = {}; // Group map, records groups by key.\r\n            \r\n            let valueIndex = 0;\r\n    \r\n            for (const pair of this.getContent().pairs) {\r\n                const groupKey = selector(pair[1], valueIndex);\r\n                ++valueIndex;\r\n                const existingGroup = groupMap[groupKey];\r\n                if (existingGroup) {\r\n                    existingGroup.push(pair);\r\n                }\r\n                else {\r\n                    const newGroup: any[] = [];\r\n                    newGroup.push(pair);\r\n                    groups.push(newGroup);\r\n                    groupMap[groupKey] = newGroup;\r\n                }\r\n            }\r\n\r\n            return {\r\n                values: groups.map(group => new DataFrame<IndexT, ValueT>({ pairs: group }))\r\n            };\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Collects rows in the dataframe into a series of groups according to a user-defined selector function that identifies adjacent rows that should be in the same group.\r\n     *\r\n     * @param selector Optional selector that defines the value to group by.\r\n     *\r\n     * @return Returns a {@link Series} of groups. Each group is a dataframe with values that have been grouped by the 'selector' function.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Some ultra simple stock trading strategy backtesting...\r\n     * const dailyStockPriceDf = ... daily stock price for a company ...\r\n     * const priceGroups  = dailyStockPriceDf.groupBy(day => day.close > day.movingAverage);\r\n     * for (const priceGroup of priceGroups) {\r\n     *      // ... do something with each stock price group ...\r\n     * \r\n     *      const firstDay = priceGroup.first();\r\n     *      if (firstDay.close > movingAverage) {\r\n     *          // This group of days has the stock price above its moving average.\r\n     *          // ... maybe enter a long trade here ...\r\n     *      }\r\n     *      else {\r\n     *          // This group of days has the stock price below its moving average.\r\n     *          // ... maybe enter a short trade here ...\r\n     *      }\r\n     * }\r\n     * </pre>\r\n     */\r\n    groupSequentialBy<GroupT> (selector?: SelectorFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>> {\r\n\r\n        if (selector) {\r\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.groupSequentialBy' to be a selector function that determines the value to group the series by.\")\r\n        }\r\n        else {\r\n            selector = value => <GroupT> <any> value;\r\n        }\r\n        \r\n        return this.variableWindow((a: ValueT, b: ValueT): boolean => selector!(a) === selector!(b));\r\n    }\r\n\r\n    /**\r\n     * Concatenate multiple dataframes into a single dataframe.\r\n     *\r\n     * @param dataframes Array of dataframes to concatenate.\r\n     * \r\n     * @return Returns a single dataframe concatenated from multiple input dataframes. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df1 = ...\r\n     * const df2 = ...\r\n     * const df3 = ...\r\n     * const concatenatedDf = DataFrame.concat([df1, df2, df3]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfs = [... array of dataframes...];\r\n     * const concatenatedDf = DataFrame.concat(dfs);\r\n     * </pre>\r\n     */\r\n    static concat<IndexT = any, ValueT = any> (dataframes: IDataFrame<IndexT, ValueT>[]): IDataFrame<IndexT, ValueT > {\r\n        if (!isArray(dataframes)) throw new Error(\"Expected 'dataframes' parameter to 'DataFrame.concat' to be an array of dataframes.\");\r\n\r\n        return new DataFrame(() => {\r\n            const upcast = <DataFrame<IndexT, ValueT>[]> dataframes; // Upcast so that we can access private index, values and pairs.\r\n            const contents = upcast.map(dataframe => dataframe.getContent());\r\n\r\n            let columnNames: string[] = [];\r\n            for (const content of contents) {\r\n                for (const columnName of content.columnNames) {\r\n                    columnNames.push(columnName);\r\n                }\r\n            }\r\n\r\n            columnNames = makeDistinct(columnNames);\r\n\r\n            return {\r\n                columnNames: columnNames,\r\n                values: new ConcatIterable(contents.map(content => content.values)),\r\n                pairs: new ConcatIterable(contents.map(content => content.pairs)),\r\n            };\r\n        });    \r\n    }\r\n    \r\n    /**\r\n     * Concatenate multiple other dataframes onto this dataframe.\r\n     * \r\n     * @param dataframes Multiple arguments. Each can be either a dataframe or an array of dataframes.\r\n     * \r\n     * @return Returns a single dataframes concatenated from multiple input dataframes. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenatedDf = dfA.concat(dfB);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenatedDf = dfA.concat(dfB, dfC);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenatedDf = dfA.concat([dfB, dfC]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const concatenatedDf = dfA.concat(dfB, [dfC, dfD]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const otherDfs = [... array of dataframes...];\r\n     * const concatenatedDf = dfA.concat(otherDfs);\r\n     * </pre>\r\n     */    \r\n    concat (...dataframes: (IDataFrame<IndexT, ValueT>[] | IDataFrame<IndexT, ValueT>)[]): IDataFrame<IndexT, ValueT> {\r\n        const concatInput: IDataFrame<IndexT, ValueT>[] = [this];\r\n\r\n        for (const input of dataframes) {\r\n            if (isArray(input)) {\r\n                for (const subInput of input) {\r\n                    concatInput.push(subInput);\r\n                }\r\n            }\r\n            else {\r\n                concatInput.push(input);\r\n            }\r\n        }\r\n\r\n        return DataFrame.concat<IndexT, ValueT>(concatInput);\r\n    }\r\n   \r\n    /**\r\n    * Zip (or merge) together multiple dataframes to create a new dataframe.\r\n    * Preserves the index of the first dataframe.\r\n    *\r\n    * @param input An iterable of datafames to be zipped.\r\n    * @param zipper User-defined zipper function that merges rows. It produces rows for the new dataframe based-on rows from the input dataframes.\r\n    * \r\n    * @return Returns a single dataframe zipped (or merged) from multiple input dataframes. \r\n    * \r\n    * @example\r\n    * <pre>\r\n    * \r\n    * function produceNewRow (inputRows) {\r\n    *       const outputRow = {\r\n    *           // Produce output row based on the contents of the input rows.\r\n    *       };\r\n    *       return outputRow;\r\n    * }\r\n    * \r\n    * const inputDfs = [... array of input dataframes ...];\r\n    * const zippedDf = DataFrame.zip(inputDfs, produceNewRow);\r\n    * \r\n    * </pre>\r\n    * \r\n    * @example\r\n    * <pre>\r\n    * \r\n    * function produceNewRow (inputRows) {\r\n    *       const outputRow = {\r\n    *           // Produce output row based on the contents of the input rows.\r\n    *       };\r\n    *       return outputRow;\r\n    * }\r\n    * \r\n    * const dfA = new DataFrame([ { Value: 10 }, { Value: 20 }, { Value: 30 }]);\r\n    * const dfB = new DataFrame([ { Value: 100 }, { Value: 200 }, { Value: 300 }]);\r\n    * const zippedDf = DataFrame.zip([dfA, dfB], produceNewRow);\r\n    * </pre>\r\n    */\r\n    static zip<IndexT = any, ValueT = any, ResultT = any> (dataframes: Iterable<IDataFrame<IndexT, ValueT>>, zipper: ZipNFn<ValueT, ResultT>): IDataFrame<IndexT, ResultT> {\r\n\r\n        const input = Array.from(dataframes);\r\n\r\n        if (input.length === 0) {\r\n            return new DataFrame<IndexT, ResultT>();\r\n        }\r\n\r\n        const firstSeries = input[0];\r\n        if (firstSeries.none()) {\r\n            return new DataFrame<IndexT, ResultT>();\r\n        }\r\n\r\n        return new DataFrame<IndexT, ResultT>(() => {\r\n            const firstSeriesUpCast = <DataFrame<IndexT, ValueT>> firstSeries;\r\n            const upcast = <DataFrame<IndexT, ValueT>[]> input; // Upcast so that we can access private index, values and pairs.\r\n            \r\n            return {\r\n                index: <Iterable<IndexT>> firstSeriesUpCast.getContent().index,\r\n                values: new ZipIterable<ValueT, ResultT>(upcast.map(s => s.getContent().values), zipper),\r\n            };\r\n        });\r\n    }\r\n    \r\n    /**\r\n    * Zip (or merge) together multiple dataframes to create a new dataframe.\r\n    * Preserves the index of the first dataframe.\r\n    * \r\n    * @param s2, s3, s4, s4 Multiple dataframes to zip.\r\n    * @param zipper User-defined zipper function that merges rows. It produces rows for the new dataframe based-on rows from the input dataframes.\r\n    * \r\n    * @return Returns a single dataframe zipped (or merged) from multiple input dataframes. \r\n    * \r\n    * @example\r\n    * <pre>\r\n    * \r\n    * function produceNewRow (rowA, rowB) {\r\n    *       const outputRow = {\r\n    *           ValueA: rowA.Value,\r\n    *           ValueB: rowB.Value,\r\n    *       };\r\n    *       return outputRow;\r\n    * }\r\n    * \r\n    * const dfA = new DataFrame([ { Value: 10 }, { Value: 20 }, { Value: 30 }]);\r\n    * const dfB = new DataFrame([ { Value: 100 }, { Value: 200 }, { Value: 300 }]);\r\n    * const zippedDf = dfA.zip(dfB, produceNewRow);\r\n    * </pre>\r\n    */    \r\n    zip<Index2T, Value2T, ResultT>  (s2: IDataFrame<Index2T, Value2T>, zipper: Zip2Fn<ValueT, Value2T, ResultT> ): IDataFrame<IndexT, ResultT>;\r\n    zip<Index2T, Value2T, Index3T, Value3T, ResultT>  (s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): IDataFrame<IndexT, ResultT>;\r\n    zip<Index2T, Value2T, Index3T, Value3T, Index4T, Value4T, ResultT>  (s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, s4: IDataFrame<Index4T, Value4T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): IDataFrame<IndexT, ResultT>;\r\n    zip<ResultT>  (...args: any[]): IDataFrame<IndexT, ResultT> {\r\n\r\n        const selector: Function = args[args.length-1];\r\n        const input: IDataFrame<IndexT, any>[] = [this].concat(args.slice(0, args.length-1));\r\n        return DataFrame.zip<IndexT, any, ResultT>(input, values => selector(...values));\r\n    }    \r\n\r\n    /**\r\n     * Sorts the dataframe in ascending order by a value defined by the user-defined selector function. \r\n     * \r\n     * @param selector User-defined selector function that selects the value to sort by.\r\n     * \r\n     * @return Returns a new dataframe that has been ordered accorrding to the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Order sales by amount from least to most.\r\n     * const orderedDf = salesDf.orderBy(sale => sale.Amount); \r\n     * </pre>\r\n     */\r\n    orderBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT> {\r\n        const content = this.getContent();\r\n        return new OrderedDataFrame<IndexT, ValueT, SortT>({\r\n            columnNames: content.columnNames,\r\n            values: content.values, \r\n            pairs: content.pairs, \r\n            selector: selector, \r\n            direction: Direction.Ascending, \r\n            parent: null,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sorts the dataframe in descending order by a value defined by the user-defined selector function. \r\n     * \r\n     * @param selector User-defined selector function that selects the value to sort by.\r\n     * \r\n     * @return Returns a new dataframe that has been ordered accorrding to the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Order sales by amount from most to least\r\n     * const orderedDf = salesDf.orderByDescending(sale => sale.Amount); \r\n     * </pre>\r\n     */\r\n    orderByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT> {\r\n        const content = this.getContent();\r\n        return new OrderedDataFrame<IndexT, ValueT, SortT>({\r\n            columnNames: content.columnNames,\r\n            values: content.values, \r\n            pairs: content.pairs, \r\n            selector: selector, \r\n            direction: Direction.Descending, \r\n            parent: null,\r\n        });\r\n    }\r\n        \r\n    /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains the union of rows from the two input dataframes.\r\n     * These are the unique combination of rows in both dataframe.\r\n     * This is basically a concatenation and then elimination of duplicates.\r\n     *\r\n     * @param other The other dataframes to merge.\r\n     * @param selector Optional user-defined selector function that selects the value to compare to determine distinctness.\r\n     * \r\n     * @return Returns the union of the two dataframes.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * const dfA = ...\r\n     * const dfB = ...\r\n     * const merged = dfA.union(dfB);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Merge two sets of customer records that may contain the same\r\n     * // customer record in each set. This is basically a concatenation\r\n     * // of the dataframes and then an elimination of any duplicate records\r\n     * // that result.\r\n     * const customerRecordsA = ...\r\n     * const customerRecordsB = ...\r\n     * const mergedCustomerRecords = customerRecordsA.union(\r\n     *      customerRecordsB, \r\n     *      customerRecord => customerRecord.CustomerId\r\n     * );\r\n     * </pre>\r\n     * \r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Note that you can achieve the exact same result as the previous\r\n     * // example by doing a {@link DataFrame.concat) and {@link DataFrame.distinct}\r\n     * // of the dataframes and then an elimination of any duplicate records\r\n     * // that result.\r\n     * const customerRecordsA = ...\r\n     * const customerRecordsB = ...\r\n     * const mergedCustomerRecords = customerRecordsA\r\n     *      .concat(customerRecordsB)\r\n     *      .distinct(customerRecord => customerRecord.CustomerId);\r\n     * </pre>\r\n     * \r\n     */\r\n    union<KeyT = ValueT> (\r\n        other: IDataFrame<IndexT, ValueT>, \r\n        selector?: SelectorFn<ValueT, KeyT>): \r\n            IDataFrame<IndexT, ValueT> {\r\n\r\n        if (selector) {\r\n            if (!isFunction(selector)) throw new Error(\"Expected optional 'selector' parameter to 'DataFrame.union' to be a selector function.\");\r\n        }\r\n\r\n        return this.concat(other).distinct(selector);\r\n    }\r\n\r\n    /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains the intersection of rows from the two input dataframes.\r\n     * These are only the rows that appear in both dataframes.\r\n     *\r\n     * @param inner The inner dataframe to merge (the dataframe you call the function on is the 'outer' dataframe).\r\n     * @param outerSelector Optional user-defined selector function that selects the key from the outer dataframe that is used to match the two dataframes.\r\n     * @param innerSelector Optional user-defined selector function that selects the key from the inner dataframe that is used to match the two dataframes.\r\n     * \r\n     * @return Returns a new dataframe that contains the intersection of rows from the two input dataframes.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfA = ...\r\n     * const dfB = ...\r\n     * const mergedDf = dfA.intersection(dfB);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Merge two sets of customer records to find only the\r\n     * // customers that appears in both.\r\n     * const customerRecordsA = ...\r\n     * const customerRecordsB = ...\r\n     * const intersectionOfCustomerRecords = customerRecordsA.intersection(\r\n     *      customerRecordsB, \r\n     *      customerRecord => customerRecord.CustomerId\r\n     * );\r\n     * </pre>     \r\n     * */\r\n    intersection<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\r\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \r\n        outerSelector?: SelectorFn<ValueT, KeyT>,\r\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \r\n            IDataFrame<IndexT, ValueT> {\r\n\r\n        if (outerSelector) {\r\n            if (!isFunction(outerSelector)) throw new Error(\"Expected optional 'outerSelector' parameter to 'DataFrame.intersection' to be a function.\");\r\n        }\r\n        else {\r\n            outerSelector = value => <KeyT> <any> value;\r\n        }\r\n        \r\n        if (innerSelector) {\r\n            if (!isFunction(innerSelector)) throw new Error(\"Expected optional 'innerSelector' parameter to 'DataFrame.intersection' to be a function.\");\r\n        }\r\n        else {\r\n            innerSelector = value => <KeyT> <any> value;\r\n        }\r\n\r\n        const outer = this;\r\n        return outer.filter(outerValue => {\r\n                const outerKey = outerSelector!(outerValue);\r\n                return inner\r\n                    .filter(innerValue => outerKey === innerSelector!(innerValue))\r\n                    .any();\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains only the rows from the 1st dataframe that don't appear in the 2nd dataframe.\r\n     * This is essentially subtracting the rows from the 2nd dataframe from the 1st and creating a new dataframe with the remaining rows.\r\n     *\r\n     * @param inner The inner dataframe to merge (the dataframe you call the function on is the 'outer' dataframe).\r\n     * @param outerSelector Optional user-defined selector function that selects the key from the outer dataframe that is used to match the two dataframes.\r\n     * @param innerSelector Optional user-defined selector function that selects the key from the inner dataframe that is used to match the two dataframes.\r\n     * \r\n     * @return Returns a new dataframe that contains only the rows from the 1st dataframe that don't appear in the 2nd dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const dfA = ...\r\n     * const dfB = ...\r\n     * const remainingDf = dfA.except(dfB);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     *\r\n     * // Find the list of customers haven't bought anything recently.\r\n     * const allCustomers = ... list of all customers ...\r\n     * const recentCustomers = ... list of customers who have purchased recently ...\r\n     * const remainingCustomers = allCustomers.except(\r\n     *      recentCustomers, \r\n     *      customerRecord => customerRecord.CustomerId\r\n     * );\r\n     * </pre>\r\n     */\r\n    except<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\r\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \r\n        outerSelector?: SelectorFn<ValueT, KeyT>,\r\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \r\n            IDataFrame<IndexT, ValueT> {\r\n\r\n        if (outerSelector) {\r\n            if (!isFunction(outerSelector)) throw new Error(\"Expected optional 'outerSelector' parameter to 'DataFrame.except' to be a function.\");\r\n        }\r\n        else {\r\n            outerSelector = value => <KeyT> <any> value;\r\n        }\r\n\r\n        if (innerSelector) {\r\n            if (!isFunction(innerSelector)) throw new Error(\"Expected optional 'innerSelector' parameter to 'DataFrame.except' to be a function.\");\r\n        }\r\n        else {\r\n            innerSelector = value => <KeyT> <any> value;\r\n        }\r\n\r\n        const outer = this;\r\n        return outer.filter(outerValue => {\r\n                const outerKey = outerSelector!(outerValue);\r\n                return inner\r\n                    .filter(innerValue => outerKey === innerSelector!(innerValue))\r\n                    .none();\r\n            });\r\n    }\r\n\r\n   /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains only those rows that have matching keys in both input dataframes.\r\n     *\r\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * @return Returns the new merged dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought both product A and product B.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const customersWhoBoughtBothProductsDf = customerWhoBoughtProductA.join(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    join<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT, InnerValueT, ResultValueT>):\r\n            IDataFrame<number, ResultValueT> {\r\n\r\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'DataFrame.join' to be a selector function.\");\r\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'DataFrame.join' to be a selector function.\");\r\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'DataFrame.join' to be a selector function.\");\r\n\r\n        const outer = this;\r\n\r\n        return new DataFrame<number, ResultValueT>(() => {\r\n            const innerMap = inner\r\n                .groupBy(innerKeySelector)\r\n                .toObject(\r\n                    group => innerKeySelector(group.first()), \r\n                    group => group\r\n                );\r\n\r\n            const outerContent = outer.getContent();\r\n\r\n            const output: ResultValueT[] = [];\r\n            \r\n            for (const outerValue of outer) { //TODO: There should be an enumerator that does this.\r\n                const outerKey = outerKeySelector(outerValue);\r\n                const innerGroup = innerMap[outerKey];\r\n                if (innerGroup) {\r\n                    for (const innerValue of innerGroup) {\r\n                        output.push(resultSelector(outerValue, innerValue));\r\n                    }    \r\n                }\r\n            }\r\n\r\n            return {\r\n                values: output\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains only those rows that are only present in one or the other of the dataframes, or both.\r\n     *\r\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * Implementation from here:\r\n     * \r\n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n     * \r\n     * @return Returns the new merged dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought either product A or product B, or both.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const customersWhoBoughtEitherProductButNotBothDf = customerWhoBoughtProductA.joinOuter(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    joinOuter<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\r\n            IDataFrame<number, ResultValueT> {\r\n\r\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'DataFrame.joinOuter' to be a selector function.\");\r\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'DataFrame.joinOuter' to be a selector function.\");\r\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'DataFrame.joinOuter' to be a selector function.\");\r\n\r\n        // Get the results in the outer that are not in the inner.\r\n        const outer = this;\r\n        const outerResult = outer.except<InnerIndexT, InnerValueT, KeyT>(inner, outerKeySelector, innerKeySelector)\r\n            .select(outer => resultSelector(outer, null))\r\n            .resetIndex();\r\n\r\n        // Get the results in the inner that are not in the outer.\r\n        const innerResult = inner.except<IndexT, ValueT, KeyT>(outer, innerKeySelector, outerKeySelector)\r\n            .select(inner => resultSelector(null, inner))\r\n            .resetIndex();\r\n\r\n        // Get the intersection of results between inner and outer.\r\n        const intersectionResults = outer.join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner, outerKeySelector, innerKeySelector, resultSelector);\r\n\r\n        return outerResult\r\n            .concat(intersectionResults)\r\n            .concat(innerResult)\r\n            .resetIndex();\r\n    }\r\n\r\n    /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains only those rows that present either in both dataframes or only in the outer (left) dataframe.\r\n     * \r\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * Implementation from here:\r\n     * \r\n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n     * \r\n     * @return Returns the new merged dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought either just product A or both product A and product B.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterLeft(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    joinOuterLeft<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\r\n            IDataFrame<number, ResultValueT> {\r\n\r\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'DataFrame.joinOuterLeft' to be a selector function.\");\r\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'DataFrame.joinOuterLeft' to be a selector function.\");\r\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'DataFrame.joinOuterLeft' to be a selector function.\");\r\n\r\n        // Get the results in the outer that are not in the inner.\r\n        const outer = this;\r\n        const outerResult = outer.except<InnerIndexT, InnerValueT, KeyT>(inner, outerKeySelector, innerKeySelector)\r\n            .select(outer => resultSelector(outer, null))\r\n            .resetIndex();\r\n\r\n        // Get the intersection of results between inner and outer.\r\n        const intersectionResults = outer.join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner, outerKeySelector, innerKeySelector, resultSelector);\r\n\r\n        return outerResult\r\n            .concat(intersectionResults)\r\n            .resetIndex();\r\n    }\r\n\r\n    /**\r\n     * Creates a new dataframe by merging two input dataframes.\r\n     * The resulting dataframe contains only those rows that present either in both dataframes or only in the inner (right) dataframe.\r\n     *\r\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\r\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\r\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\r\n     * @param resultSelector User-defined function that merges outer and inner values.\r\n     * \r\n     * Implementation from here:\r\n     * \r\n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n     * \r\n     * @return Returns the new merged dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Join together two sets of customers to find those\r\n     * // that have bought either just product B or both product A and product B.\r\n     * const customerWhoBoughtProductA = ...\r\n     * const customerWhoBoughtProductB = ...\r\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterRight(\r\n     *          customerWhoBoughtProductB,\r\n     *          customerA => customerA.CustomerId, // Join key.\r\n     *          customerB => customerB.CustomerId, // Join key.\r\n     *          (customerA, customerB) => {\r\n     *              return {\r\n     *                  // ... merge the results ...\r\n     *              };\r\n     *          }\r\n     *      );\r\n     * </pre>\r\n     */\r\n    joinOuterRight<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\r\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \r\n        outerKeySelector: SelectorFn<ValueT, KeyT>, \r\n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \r\n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\r\n            IDataFrame<number, ResultValueT> {\r\n\r\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'DataFrame.joinOuterRight' to be a selector function.\");\r\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'DataFrame.joinOuterRight' to be a selector function.\");\r\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'DataFrame.joinOuterRight' to be a selector function.\");\r\n\r\n        // Get the results in the inner that are not in the outer.\r\n        const outer = this;\r\n        const innerResult = inner.except<IndexT, ValueT, KeyT>(outer, innerKeySelector, outerKeySelector)\r\n            .select(inner => resultSelector(null, inner))\r\n            .resetIndex();\r\n\r\n        // Get the intersection of results between inner and outer.\r\n        const intersectionResults = outer.join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner, outerKeySelector, innerKeySelector, resultSelector);\r\n\r\n        return intersectionResults\r\n            .concat(innerResult)\r\n            .resetIndex();\r\n    }    \r\n\r\n    /**\r\n     * Produces a summary of dataframe. \r\n     * \r\n     * @param spec Optional parameter that specifies which columns to aggregate and how to aggregate them. Leave this out to produce a default summary of all columns.\r\n     * \r\n     * @returns A object with fields that summary the values in the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = df.summarize();\r\n     * console.log(summary);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = df.summarize({ // Summarize using pre-defined functions.\r\n     *      Column1: Series.sum,\r\n     *      Column2: Series.average,\r\n     *      Column3: Series.count,\r\n     * });\r\n     * console.log(summary);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = df.summarize({ // Summarize using custom functions.\r\n     *      Column1: series => series.sum(),\r\n     *      Column2: series => series.std(),\r\n     *      ColumnN: whateverFunctionYouWant,\r\n     * });\r\n     * console.log(summary);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const summary = df.summarize({ // Multiple output fields per column.\r\n     *      Column1: {\r\n     *          OutputField1: Series.sum,\r\n     *          OutputField2: Series.average,\r\n     *      },\r\n     *      Column2: {\r\n     *          OutputField3: series => series.sum(),\r\n     *          OutputFieldN: whateverFunctionYouWant,\r\n     *      },\r\n     * });\r\n     * console.log(summary);\r\n     * </pre>\r\n     */\r\n    summarize<OutputValueT = any> (\r\n        spec?: IMultiColumnAggregatorSpec\r\n            ): OutputValueT {\r\n\r\n        if (spec && !isObject(spec)) {\r\n            throw new Error(\"Expected 'spec' parameter to 'DataFrame.summarize' to be an object that specifies how to summarize the dataframe.\");\r\n        }\r\n\r\n        if (!spec) {\r\n            spec = {};\r\n\r\n            for (const columnName of this.getColumnNames()) {\r\n                const columnSpec: any = {};\r\n                columnSpec[columnName + \"_sum\"] = Series.sum;\r\n                columnSpec[columnName + \"_average\"] = Series.average;\r\n                columnSpec[columnName + \"_count\"] = Series.count;\r\n                spec[columnName] = columnSpec;\r\n\r\n            }\r\n        }\r\n\r\n        for (const inputColumnName of Object.keys(spec)) {\r\n            const inputSpec = spec[inputColumnName];\r\n            if (isFunction(inputSpec)) {\r\n                spec[inputColumnName] = {}; // Expand the spec.\r\n                (spec[inputColumnName] as IColumnAggregatorSpec) [inputColumnName] = inputSpec;\r\n            }\r\n        }\r\n\r\n        const inputColumnNames = Object.keys(spec);\r\n        const outputFieldsMap = toMap(\r\n            inputColumnNames, \r\n            valueColumnName => valueColumnName, \r\n            inputColumnName => Object.keys(spec![inputColumnName])\r\n        );\r\n\r\n        const output: any = {};\r\n        \r\n        for (const inputColumnName of inputColumnNames) {\r\n            const outputFieldNames = outputFieldsMap[inputColumnName];\r\n            for (const outputFieldName of outputFieldNames) {\r\n                const aggregatorFn = (spec[inputColumnName] as IColumnAggregatorSpec)[outputFieldName];\r\n                output[outputFieldName] = aggregatorFn(this.getSeries(inputColumnName));\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n    \r\n    /**\r\n     * Reshape (or pivot) a dataframe based on column values.\r\n     * This is a powerful function that combines grouping, aggregation and sorting.\r\n     *\r\n     * @param columnOrColumns Column name whose values make the new DataFrame's columns.\r\n     * @param valueColumnNameOrSpec Column name or column spec that defines the columns whose values should be aggregated.\r\n     * @param aggregator Optional function used to aggregate pivotted vales. \r\n     *\r\n     * @return Returns a new dataframe that has been pivoted based on a particular column's values. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Simplest example.\r\n     * // Group by the values in 'PivotColumn'.\r\n     * // The unique set of values in 'PivotColumn' becomes the columns in the resulting dataframe.\r\n     * // The column 'ValueColumn' is aggregated for each group and this becomes the \r\n     * // values in the new output column.\r\n     * const pivottedDf = df.pivot(\"PivotColumn\", \"ValueColumn\", values => values.average());\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Multiple input column example.\r\n     * // Similar to the previous example except now we are aggregating multiple input columns.\r\n     * // Each group has the average computed for 'ValueColumnA' and the sum for 'ValueColumnB'.\r\n     * const pivottedDf = df.pivot(\"PivotColumn\", { \r\n     *      ValueColumnA: aValues => aValues.average(),\r\n     *      ValueColumnB:  bValues => bValues.sum(),\r\n     * });\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Multiple output column example.\r\n     * // Similar to the previous example except now we are doing multiple aggregations for each input column.\r\n     * // The example produces an output dataframe with columns OutputColumnA, B, C and D.\r\n     * // OutputColumnA/B are the sum and average of ValueColumnA across each group as defined by PivotColumn.\r\n     * // OutputColumnC/D are the sum and average of ValueColumnB across each group as defined by PivotColumn.\r\n     * const pivottedDf = df.pivot(\"PivotColumn\", { \r\n     *      ValueColumnA: {\r\n     *          OutputColumnA: aValues => aValues.sum(),\r\n     *          OutputColumnB: aValues => aValues.average(),\r\n     *      },\r\n     *      ValueColumnB: {\r\n     *          OutputColumnC: bValues => bValues.sum(),\r\n     *          OutputColumnD: bValues => bValues.average(),\r\n     *      },\r\n     * });\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Full multi-column example.\r\n     * // Similar to the previous example now we are pivotting on multiple columns.\r\n     * // We now group by the 'PivotColumnA' and then by 'PivotColumnB', effectively creating a \r\n     * // multi-level group.\r\n     * const pivottedDf = df.pivot([\"PivotColumnA\", \"PivotColumnB\" ], { \r\n     *      ValueColumnA: aValues => aValues.average(),\r\n     *      ValueColumnB:  bValues => bValues.sum(),\r\n     * });\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // To help understand the pivot function, let's look at what it does internally.\r\n     * // Take the simplest example:\r\n     * const pivottedDf = df.pivot(\"PivotColumn\", \"ValueColumn\", values => values.average());\r\n     * \r\n     * // If we expand out the internals of the pivot function, it will look something like this:\r\n     * const pivottedDf = df.groupBy(row => row.PivotColumn)\r\n     *          .select(group => ({\r\n     *              PivotColumn: group.deflate(row => row.ValueColumn).average()\r\n     *          }))\r\n     *          .orderBy(row  => row.PivotColumn);\r\n     * \r\n     * // You can see that pivoting a dataframe is the same as grouping, aggregating and sorting it.\r\n     * // Does pivoting seem simpler now?\r\n     * \r\n     * // It gets more complicated than that of course, because the pivot function supports multi-level nested \r\n     * // grouping and aggregation of multiple columns. So a full expansion of the pivot function is rather complex.\r\n     * </pre>\r\n     */\r\n    pivot<NewValueT = ValueT> (\r\n        columnOrColumns: string | Iterable<string>, \r\n        valueColumnNameOrSpec: string | IMultiColumnAggregatorSpec, \r\n        aggregator?: (values: ISeries<number, any>) => any\r\n            ): IDataFrame<number, NewValueT> {\r\n\r\n        let columnNames: string[];\r\n\r\n        if (isString(columnOrColumns)) {\r\n            columnNames = [columnOrColumns];\r\n        }\r\n        else {\r\n            if (!isArray(columnOrColumns)) throw new Error(\"Expected 'columnOrColumns' parameter to 'DataFrame.pivot' to be a string or an array of strings that identifies the column(s) whose values make the new DataFrame's columns.\");\r\n\r\n            columnNames = Array.from(columnOrColumns);\r\n\r\n            if (columnNames.length === 0) throw new Error(\"Expected 'columnOrColumns' parameter to 'DataFrame.pivot' to contain at least one string.\");\r\n\r\n            for (const columnName of columnNames) {\r\n                if (!isString(columnName)) throw new Error(\"Expected 'columnOrColumns' parameter to 'DataFrame.pivot' to be an array of strings, each string identifies a column in the DataFrame on which to pivot.\");\r\n            }\r\n        }\r\n\r\n        let aggSpec: IMultiColumnAggregatorSpec;\r\n\r\n        if (!isObject(valueColumnNameOrSpec)) {\r\n            if (!isString(valueColumnNameOrSpec)) throw new Error(\"Expected 'value' parameter to 'DataFrame.pivot' to be a string that identifies the column whose values to aggregate or a column spec that defines which column contains the value ot aggregate and the ways to aggregate that value.\");\r\n            if (!isFunction(aggregator)) throw new Error(\"Expected 'aggregator' parameter to 'DataFrame.pivot' to be a function to aggregate pivoted values.\");\r\n\r\n            const aggColumnName = valueColumnNameOrSpec as string;\r\n\r\n            const outputSpec: IColumnAggregatorSpec = {};\r\n            outputSpec[aggColumnName] = aggregator!;\r\n\r\n            aggSpec = {};\r\n            aggSpec[aggColumnName] = outputSpec;\r\n        }\r\n        else {\r\n            aggSpec = valueColumnNameOrSpec as IMultiColumnAggregatorSpec;\r\n\r\n            for (const inputColumnName of Object.keys(aggSpec)) {\r\n                const columnAggSpec = aggSpec[inputColumnName];\r\n                if (isFunction(columnAggSpec)) {\r\n                    aggSpec[inputColumnName] = {}; // Expand the pivot spec.\r\n                    (aggSpec[inputColumnName] as IColumnAggregatorSpec) [inputColumnName] = columnAggSpec;\r\n                }\r\n            }\r\n        }\r\n\r\n        const firstColumnName = columnNames[0];\r\n        let working = this.groupBy((row: any) => row[firstColumnName])\r\n            .select(group => {\r\n                const output: any = {};\r\n                output[firstColumnName] = (group.first() as any)[firstColumnName];\r\n                output.src = group;\r\n                return output;\r\n            });\r\n\r\n        for (let columnNameIndex = 1; columnNameIndex < columnNames.length; ++columnNameIndex) {\r\n            const nextColumnName = columnNames[columnNameIndex];\r\n            working = working.selectMany(parentGroup => {\r\n                    const src: IDataFrame<IndexT, ValueT> = parentGroup.src;\r\n                    return src.groupBy((row: any) => row[nextColumnName])\r\n                        .select(subGroup => {\r\n                            const output = Object.assign({}, parentGroup);\r\n                            output[nextColumnName] = (subGroup.first() as any)[nextColumnName];\r\n                            output.src = subGroup;\r\n                            return output;\r\n                        });\r\n                });\r\n        }\r\n\r\n        const valueColumnNames = Object.keys(aggSpec);\r\n        const outputColumnsMap = toMap(\r\n            valueColumnNames, \r\n            valueColumnName => valueColumnName, \r\n            valueColumnName => Object.keys(aggSpec[valueColumnName])\r\n        );\r\n        \r\n        const pivotted = working.inflate<NewValueT>((row: any) => {\r\n            for (const valueColumnName of valueColumnNames) {\r\n                const outputColumnNames = outputColumnsMap[valueColumnName];\r\n                for (const outputColumName of outputColumnNames) {\r\n                    const aggregatorFn = (aggSpec[valueColumnName] as IColumnAggregatorSpec)[outputColumName];\r\n                    row[outputColumName] = aggregatorFn(row.src.deflate((srcRow: any) => srcRow[valueColumnName])) \r\n                }\r\n            }\r\n\r\n            delete row.src;\r\n            return row;\r\n        });\r\n\r\n        let ordered = pivotted.orderBy((row: any) => row[firstColumnName]);\r\n        for (let columnNameIndex = 1; columnNameIndex < columnNames.length; ++columnNameIndex) {\r\n            const nextColumnName = columnNames[columnNameIndex];\r\n            ordered = ordered.thenBy((row: any) => row[nextColumnName]);\r\n        }\r\n\r\n        return ordered;\r\n    }\r\n\r\n    /**\r\n     * Unpivot a DataFrame from wide to long format, optionally leaving identifiers set.\r\n     * This is a powerful function that combines grouping, aggregation and sorting.\r\n     *\r\n     * @param idColumnOrColumns Column(s) to use as identifier variables.\r\n     * @param valueColumnOrColumns Column(s) to unpivot.\r\n     *\r\n     * @return Returns a new dataframe that has been unpivoted based on a particular column's values. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Use column in 'idColumnOrColumns' as the identity column.\r\n     * // The column name passed in 'valueColumnOrColumns' forms the 'variable' column\r\n     * // and the values are used to populate the 'value' column of the new dataframe.\r\n     * const moltenDf = df.melt(\"A\", \"B\");\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Multiple value columns example.\r\n     * // Similar to the previous example except now the variable column will constitute\r\n     * // of multiple values.\r\n     * const moltenDf = df.melt(\"A\", [\"B\", \"C\"]);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Multiple identity and value columns example.\r\n     * const moltenDf = df.melt([\"A\", \"B\"], [\"C\", \"D\"]);\r\n     * </pre>\r\n     */\r\n    melt<ValueT> (\r\n        idColumnOrColumns: string | Iterable<string>,\r\n        valueColumnOrColumns: string | Iterable<string>\r\n    ): IDataFrame<IndexT, ValueT> {\r\n        let idColumnNames: string[];\r\n        let valueColumnNames: string[];\r\n\r\n        if (isString(idColumnOrColumns)) {\r\n            idColumnNames = [idColumnOrColumns];\r\n        }\r\n        else {\r\n            if (!isArray(idColumnOrColumns)) throw new Error(\"Expected 'idColumnOrColumns' parameter to 'DataFrame.melt' to be a string or an array of strings that identifies the column(s) whose values make the new DataFrame's identity columns.\");\r\n\r\n            idColumnNames = Array.from(idColumnOrColumns);\r\n\r\n            for (const columnName of idColumnNames) {\r\n                if (!isString(columnName)) throw new Error(\"Expected 'idColumnOrColumns' parameter to 'DataFrame.melt' to be a string or an array of strings that identifies the column(s) whose values make the new DataFrame's identity columns.\");\r\n            }\r\n        }\r\n\r\n        if (isString(valueColumnOrColumns)) {\r\n            valueColumnNames = [valueColumnOrColumns];\r\n        }\r\n        else {\r\n            if (!isArray(valueColumnOrColumns)) throw new Error(\"Expected 'valueColumnOrColumns' parameter to 'DataFrame.melt' to be a string or an array of strings that identifies the column(s) whose molten values make the new DataFrame's 'variable' and 'value' columns.\");\r\n\r\n            valueColumnNames = Array.from(valueColumnOrColumns);\r\n\r\n            for (const columnName of valueColumnNames) {\r\n                if (!isString(columnName)) throw new Error(\"Expected 'valueColumnOrColumns' parameter to 'DataFrame.melt' to be a string or an array of strings that identifies the column(s) whose molten values make the new DataFrame's 'variable' and 'value' columns.\");\r\n            }\r\n        }\r\n\r\n        const K: number = valueColumnNames.length;\r\n        const N: number = this.count();\r\n        let mdata: IDataFrame<IndexT, any> = new DataFrame<IndexT, ValueT>();\r\n        let original: IDataFrame<IndexT, any> = this.subset(idColumnNames.concat(valueColumnNames));\r\n\r\n        for (const col of idColumnNames){\r\n            original = original.dropSeries(col);\r\n\r\n            const idData = this.getSeries(col);\r\n            const columnData = new TileIterable(idData, K);\r\n            const columnSeries: ISeries<IndexT, ValueT> = new Series(columnData);\r\n\r\n            mdata = mdata.withSeries(col, columnSeries);\r\n        }\r\n\r\n        const seriesArray = [];\r\n\r\n        for (const col of original.getColumns()) {\r\n            seriesArray.push(this.getSeries(col.name));\r\n        }\r\n\r\n        const columnData = new RavelIterable(seriesArray);\r\n        const columnSeries: ISeries<IndexT, ValueT> = new Series(columnData);\r\n\r\n        mdata = mdata.withSeries('value', columnSeries);\r\n\r\n        const valueColumnData = new RepeatIterable(valueColumnNames, N);\r\n        const valueColumnSeries: ISeries<IndexT, ValueT> = new Series(valueColumnData);\r\n\r\n        mdata = mdata.withSeries('variable', valueColumnSeries);\r\n\r\n        return mdata;\r\n    }\r\n    \r\n    /**\r\n     * Insert a pair at the start of the dataframe.\r\n     * Doesn't modify the original dataframe! The returned dataframe is entirely new and contains rows from the original dataframe plus the inserted pair.\r\n     *\r\n     * @param pair The pair to insert.\r\n     * \r\n     * @return Returns a new dataframe with the specified pair inserted.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const newIndex = ... index of the new row ...\r\n     * const newRow = ... the new data row to insert ...\r\n     * const insertedDf = df.insertPair([newIndex, newRows]);\r\n     * </pre>\r\n     */\r\n    insertPair (pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT> {\r\n        if (!isArray(pair)) throw new Error(\"Expected 'pair' parameter to 'DataFrame.insertPair' to be an array.\");\r\n        if (pair.length !== 2) throw new Error(\"Expected 'pair' parameter to 'DataFrame.insertPair' to be an array with two elements. The first element is the index, the second is the value.\");\r\n\r\n        return (new DataFrame<IndexT, ValueT>({ pairs: [pair] })).concat(this);\r\n    }\r\n\r\n    /**\r\n     * Append a pair to the end of a dataframe.\r\n     * Doesn't modify the original dataframe! The returned dataframe is entirely new and contains rows from the original dataframe plus the appended pair.\r\n     *\r\n     * @param pair - The pair to append.\r\n     *  \r\n     * @return Returns a new dataframe with the specified pair appended.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const newIndex = ... index of the new row ...\r\n     * const newRow = ... the new data row to append ...\r\n     * const appendedDf = df.appendPair([newIndex, newRows]);\r\n     * </pre>\r\n     */\r\n    appendPair (pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT> {\r\n        if (!isArray(pair)) throw new Error(\"Expected 'pair' parameter to 'DataFrame.appendPair' to be an array.\");\r\n        if (pair.length !== 2) throw new Error(\"Expected 'pair' parameter to 'DataFrame.appendPair' to be an array with two elements. The first element is the index, the second is the value.\");\r\n\r\n        return this.concat(new DataFrame<IndexT, ValueT>({ pairs: [pair] }));\r\n    }\r\n\r\n    /**\r\n     * Removes rows from the dataframe by index.\r\n     */\r\n    remove(index: IndexT): IDataFrame<IndexT, ValueT> {\r\n\r\n        return new DataFrame<IndexT, ValueT>(() => {\r\n            const content = this.getContent();\r\n            return {\r\n                columnNames: content.columnNames,\r\n                pairs: new WhereIterable(content.pairs, pair => pair[0] !== index),\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fill gaps in a dataframe.\r\n     *\r\n     * @param comparer User-defined comparer function that is passed pairA and pairB, two consecutive rows, return truthy if there is a gap between the rows, or falsey if there is no gap.\r\n     * @param generator User-defined generator function that is passed pairA and pairB, two consecutive rows, returns an array of pairs that fills the gap between the rows.\r\n     *\r\n     * @return Returns a new dataframe with gaps filled in.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     *   var sequenceWithGaps = ...\r\n     *\r\n     *  // Predicate that determines if there is a gap.\r\n     *  var gapExists = (pairA, pairB) => {\r\n     *      // Returns true if there is a gap.\r\n     *      return true;\r\n     *  };\r\n     *\r\n     *  // Generator function that produces new rows to fill the game.\r\n     *  var gapFiller = (pairA, pairB) => {\r\n     *      // Create an array of index, value pairs that fill the gaps between pairA and pairB.\r\n     *      return [\r\n     *          newPair1,\r\n     *          newPair2,\r\n     *          newPair3,\r\n     *      ];\r\n     *  };\r\n     *\r\n     *  var sequenceWithoutGaps = sequenceWithGaps.fillGaps(gapExists, gapFiller);\r\n     * </pre>\r\n     */\r\n    fillGaps (comparer: ComparerFn<[IndexT, ValueT], [IndexT, ValueT]>, generator: GapFillFn<[IndexT, ValueT], [IndexT, ValueT]>): IDataFrame<IndexT, ValueT> {\r\n        if (!isFunction(comparer)) throw new Error(\"Expected 'comparer' parameter to 'DataFrame.fillGaps' to be a comparer function that compares two values and returns a boolean.\")\r\n        if (!isFunction(generator)) throw new Error(\"Expected 'generator' parameter to 'DataFrame.fillGaps' to be a generator function that takes two values and returns an array of generated pairs to span the gap.\")\r\n\r\n        return this.rollingWindow(2)\r\n            .selectMany(window => {\r\n                const pairs = window.toPairs();\r\n                const pairA = pairs[0];\r\n                const pairB = pairs[1];\r\n                if (!comparer(pairA, pairB)) {\r\n                    return [pairA];\r\n                }\r\n\r\n                const generatedRows = generator(pairA, pairB);\r\n                if (!isArray(generatedRows)) throw new Error(\"Expected return from 'generator' parameter to 'DataFrame.fillGaps' to be an array of pairs, instead got a \" + typeof(generatedRows));\r\n\r\n                return [pairA].concat(generatedRows);\r\n            })\r\n            .withIndex(pair => pair[0])\r\n            .inflate(pair => pair[1])\r\n            .concat(this.tail(1));\r\n            \r\n    }\r\n\r\n    /**\r\n     * Returns the specified default dataframe if the dataframe is empty. \r\n     *\r\n     * @param defaultDataFrame Default dataframe to return if the dataframe is empty.\r\n     * \r\n     * @return Returns 'defaultDataFrame' if the dataframe is empty. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const emptyDataFrame = new DataFrame();\r\n     * const defaultDataFrame = new DataFrame([ { A: 1 }, { A: 2 }, { A: 3 } ]);\r\n     * expect(emptyDataFrame.defaultIfEmpty(defaultDataFrame)).to.eql(defaultDataFrame);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const nonEmptyDataFrame = new DataFrame([ { A: 100 }]);\r\n     * const defaultDataFrame = new DataFrame([ { A: 1 }, { A: 2 }, { A: 3 } ]);\r\n     * expect(nonEmptyDataFrame.defaultIfEmpty(defaultDataFrame)).to.eql(nonEmptyDataFrame);\r\n     * </pre>\r\n     */\r\n    defaultIfEmpty (defaultDataFrame: ValueT[] | IDataFrame<IndexT, ValueT>): IDataFrame<IndexT, ValueT> {\r\n\r\n        if (this.none()) {\r\n            if (defaultDataFrame instanceof DataFrame) {\r\n                return <IDataFrame<IndexT, ValueT>> defaultDataFrame;\r\n            }\r\n            else if (isArray(defaultDataFrame)) {\r\n                return new DataFrame<IndexT, ValueT>(defaultDataFrame);\r\n            }\r\n            else {\r\n                throw new Error(\"Expected 'defaultSequence' parameter to 'DataFrame.defaultIfEmpty' to be an array or a series.\");\r\n            }\r\n        } \r\n        else {\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detect the the frequency of the types of the values in the dataframe.\r\n     * This is a good way to understand the shape of your data.\r\n     *\r\n     * @return Returns a dataframe with rows that confirm to {@link ITypeFrequency} that describes the data types contained in the original dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = dataForge.readFileSync(\"./my-data.json\").parseJSON();\r\n     * const dataTypes = df.detectTypes();\r\n     * console.log(dataTypes.toString());\r\n     * </pre>\r\n     */\r\n    detectTypes (): IDataFrame<number, ITypeFrequency> {\r\n        return new DataFrame<number, ITypeFrequency>(() => {\r\n            const typeFrequencies = this.getColumns()\r\n                .selectMany(column => {\r\n                    return column.series.detectTypes()\r\n                        .select((typeFrequency: any) => {\r\n                            const output = Object.assign({}, typeFrequency);\r\n                            output.Column = column.name;\r\n                            return output;\r\n                        });\r\n                });\r\n            return {\r\n                columnNames: [\"Type\", \"Frequency\", \"Column\"],\r\n                values: typeFrequencies,\r\n            };\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Detect the frequency of the values in the dataframe.\r\n     * This is a good way to understand the shape of your data.\r\n     *\r\n     * @return Returns a dataframe with rows that conform to {@link IValueFrequency} that describes the values contained in the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const df = dataForge.readFileSync(\"./my-data.json\").parseJSON();\r\n     * const dataValues = df.detectedValues();\r\n     * console.log(dataValues.toString());\r\n     * </pre>\r\n     */\r\n    detectValues (): IDataFrame<number, IValueFrequency> {\r\n        return new DataFrame<number, IValueFrequency>(() => {\r\n            const valueFrequencies = this.getColumns()\r\n                .selectMany(column => {\r\n                    return column.series.detectValues()\r\n                        .select((valueFrequency: any) => {\r\n                            const output = Object.assign({}, valueFrequency);\r\n                            output.Column = column.name;\r\n                            return output;\r\n                        });\r\n                });\r\n            return {\r\n                columnNames: [\"Value\", \"Frequency\", \"Column\"],\r\n                values: valueFrequencies,\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serialize the dataframe to the JSON data format.\r\n     * \r\n     * @return Returns a string in the JSON data format that represents the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const jsonData = df.toJSON();\r\n     * console.log(jsonData);\r\n     * </pre>\r\n     */\r\n    toJSON (): string {\r\n        return JSON.stringify(this.toArray(), null, 4);\r\n    }\r\n\r\n    /**\r\n     * Serialize the dataframe to the JSON5 data format.\r\n     * \r\n     * @return Returns a string in the JSON5 data format that represents the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const jsonData = df.toJSON5();\r\n     * console.log(jsonData);\r\n     * </pre>\r\n     */\r\n    toJSON5 (): string {\r\n        return JSON5.stringify(this.toArray(), null, 4);\r\n    }\r\n\r\n    /**\r\n     * Serialize the dataframe to the CSV data format.\r\n     * \r\n     * @param options Options for CSV output. The options object is passed directly to [PapaParse.unparse](https://www.papaparse.com/docs#unparse), please see [PapaParse docs for additional options](https://www.papaparse.com/docs#unparse-config-default).\r\n     * \r\n     * @return Returns a string in the CSV data format that represents the dataframe.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const csvData = df.toCSV();\r\n     * console.log(csvData);\r\n     * </pre>\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const csvData = df.toCSV({ header: false });\r\n     * console.log(csvData);\r\n     * </pre>\r\n     */\r\n    toCSV (options?: ICSVOutputOptions): string {\r\n        const headerLine = options === undefined || options.header === undefined || options.header\r\n            ? [this.getColumnNames()]\r\n            : []\r\n            ;\r\n        const rows = headerLine.concat(this.toRows());\r\n        return PapaParse.unparse(rows, options);\r\n    }\r\n\r\n    /**\r\n     * Serialize the dataframe to HTML.\r\n     * \r\n     * @return Returns a string in HTML format that represents the dataframe.\r\n     */\r\n    toHTML (): string {\r\n\r\n        const columNames = this.getColumnNames();\r\n        const header = columNames.map(columnName => \"            <th>\" + columnName + \"</th>\").join(\"\\n\");\r\n        const pairs = this.toPairs();\r\n\r\n        return '<table border=\"1\" class=\"dataframe\">\\n' + \r\n            '    <thead>\\n' +\r\n            '        <tr style=\"text-align: right;\">\\n' +\r\n            '            <th></th>\\n' +\r\n\r\n            header +\r\n\r\n            '\\n' +\r\n            '       </tr>\\n' +\r\n            '    </thead>\\n' +\r\n            '    <tbody>\\n' +\r\n\r\n            pairs.map(pair => {\r\n                const index = pair[0];\r\n                const value: any = pair[1];\r\n                return '        <tr>\\n' +\r\n                    '            <th>' + index + '</th>\\n' +\r\n                    columNames.map(columName => {\r\n                            return '            <td>' + value[columName] + '</td>';\r\n                        })\r\n                        .join('\\n') +\r\n                        '\\n' +\r\n                        '        </tr>';\r\n                })\r\n                .join('\\n') +\r\n\r\n            '\\n' +\r\n            '    </tbody>\\n' +\r\n            '</table>';\r\n    }    \r\n\r\n    /**\r\n     * Serialize the dataframe to an ordinary JavaScript data structure.\r\n     * The resulting data structure is suitable for further serialization to JSON and can be used to \r\n     * transmit a DataFrame and its internal structure over the wire.\r\n     * Use the {@link deserialize} function to later reconstitute the serialized dataframe.\r\n     * \r\n     * @return Returns a JavaScript data structure conforming to {@link ISerializedDataFrame} that represents the dataframe and its internal structure.\r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const jsDataStructure = df.serialize();\r\n     * const jsonData = JSON.stringify(jsDataStructure);\r\n     * console.log(jsonData);\r\n     * const deserializedJsDataStructure = JSON.parse(jsonData);\r\n     * const deserializedDf = DataFrame.deserialize(deserializedJsDataStructure); // Reconsituted.\r\n     * </pre>\r\n     */\r\n    serialize (): ISerializedDataFrame {\r\n        let rows = this.toArray(); // Bake the dataframe to an array.\r\n        const index = this.getIndex(); // Extract the index.\r\n        let indexValues = index.head(rows.length).toArray() as any[];\r\n        const columns = this.getColumns();\r\n        const serializedColumns = toMap(columns, column => column.name, column => column.type);\r\n        const indexType = index.getType();\r\n        \r\n        if (indexType === \"date\") {\r\n            indexValues = indexValues.map(index => moment(index).toISOString()); // Manually serialize date value, they aren't supported directly by JSON.\r\n        }\r\n\r\n        let cloned = false;\r\n\r\n        // Serialize date values.\r\n        for (const column of columns) {\r\n            if (column.type === \"date\") {\r\n                if (!cloned) {\r\n                    rows = rows.map(row => Object.assign({}, row)); // Clone so we don't modify any original data.\r\n                    cloned = true;\r\n                }\r\n\r\n                for (const row of rows) {\r\n                    row[column.name] = moment(row[column.name]).toISOString(); // Manually serialize date value.\r\n                }\r\n            }\r\n        }\r\n        \r\n        return {\r\n            columnOrder: this.getColumnNames(),\r\n            columns: serializedColumns,\r\n            index: {\r\n                type: indexType,\r\n                values: indexValues,\r\n            },\r\n            values: rows,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Deserialize the dataframe from an ordinary JavaScript data structure.\r\n     * Can reconstitute a dataframe that previously serialized with the {@link serialize} function.\r\n     * This can rebuilds the dataframe with the exact same internal structure after it has been transmitted over the wire.\r\n     * \r\n     * @param input The serialize JavaScript data structure for the dataframe.\r\n     * \r\n     * @return Returns the deserialized/reconstituted dataframe.    \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * const jsDataStructure = df.serialize();\r\n     * const jsonData = JSON.stringify(jsDataStructure);\r\n     * console.log(jsonData);\r\n     * const deserializedJsDataStructure = JSON.parse(jsonData);\r\n     * const deserializedDf = DataFrame.deserialize(deserializedJsDataStructure); // Reconsituted.\r\n     * </pre>\r\n     */\r\n    static deserialize<IndexT = any,  ValueT = any> (input: ISerializedDataFrame): IDataFrame<IndexT, ValueT> {\r\n\r\n        let indexValues = input.index && input.index.values || [];\r\n        let rows = input.values && input.values || [];\r\n        let cloned = false;\r\n\r\n        // Deserialize dates.\r\n        if (input.columns) {\r\n            for (const columnName of Object.keys(input.columns)) {\r\n                if (input.columns[columnName] !== \"date\") {\r\n                    continue; // No need to process other types, they are natively supported by JSON.\r\n                }\r\n\r\n                if (!cloned) {\r\n                    rows = rows.map(row => Object.assign({}, row)); // Clone so we don't modify any original data.\r\n                    cloned = true;\r\n                }\r\n    \r\n                for (const row of rows) {\r\n                    row[columnName] = moment(row[columnName]).toDate(); // Manually deserialize data value.\r\n                }\r\n            }\r\n        }\r\n\r\n        if (input.index && input.index.type === \"date\") {\r\n            indexValues = indexValues.map(value => moment(value).toDate()); // Manually deserialize data value.\r\n        }\r\n\r\n        return new DataFrame<IndexT, ValueT>({\r\n            columnNames: input.columnOrder || [],\r\n            index: indexValues,\r\n            values: rows,\r\n        });\r\n    }\r\n\r\n    /***\r\n     * Allows the dataframe to be queried to confirm that it is actually a dataframe.\r\n     * Used from JavaScript to tell the difference between a Series and a DataFrame.\r\n     * \r\n     * @return Returns the string \"dataframe\".\r\n     */\r\n    getTypeCode (): string {\r\n        return \"dataframe\";\r\n    }\r\n}\r\n\r\n/**\r\n * @hidden\r\n * The configuration for an ordered dataframe.\r\n */\r\ninterface IOrderedDataFrameConfig<IndexT, ValueT, SortT> {\r\n    //\r\n    // The order of columns for the data frame.\r\n    //\r\n    columnNames: string[] | Iterable<string>;\r\n\r\n    //\r\n    // The source values for the ordered dataframe.\r\n    //\r\n    values: Iterable<ValueT>;\r\n\r\n    //\r\n    // The source pairs (index,value) for the ordered dataframe.\r\n    //\r\n    pairs: Iterable<[IndexT, ValueT]>;\r\n\r\n    //\r\n    // The selector used to get the sorting key for the orderby operation.\r\n    //\r\n    selector: SelectorWithIndexFn<ValueT, SortT>;\r\n\r\n    //\r\n    // The sort direction, ascending or descending.\r\n    //\r\n    direction: Direction;\r\n\r\n    //\r\n    // The parent dataframe in the orderby operation or null if none.\r\n    //\r\n    parent: OrderedDataFrame<IndexT, ValueT, any> | null;\r\n}\r\n\r\n/**\r\n * @hidden\r\n * Represents a dataframe that has been sorted.\r\n */\r\nclass OrderedDataFrame<IndexT = number, ValueT = any, SortT = any> \r\n    extends DataFrame<IndexT, ValueT>\r\n    implements IOrderedDataFrame<IndexT, ValueT, SortT> {\r\n\r\n    //\r\n    // Configuration for the ordered dataframe.\r\n    //\r\n    private config: IOrderedDataFrameConfig<IndexT, ValueT, SortT>;\r\n\r\n    //\r\n    // Helper function to create a sort spec.\r\n    //\r\n    private static makeSortSpec (sortLevel: number, selector: SortSelectorFn, direction: Direction): ISortSpec {\r\n        return { sortLevel: sortLevel, selector: selector, direction: direction };\r\n    }\r\n\r\n    //\r\n    // Helper function to make a sort selector for pairs, this captures the parent correct when generating the closure.\r\n    //\r\n    private static makePairsSelector (selector: SortSelectorFn): SortSelectorFn {\r\n        return (pair: any, index: number) => selector(pair[1], index);\r\n    }\r\n\r\n    constructor(config: IOrderedDataFrameConfig<IndexT, ValueT, SortT>) {\r\n\r\n        const valueSortSpecs: ISortSpec[] = [];\r\n        const pairSortSpecs: ISortSpec[] = [];\r\n        let sortLevel = 0;\r\n\r\n        let parent = config.parent;\r\n        const parents = [];\r\n        while (parent !== null) {\r\n            parents.push(parent);\r\n            parent = parent.config.parent;\r\n        }\r\n\r\n        parents.reverse();\r\n\r\n        for (const parent of parents) {\r\n            const parentConfig = parent.config;\r\n            valueSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, parentConfig.selector, parentConfig.direction));\r\n            pairSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, OrderedDataFrame.makePairsSelector(parentConfig.selector), parentConfig.direction));\r\n            ++sortLevel;\r\n        }\r\n\r\n        valueSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, config.selector, config.direction));\r\n        pairSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, OrderedDataFrame.makePairsSelector(config.selector), config.direction));\r\n\r\n        super({\r\n            columnNames: config.columnNames,\r\n            values: new OrderedIterable(config.values, valueSortSpecs),\r\n            pairs: new OrderedIterable(config.pairs, pairSortSpecs)\r\n        });\r\n\r\n        this.config = config;\r\n    }\r\n\r\n    /** \r\n     * Applys additional sorting (ascending) to an already sorted dataframe.\r\n     * \r\n     * @param selector User-defined selector that selects the additional value to sort by.\r\n     * \r\n     * @return Returns a new dataframe has been additionally sorted by the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Order sales by salesperson and then by amount (from least to most).\r\n     * const orderedDf = salesDf.orderBy(sale => sale.SalesPerson).thenBy(sale => sale.Amount);\r\n     * </pre>\r\n     */\r\n    thenBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT> {\r\n        return new OrderedDataFrame<IndexT, ValueT, SortT>({\r\n            columnNames: this.config.columnNames,\r\n            values: this.config.values, \r\n            pairs: this.config.pairs, \r\n            selector: selector, \r\n            direction: Direction.Ascending, \r\n            parent: this,\r\n        });\r\n    }\r\n\r\n    /** \r\n     * Applys additional sorting (descending) to an already sorted dataframe.\r\n     * \r\n     * @param selector User-defined selector that selects the additional value to sort by.\r\n     * \r\n     * @return Returns a new dataframe has been additionally sorted by the value chosen by the selector function. \r\n     * \r\n     * @example\r\n     * <pre>\r\n     * \r\n     * // Order sales by salesperson and then by amount (from most to least).\r\n     * const orderedDf = salesDf.orderBy(sale => sale.SalesPerson).thenByDescending(sale => sale.Amount);\r\n     * </pre>\r\n     */\r\n    thenByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT> {\r\n        return new OrderedDataFrame<IndexT, ValueT, SortT>({\r\n            columnNames: this.config.columnNames,\r\n            values: this.config.values, \r\n            pairs: this.config.pairs, \r\n            selector: selector, \r\n            direction: Direction.Descending, \r\n            parent: this,\r\n        });\r\n    }\r\n}\r\n","export { Index, IIndex } from './lib/index';\r\nexport { Series, ISeries, SelectorWithIndexFn } from './lib/series';\r\nexport { DataFrame, IDataFrame } from './lib/dataframe';\r\nimport { ArrayIterable } from './lib/iterables/array-iterable';\r\nimport { CsvRowsIterable } from './lib/iterables/csv-rows-iterable';\r\nimport { Series, ISeries } from '.';\r\nimport { DataFrame, IDataFrame } from '.';\r\nimport { isString, isObject, isArray, isNumber } from './lib/utils';\r\nimport { isFunction } from 'util';\r\nimport JSON5 from 'json5';\r\n// @ts-ignore\r\nimport moment from \"dayjs\";\r\n// @ts-ignore\r\nimport customParseFormat from 'dayjs/plugin/customParseFormat';\r\nmoment.extend(customParseFormat);\r\n\r\n// @ts-ignore\r\nimport PapaParse from 'papaparse';\r\n\r\n/**\r\n * Represents a field from a JavaScript object.\r\n */\r\nexport interface IFieldRecord {\r\n    /**\r\n     * The name of the field.\r\n     */\r\n    Field: string;\r\n\r\n    /**\r\n     * The value of the field.\r\n     */\r\n    Value: any;\r\n}\r\n\r\n/**\r\n * Convert a regular JavaScript obejct to a dataframe.\r\n * Each row in the dataframe represents a field from the object.\r\n * \r\n * @param obj - The JavaScript object to convert to a dataframe.\r\n * \r\n * @returns Returns a dataframe that lists the fields in the pass-in object.\r\n */\r\nexport function fromObject (obj: any): IDataFrame<number, IFieldRecord> {\r\n    return new DataFrame<number, IFieldRecord>(\r\n        Object.keys(obj)\r\n            .map(fieldName => ({\r\n                Field: fieldName,\r\n                Value: obj[fieldName],\r\n            }))\r\n    );\r\n}\r\n\r\n/**\r\n * Deserialize a dataframe from a JSON text string.\r\n *\r\n * @param jsonTextString The JSON text to deserialize.\r\n * \r\n * @returns Returns a dataframe that has been deserialized from the JSON data.\r\n */\r\nexport function fromJSON (jsonTextString: string): IDataFrame<number, any> {\r\n    \r\n    if (!isString(jsonTextString)) throw new Error(\"Expected 'jsonTextString' parameter to 'dataForge.fromJSON' to be a string containing data encoded in the JSON format.\");\r\n\r\n    return new DataFrame<number, any>({\r\n        values: JSON.parse(jsonTextString)\r\n    });\r\n}\r\n\r\n/**\r\n * Deserialize a dataframe from a JSON5 text string.\r\n *\r\n * @param jsonTextString The JSON5 text to deserialize.\r\n * \r\n * @returns Returns a dataframe that has been deserialized from the JSON data.\r\n */\r\nexport function fromJSON5 (jsonTextString: string): IDataFrame<number, any> {\r\n    \r\n    if (!isString(jsonTextString)) throw new Error(\"Expected 'jsonTextString' parameter to 'dataForge.fromJSON5' to be a string containing data encoded in the JSON5 format.\");\r\n\r\n    return new DataFrame<number, any>({\r\n        values: JSON5.parse(jsonTextString)\r\n    });\r\n}\r\n\r\n/**\r\n * Options for parsing CSV data.\r\n */\r\nexport interface ICSVOptions {\r\n    /**\r\n     * Optionally specifies the column names (when enabled, assumes that the header row is not read from the CSV data).\r\n     * Default: undefined\r\n     */\r\n    columnNames?: Iterable<string>;\r\n\r\n    /**\r\n     * Automatically pick types based on what the value looks like.\r\n     * Default: false.\r\n     */\r\n    dynamicTyping?: boolean;\r\n\r\n    /**\r\n     * Skip empty lines in the input.\r\n     * Default: true\r\n     */\r\n    skipEmptyLines?: boolean;\r\n}\r\n\r\n/**\r\n * Deserialize a DataFrame from a CSV text string.\r\n *\r\n * @param csvTextString The CSV text to deserialize.\r\n * @param config Optional configuration options for parsing the CSV data. \r\n * The config object is passed directly to [PapaParse.parse](https://www.papaparse.com/docs#strings), please see [PapaParse docs for additional options](https://www.papaparse.com/docs#config).\r\n * \r\n * @returns Returns a dataframe that has been deserialized from the CSV data.\r\n */\r\nexport function fromCSV (csvTextString: string, config?: ICSVOptions) {\r\n    if (!isString(csvTextString)) throw new Error(\"Expected 'csvTextString' parameter to 'dataForge.fromCSV' to be a string containing data encoded in the CSV format.\");\r\n\r\n    if (config) {\r\n        if (!isObject(config)) throw new Error(\"Expected 'config' parameter to 'dataForge.fromCSV' to be an object with CSV parsing configuration options.\");\r\n\r\n        if (config.columnNames) {\r\n            if (!isFunction(config.columnNames[Symbol.iterator])) {\r\n                if (!isArray(config.columnNames)) throw new Error(\"Expect 'columnNames' field of 'config' parameter to DataForge.fromCSV to be an array or iterable of strings that specifies column names.\")\r\n            }\r\n\r\n\r\n            for (const columnName of config.columnNames) {\r\n                if (!isString(columnName)) throw new Error(\"Expect 'columnNames' field of 'config' parameter to DataForge.fromCSV to be an array of strings that specify column names.\")\r\n            }\r\n        }\r\n        \r\n        if (config.skipEmptyLines === undefined) {\r\n            config = Object.assign({}, config); // Clone the config. Don't want to modify the original.\r\n            config.skipEmptyLines = true;\r\n        }\r\n    }\r\n    else {\r\n        config = {\r\n            skipEmptyLines: true,\r\n        }\r\n    }\r\n\r\n    const parsed = PapaParse.parse(csvTextString, config as any);\r\n    let rows = <string[][]> parsed.data;\r\n\r\n    if (rows.length === 0) {\r\n        return new DataFrame<number, any>();\r\n    }\r\n\r\n    let columnNames;\r\n    rows = rows.map(row => {\r\n            return row.map(cell => isString(cell) ? cell.trim() : cell); // Trim each cell that is still a string.\r\n        });\r\n\r\n    if (config && config.columnNames) {\r\n        columnNames = config.columnNames;\r\n    }\r\n    else {\r\n        columnNames = rows.shift();\r\n    }\r\n\r\n    return new DataFrame<number, any>({\r\n        rows: rows,\r\n        columnNames: columnNames,\r\n    });\r\n}\r\n\r\nconst concat = Series.concat;\r\n\r\n/**\r\n * Concatenate multiple series into a single series.\r\n * THIS FUNCTION IS DEPRECATED. Instead use dataFrame.Series.concat.\r\n * \r\n * @param {array} series - Array of series to concatenate.\r\n *\r\n * @returns {Series} - Returns the single concatendated series.  \r\n */\r\nexport { concat as concatSeries };\r\n\r\nconst zip = Series.zip;\r\n\r\n/**\r\n * Zip together multiple series to create a new series.\r\n * THIS FUNCTION IS DEPRECATED. Instead use dataFrame.Series.zip.\r\n *\r\n * @param {array} series - Array of series to zip together.\r\n * @param {function} selector - Selector function that produces a new series based on the input series.\r\n * \r\n * @returns {Series} Returns a single series that is the combination of multiple input series that have been 'zipped' together by the 'selector' function.\r\n */\r\nexport { zip as zipSeries }\r\n\r\n/**\r\n * Generate a series from a range of numbers.\r\n *\r\n * @param start - The value of the first number in the range.\r\n * @param count - The number of sequential values in the range.\r\n * \r\n * @returns Returns a series with a sequence of generated values. The series contains 'count' values beginning at 'start'. \r\n */\r\nexport function range (start: number, count: number): ISeries<number, number> {\r\n\r\n    if (!isNumber(start)) throw new Error(\"Expect 'start' parameter to 'dataForge.range' function to be a number.\");\r\n    if (!isNumber(count)) throw new Error(\"Expect 'count' parameter to 'dataForge.range' function to be a number.\");\r\n\r\n    const values: number[] = [];\r\n    for (let valueIndex = 0; valueIndex < count; ++valueIndex) {\r\n        values.push(start + valueIndex);\r\n    }\r\n\r\n    return new Series<number, number>(values);\r\n}\r\n\r\n/**\r\n * Replicate a particular value N times to create a series.\r\n * \r\n * @param value The value to replicate.\r\n * @param count The number of times to replicate the value.\r\n * \r\n * @returns Returns a new series that contains N copies of the value.\r\n */\r\nexport function replicate<ValueT> (value: ValueT, count: number): ISeries<number, ValueT> {\r\n    const values: ValueT[] = [];\r\n    for (let i = 0; i < count; ++i) {\r\n        values.push(value);\r\n    }\r\n\r\n    return new Series<number, ValueT>(values);\r\n}\r\n\r\n/**\r\n * Generate a data-frame containing a matrix of values.\r\n *\r\n * @param numColumns - The number of columns in the data-frame.\r\n * @param numRows - The number of rows in the data-frame.\r\n * @param start - The starting value.\r\n * @param increment - The value to increment by for each new value.\r\n * \r\n * @returns Returns a dataframe that contains a matrix of generated values.\r\n */\r\nexport function matrix (numColumns: number, numRows: number, start: number, increment: number): IDataFrame<number, any> {\r\n    if (!isNumber(numColumns)) throw new Error(\"Expect 'numColumns' parameter to 'dataForge.matrix' function to be a number.\");\r\n    if (!isNumber(numRows)) throw new Error(\"Expect 'numRows' parameter to 'dataForge.matrix' function to be a number.\");\r\n    if (!isNumber(start)) throw new Error(\"Expect 'start' parameter to 'dataForge.matrix' function to be a number.\");\r\n    if (!isNumber(increment)) throw new Error(\"Expect 'increment' parameter to 'dataForge.matrix' function to be a number.\");\r\n\r\n    const rows: number[][] = [];\r\n    const columnNames: string[] = [];\r\n    var nextValue = start;\r\n\r\n    for (let colIndex = 0; colIndex < numColumns; ++colIndex) {\r\n        columnNames.push((colIndex+1).toString());\r\n    }\r\n    \r\n    for (let rowIndex = 0; rowIndex < numRows; ++rowIndex) {\r\n        var row: number[] = [];\r\n\r\n        for (let colIndex = 0; colIndex < numColumns; ++colIndex) {\r\n            row.push(nextValue + (colIndex * increment));\r\n        }\r\n\r\n        nextValue += numColumns * increment;\r\n        rows.push(row);\r\n    }\r\n\r\n    return new DataFrame({\r\n        columnNames: columnNames,\r\n        rows: rows,\r\n    });\r\n}\r\n","!function(t,n){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=n():\"function\"==typeof define&&define.amd?define(n):t.dayjs=n()}(this,function(){\"use strict\";var t=\"millisecond\",n=\"second\",e=\"minute\",i=\"hour\",r=\"day\",s=\"week\",u=\"month\",a=\"quarter\",o=\"year\",h=/^(\\d{4})-?(\\d{1,2})-?(\\d{0,2})[^0-9]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?.?(\\d{1,3})?$/,f=/\\[([^\\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,c=function(t,n,e){var i=String(t);return!i||i.length>=n?t:\"\"+Array(n+1-i.length).join(e)+t},d={s:c,z:function(t){var n=-t.utcOffset(),e=Math.abs(n),i=Math.floor(e/60),r=e%60;return(n<=0?\"+\":\"-\")+c(i,2,\"0\")+\":\"+c(r,2,\"0\")},m:function(t,n){var e=12*(n.year()-t.year())+(n.month()-t.month()),i=t.clone().add(e,u),r=n-i<0,s=t.clone().add(e+(r?-1:1),u);return Number(-(e+(n-i)/(r?i-s:s-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(h){return{M:u,y:o,w:s,d:r,h:i,m:e,s:n,ms:t,Q:a}[h]||String(h||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},$={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\")},l=\"en\",m={};m[l]=$;var y=function(t){return t instanceof S},M=function(t,n,e){var i;if(!t)return null;if(\"string\"==typeof t)m[t]&&(i=t),n&&(m[t]=n,i=t);else{var r=t.name;m[r]=t,i=r}return e||(l=i),i},g=function(t,n,e){if(y(t))return t.clone();var i=n?\"string\"==typeof n?{format:n,pl:e}:n:{};return i.date=t,new S(i)},D=d;D.l=M,D.i=y,D.w=function(t,n){return g(t,{locale:n.$L,utc:n.$u})};var S=function(){function c(t){this.$L=this.$L||M(t.locale,null,!0)||l,this.parse(t)}var d=c.prototype;return d.parse=function(t){this.$d=function(t){var n=t.date,e=t.utc;if(null===n)return new Date(NaN);if(D.u(n))return new Date;if(n instanceof Date)return new Date(n);if(\"string\"==typeof n&&!/Z$/i.test(n)){var i=n.match(h);if(i)return e?new Date(Date.UTC(i[1],i[2]-1,i[3]||1,i[4]||0,i[5]||0,i[6]||0,i[7]||0)):new Date(i[1],i[2]-1,i[3]||1,i[4]||0,i[5]||0,i[6]||0,i[7]||0)}return new Date(n)}(t),this.init()},d.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},d.$utils=function(){return D},d.isValid=function(){return!(\"Invalid Date\"===this.$d.toString())},d.isSame=function(t,n){var e=g(t);return this.startOf(n)<=e&&e<=this.endOf(n)},d.isAfter=function(t,n){return g(t)<this.startOf(n)},d.isBefore=function(t,n){return this.endOf(n)<g(t)},d.$g=function(t,n,e){return D.u(t)?this[n]:this.set(e,t)},d.year=function(t){return this.$g(t,\"$y\",o)},d.month=function(t){return this.$g(t,\"$M\",u)},d.day=function(t){return this.$g(t,\"$W\",r)},d.date=function(t){return this.$g(t,\"$D\",\"date\")},d.hour=function(t){return this.$g(t,\"$H\",i)},d.minute=function(t){return this.$g(t,\"$m\",e)},d.second=function(t){return this.$g(t,\"$s\",n)},d.millisecond=function(n){return this.$g(n,\"$ms\",t)},d.unix=function(){return Math.floor(this.valueOf()/1e3)},d.valueOf=function(){return this.$d.getTime()},d.startOf=function(t,a){var h=this,f=!!D.u(a)||a,c=D.p(t),d=function(t,n){var e=D.w(h.$u?Date.UTC(h.$y,n,t):new Date(h.$y,n,t),h);return f?e:e.endOf(r)},$=function(t,n){return D.w(h.toDate()[t].apply(h.toDate(),(f?[0,0,0,0]:[23,59,59,999]).slice(n)),h)},l=this.$W,m=this.$M,y=this.$D,M=\"set\"+(this.$u?\"UTC\":\"\");switch(c){case o:return f?d(1,0):d(31,11);case u:return f?d(1,m):d(0,m+1);case s:var g=this.$locale().weekStart||0,S=(l<g?l+7:l)-g;return d(f?y-S:y+(6-S),m);case r:case\"date\":return $(M+\"Hours\",0);case i:return $(M+\"Minutes\",1);case e:return $(M+\"Seconds\",2);case n:return $(M+\"Milliseconds\",3);default:return this.clone()}},d.endOf=function(t){return this.startOf(t,!1)},d.$set=function(s,a){var h,f=D.p(s),c=\"set\"+(this.$u?\"UTC\":\"\"),d=(h={},h[r]=c+\"Date\",h.date=c+\"Date\",h[u]=c+\"Month\",h[o]=c+\"FullYear\",h[i]=c+\"Hours\",h[e]=c+\"Minutes\",h[n]=c+\"Seconds\",h[t]=c+\"Milliseconds\",h)[f],$=f===r?this.$D+(a-this.$W):a;if(f===u||f===o){var l=this.clone().set(\"date\",1);l.$d[d]($),l.init(),this.$d=l.set(\"date\",Math.min(this.$D,l.daysInMonth())).toDate()}else d&&this.$d[d]($);return this.init(),this},d.set=function(t,n){return this.clone().$set(t,n)},d.get=function(t){return this[D.p(t)]()},d.add=function(t,a){var h,f=this;t=Number(t);var c=D.p(a),d=function(n){var e=new Date(f.$d);return e.setDate(e.getDate()+n*t),D.w(e,f)};if(c===u)return this.set(u,this.$M+t);if(c===o)return this.set(o,this.$y+t);if(c===r)return d(1);if(c===s)return d(7);var $=(h={},h[e]=6e4,h[i]=36e5,h[n]=1e3,h)[c]||1,l=this.valueOf()+t*$;return D.w(l,this)},d.subtract=function(t,n){return this.add(-1*t,n)},d.format=function(t){var n=this;if(!this.isValid())return\"Invalid Date\";var e=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=D.z(this),r=this.$locale(),s=r.weekdays,u=r.months,a=function(t,n,e,i){return t&&t[n]||e[n].substr(0,i)},o=function(t){return D.s(n.$H%12||12,t,\"0\")},h={YY:String(this.$y).slice(-2),YYYY:String(this.$y),M:String(this.$M+1),MM:D.s(this.$M+1,2,\"0\"),MMM:a(r.monthsShort,this.$M,u,3),MMMM:u[this.$M],D:String(this.$D),DD:D.s(this.$D,2,\"0\"),d:String(this.$W),dd:a(r.weekdaysMin,this.$W,s,2),ddd:a(r.weekdaysShort,this.$W,s,3),dddd:s[this.$W],H:String(this.$H),HH:D.s(this.$H,2,\"0\"),h:o(1),hh:o(2),a:this.$H<12?\"am\":\"pm\",A:this.$H<12?\"AM\":\"PM\",m:String(this.$m),mm:D.s(this.$m,2,\"0\"),s:String(this.$s),ss:D.s(this.$s,2,\"0\"),SSS:D.s(this.$ms,3,\"0\"),Z:i};return e.replace(f,function(t,n){return n||h[t]||i.replace(\":\",\"\")})},d.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},d.diff=function(t,h,f){var c,d=D.p(h),$=g(t),l=6e4*($.utcOffset()-this.utcOffset()),m=this-$,y=D.m(this,$);return y=(c={},c[o]=y/12,c[u]=y,c[a]=y/3,c[s]=(m-l)/6048e5,c[r]=(m-l)/864e5,c[i]=m/36e5,c[e]=m/6e4,c[n]=m/1e3,c)[d]||m,f?y:D.a(y)},d.daysInMonth=function(){return this.endOf(u).$D},d.$locale=function(){return m[this.$L]},d.locale=function(t,n){if(!t)return this.$L;var e=this.clone();return e.$L=M(t,n,!0),e},d.clone=function(){return D.w(this.toDate(),this)},d.toDate=function(){return new Date(this.$d)},d.toJSON=function(){return this.toISOString()},d.toISOString=function(){return this.$d.toISOString()},d.toString=function(){return this.$d.toUTCString()},c}();return g.prototype=S.prototype,g.extend=function(t,n){return t(n,S,g),g},g.locale=M,g.isDayjs=y,g.unix=function(t){return g(1e3*t)},g.en=m[l],g.Ls=m,g});\n","// @ts-ignore\r\nimport t from \"typy\";\r\n\r\n//\r\n// Various shared utility functions.\r\n//\r\n\r\nexport function* mapIterable<InT, OutT> (items: Iterable<InT>, mapFn: (item: InT) => OutT): Iterable<OutT> {\r\n    const iterator = items[Symbol.iterator]();\r\n    while (true) {\r\n        const result = iterator.next();\r\n        if (result.done) {\r\n            break;\r\n        }\r\n        yield mapFn(result.value);\r\n    }\r\n}\r\n\r\n//\r\n// Helper function to only return distinct items.\r\n//\r\nexport function makeDistinct<ItemT, KeyT>(items: Iterable<ItemT>, selector?: (item: ItemT) => KeyT): ItemT[] {\r\n    const set: any = {};\r\n    const output: any[] = [];\r\n    for (const item of items) {\r\n        var key = selector && selector(item) || item;\r\n        if (!set[key]) {\r\n            // Haven't yet seen this key.\r\n            set[key] = true;\r\n            output.push(item);\r\n        }\r\n    }\r\n\r\n    return output;\r\n}\r\n\r\n//\r\n// Helper function to map an array of objects.\r\n//\r\nexport function toMap<InT, KeyT, ValueT>(items: Iterable<InT>, keySelector: (item: InT) => KeyT, valueSelector: (item: InT) => ValueT): any {\r\n    const output: any = {};\r\n    for (const item of items) {\r\n        var key = keySelector(item);\r\n        output[key] = valueSelector(item);\r\n    }\r\n    return output;\r\n}\r\n\r\n//\r\n// Helper function to map an array of objects.\r\n//\r\nexport function toMap2<InT, KeyT, ValueT>(items: Iterable<InT>, keySelector: (item: InT) => KeyT, valueSelector: (item: InT) => ValueT): Map<KeyT, ValueT> {\r\n    const output = new Map<KeyT, ValueT>();\r\n    for (const item of items) {\r\n        output.set(keySelector(item), valueSelector(item));\r\n    }\r\n    return output;\r\n}\r\n\r\n//\r\n// Determine the type of a value.\r\n//\r\nexport function determineType (value: any): string {\r\n    if (value === undefined) {\r\n        return \"undefined\";\r\n    }\r\n    else if (isNumber(value)) {\r\n        return \"number\";\r\n    }\r\n    else if (isString(value)) {\r\n        return \"string\";\r\n    }\r\n    else if (value instanceof Date) {\r\n        return \"date\";\r\n    }\r\n    else if (isBoolean(value)) {\r\n        return \"boolean\";\r\n    }\r\n    else {\r\n        return \"unsupported\";\r\n    }\r\n}\r\n\r\nexport function isObject(v: any): boolean {\r\n    return t(v).isObject && !isDate(v);\r\n}\r\n\r\nexport function isFunction(v: any): v is Function {\r\n    return t(v).isFunction;\r\n}\r\n\r\nexport function isString(v: any): v is string {\r\n    return t(v).isString;\r\n}\r\n\r\nexport function isDate(v: any): v is Date {\r\n    return Object.prototype.toString.call(v) === \"[object Date]\";\r\n}\r\n\r\nexport function isBoolean(v: any): v is boolean {\r\n    return t(v).isBoolean;\r\n}\r\n\r\nexport function isNumber(v: any): v is number {\r\n    return t(v).isNumber;\r\n}\r\n\r\nexport function isArray(v: any): v is Array<any> {\r\n    return t(v).isArray;\r\n}\r\n\r\nexport function isUndefined(v: any): boolean {\r\n    return v === undefined;\r\n}\r\n","import { ISeries, Series, SeriesConfigFn } from './series';\r\n// @ts-ignore\r\nimport moment from \"dayjs\";\r\nimport { determineType } from './utils';\r\n\r\n/**\r\n * A predicate function for testing a value against another.\r\n */\r\nexport type PredicateFn = (value: any, against: any) => boolean;\r\n\r\n/**\r\n * Interface that represents an index for a Series.\r\n */\r\nexport interface IIndex<IndexT> extends ISeries<number, IndexT> {\r\n\r\n    /**\r\n     * Get the type of the index.\r\n     * \r\n     * @returns Returns a string that specifies the type of the index.\r\n     */\r\n    getType (): string;\r\n\r\n    /**\r\n     * Get the less than operation for the index.\r\n     * \r\n     * @returns Returns a function that can be used to compare a value against an index value.\r\n     */\r\n    getLessThan (): PredicateFn;\r\n\r\n    /**\r\n     * Get the less than or equal to operation for the index.\r\n     * \r\n     * @returns Returns a function that can be used to compare a value against an index value.\r\n     */\r\n    getLessThanOrEqualTo (): PredicateFn;\r\n\r\n    /**\r\n     * Get the greater than operation for the index.\r\n     * \r\n     * @returns Returns a function that can be used to compare a value against an index value.\r\n     */\r\n    getGreaterThan (): PredicateFn;\r\n    \r\n}\r\n\r\n/**\r\n * Class that represents an index for a Series.\r\n */\r\nexport class Index<IndexT> extends Series<number, IndexT> implements IIndex<IndexT> {\r\n\r\n    //\r\n    // Records the type of the index.\r\n    //\r\n    private _type?: string;\r\n\r\n    constructor(config?: any | SeriesConfigFn<number, IndexT>) {\r\n        super(config);\r\n    }\r\n\r\n    /**\r\n     * Get the type of the index.\r\n     * \r\n     * @returns Returns a string that specifies the type of the index.\r\n     */\r\n    getType (): string {\r\n\r\n        if (!this._type) {\r\n            //\r\n            // Detect the type.\r\n            //\r\n            if (this.any()) {\r\n                this._type = determineType(this.first());\r\n            }\r\n            else {\r\n                this._type = 'empty';\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Get the less than operation for the index.\r\n     * \r\n     * @returns Returns a function that can be used to compare a value against an index value.\r\n     */\r\n    getLessThan (): PredicateFn {\r\n\r\n        switch (this.getType()) {\r\n            case \"date\":\r\n                return (d1: Date, d2: Date) => moment(d1).isBefore(d2);\r\n\r\n            case \"string\":\r\n            case \"number\":\r\n                return (v1: any, v2: any) => v1 < v2;\r\n\r\n            case \"empty\":\r\n                return () => true; // Series is empty, so this makes no difference.\r\n\r\n            default:\r\n                throw new Error(\"No less than operation available for type: \" + this.getType());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the less than or equal to operation for the index.\r\n     * \r\n     * @returns Returns a function that can be used to compare a value against an index value.\r\n     */\r\n    getLessThanOrEqualTo (): PredicateFn {\r\n        return (v1: any, v2: any) => !this.getGreaterThan()(v1, v2); //TODO: Should expand  this out.\r\n    }\r\n    \r\n    /**\r\n     * Get the greater than operation for the index.\r\n     * \r\n     * @returns Returns a function that can be used to compare a value against an index value.\r\n     */\r\n    getGreaterThan (): PredicateFn {\r\n\r\n        switch (this.getType()) {\r\n            case \"date\":\r\n                return (d1: Date, d2: Date) => moment(d1).isAfter(d2);\r\n\r\n            case \"string\":\r\n            case \"number\":\r\n                return (v1: any, v2: any) => v1 > v2;\r\n\r\n            case \"empty\":\r\n                return () => true; // Series is empty, so this makes no difference.\r\n\r\n            default:\r\n                throw new Error(\"No greater than operation available for type: \" + this.getType());\r\n        }\r\n    }\r\n\r\n}\r\n","//\r\n// An iterator that iterates the elements of an array.\r\n//\r\n\r\nexport class ArrayIterator<T> implements Iterator<T> {\r\n\r\n    arr: T[];\r\n\r\n    index = 0;\r\n\r\n    constructor(arr: T[]) {\r\n        this.arr = arr;\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n        if (this.index < this.arr.length) {\r\n            return {\r\n                done: false, \r\n                value: this.arr[this.index++],\r\n            };\r\n        }\r\n        else {\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<T>)  // <= explicit cast here!;\r\n        }\r\n    }\r\n\r\n}","//\r\n// An iterable that returns no values.\r\n//\r\n\r\nimport { EmptyIterator } from '../iterators/empty-iterator';\r\n\r\nexport class EmptyIterable implements Iterable<any> {\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        return new EmptyIterator();\r\n    }\r\n}","//\r\n// An iterable that simply counts up from zero.\r\n// This creates the default index in Data-Forge.\r\n//\r\n\r\nimport { CountIterator } from '../iterators/count-iterator';\r\n\r\nexport class CountIterable implements Iterable<any> {\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        return new CountIterator();\r\n    }\r\n}","//\r\n// An iterable that allows multiple other iterables to be iterated at once.\r\n// This allows iterables to be composed.\r\n// This is used in Data-Forge to combine iterables for index and values.\r\n//\r\n\r\nimport { MultiIterator } from '../iterators/multi-iterator';\r\n\r\nexport class MultiIterable implements Iterable<any[]> {\r\n\r\n    iterables: Iterable<any>[];\r\n\r\n    constructor(iterables: Iterable<any>[]) {\r\n        this.iterables = iterables;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var iterators: Iterator<any>[] = [];\r\n\r\n        for (const iterable of this.iterables) {\r\n            iterators.push(iterable[Symbol.iterator]());\r\n        }\r\n\r\n        return new MultiIterator(iterators);\r\n    }\r\n}","//\r\n// An iterable that applies a selector function to each item.\r\n//\r\n\r\nimport { SelectorFn, SelectIterator } from '../iterators/select-iterator';\r\n\r\nexport class SelectIterable<ValueT, ToT> implements Iterable<ToT> {\r\n\r\n    iterable: Iterable<ValueT>;\r\n    selector: SelectorFn<ValueT, ToT>;\r\n\r\n    constructor(iterable: Iterable<ValueT>, selector: SelectorFn<ValueT, ToT>) {\r\n        this.iterable = iterable;\r\n        this.selector = selector;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<ToT> {\r\n        var iterator = this.iterable[Symbol.iterator]();\r\n        return new SelectIterator<ValueT, ToT>(iterator, this.selector);\r\n    }\r\n}","//\r\n// An iterable that applies a selector function to each item.\r\n//\r\n\r\nimport { SelectorFn, SelectManyIterator } from '../iterators/select-many-iterator';\r\n\r\nexport class SelectManyIterable<ValueT, ToT> implements Iterable<ToT> {\r\n\r\n    iterable: Iterable<ValueT>;\r\n    selector: SelectorFn<ValueT, ToT>;\r\n\r\n    constructor(iterable: Iterable<ValueT>, selector: SelectorFn<ValueT, ToT>) {\r\n        this.iterable = iterable;\r\n        this.selector = selector;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<ToT> {\r\n        var iterator = this.iterable[Symbol.iterator]();\r\n        return new SelectManyIterator<ValueT, ToT>(iterator, this.selector);\r\n    }\r\n}","//\r\n// An iterable that takes a certain number of elements from a child iterable.\r\n//\r\n\r\nimport { TakeIterator } from '../iterators/take-iterator';\r\n\r\nexport class TakeIterable<T> implements Iterable<T> {\r\n\r\n    childIterable: Iterable<T>;\r\n    numElements: number;\r\n\r\n    constructor(childIterable: Iterable<T>, numElements: number) {\r\n        this.childIterable = childIterable;\r\n        this.numElements = numElements;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var childIterator = this.childIterable[Symbol.iterator]();\r\n        return new TakeIterator(childIterator, this.numElements);\r\n    }\r\n}","//\r\n// An iterable that takes a sequence of elements while a predicate function returns true.\r\n//\r\n\r\nimport { TakeWhileIterator, PredicateFn } from '../iterators/take-while-iterator';\r\n\r\nexport class TakeWhileIterable<T> implements Iterable<T> {\r\n\r\n    childIterable: Iterable<T>;\r\n    predicate: PredicateFn<T>;\r\n\r\n    constructor(childIterable: Iterable<T>, predicate: PredicateFn<T>) {\r\n        this.childIterable = childIterable;\r\n        this.predicate = predicate;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var childIterator = this.childIterable[Symbol.iterator]();\r\n        return new TakeWhileIterator(childIterator, this.predicate);\r\n    }\r\n}","//\r\n// An iterable that takes elements from a child iterable based on a predicate function.\r\n//\r\n\r\nimport { WhereIterator, PredicateFn } from '../iterators/where-iterator';\r\n\r\nexport class WhereIterable<T> implements Iterable<T> {\r\n\r\n    childIterable: Iterable<T>;\r\n    predicate: PredicateFn<T>;\r\n\r\n    constructor(childIterable: Iterable<T>, predicate: PredicateFn<T>) {\r\n        this.childIterable = childIterable;\r\n        this.predicate = predicate;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var childIterator = this.childIterable[Symbol.iterator]();\r\n        return new WhereIterator(childIterator, this.predicate);\r\n    }\r\n}","//\r\n// An iterable that concatenates multiple iterables.\r\n//\r\n\r\nimport { ConcatIterator } from '../iterators/concat-iterator';\r\n\r\nexport class ConcatIterable<T> implements Iterable<T> {\r\n\r\n    iterables: Iterable<Iterable<T>>;\r\n\r\n    constructor(iterables: Iterable<Iterable<T>>) {\r\n        this.iterables = iterables;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        return new ConcatIterator(this.iterables);\r\n    }\r\n}","//\r\n// An iterable that iterates the elements in reverse.\r\n//\r\n\r\nimport { ArrayIterator } from '../iterators/array-iterator';\r\n\r\nexport class ReverseIterable<T> implements Iterable<T> {\r\n\r\n    iterable: Iterable<T>;\r\n\r\n    constructor(iterable: Iterable<T>) {\r\n        this.iterable = iterable\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        const working = [];\r\n        for (const value of this.iterable) {\r\n            working.push(value);\r\n        }\r\n        working.reverse();\r\n        return new ArrayIterator(working);\r\n    }\r\n}","//\r\n// An iterable that zips together each set of elements in child iterables.\r\n//\r\n\r\nimport { ZipIterator, ZipFn } from '../iterators/zip-iterator';\r\n\r\nexport class ZipIterable<ValueT, ReturnT> implements Iterable<ReturnT> {\r\n\r\n    iterables: Iterable<ValueT>[];\r\n    zipper: ZipFn<ValueT, ReturnT>;\r\n\r\n    constructor(iterables: Iterable<ValueT>[], zipper: ZipFn<ValueT, ReturnT>) {\r\n        this.iterables = iterables;\r\n        this.zipper = zipper;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<ReturnT> {\r\n        return new ZipIterator<ValueT, ReturnT>(this.iterables, this.zipper);\r\n    }\r\n}","//\r\n// An iterable that iterates the only distinct elements of another iterable.\r\n//\r\n\r\nimport { DistinctIterator, SelectorFnNoIndex } from '../iterators/distinct-iterator';\r\n\r\nexport class DistinctIterable<FromT, ToT> implements Iterable<FromT> {\r\n\r\n    iterable: Iterable<FromT>;\r\n    selector?: SelectorFnNoIndex<FromT, ToT>;\r\n\r\n    constructor(iterable: Iterable<FromT>, selector?: SelectorFnNoIndex<FromT, ToT>) {\r\n        this.iterable = iterable;\r\n        this.selector = selector;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<FromT> {\r\n        return new DistinctIterator(this.iterable, this.selector);\r\n    }\r\n}","//\r\n// An iterable that sorts it's input before iterating it.\r\n//\r\n\r\nimport { ArrayIterator } from '../iterators/array-iterator';\r\n\r\nexport type SelectorFn = (value: any, index: number) => any;\r\n\r\nexport enum Direction {\r\n    Ascending,\r\n    Descending\r\n}\r\n\r\nexport interface ISortSpec {\r\n    sortLevel: number; // Debug helper. Sort level 0 is the first level.\r\n    selector: SelectorFn;\r\n    direction: Direction,\r\n}\r\n\r\nclass SortOperation {\r\n\r\n    values: any[];\r\n    sortSpec: ISortSpec;\r\n    keys: any[];\r\n\r\n    constructor(values: any[], sortSpec: ISortSpec) {\r\n        this.values = values;\r\n        this.sortSpec = sortSpec;\r\n        this.keys = [];\r\n    }\r\n\r\n    genKeys (): void {\r\n        if (this.keys.length > 0) {\r\n            // Already cached.\r\n            return;\r\n        }\r\n        \r\n        const index = 0;\r\n        for (const value of this.values) {\r\n            this.keys.push(this.sortSpec.selector(value, index));\r\n        }        \r\n    }\r\n\r\n    compare (indexA: number, indexB: number): number {\r\n        this.genKeys();\r\n\r\n        const keyA = this.keys[indexA];\r\n        const keyB = this.keys[indexB];\r\n        let comparison = -1;\r\n        if (keyA === keyB) {\r\n            comparison = 0;\r\n        }\r\n        else if (keyA > keyB) {\r\n            comparison = 1;\r\n        }\r\n\r\n        return (this.sortSpec.direction === Direction.Descending) ? -comparison : comparison;\r\n    }\r\n}\r\n\r\nexport class OrderedIterable implements Iterable<any> {\r\n\r\n    //TODO: Would probably be good to cache the sorted data here.\r\n\r\n    iterable: Iterable<any>;\r\n    sortSpec: ISortSpec[];\r\n\r\n    constructor(iterable: Iterable<any>, sortSpec: ISortSpec[]) {\r\n        this.iterable = iterable;\r\n        this.sortSpec = sortSpec;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n\r\n        const indexes: number[] = [];\r\n        const values: any[] = [];\r\n\r\n        let index = 0;\r\n        for (const value of this.iterable) {\r\n            indexes.push(index);\r\n            values.push(value);\r\n            ++index;\r\n        }\r\n\r\n        const sortOperations: SortOperation[] = [];\r\n        for (const sortSpec of this.sortSpec) {\r\n            sortOperations.push(new SortOperation(values, sortSpec));\r\n        }\r\n\r\n        sortOperations[0].genKeys();\r\n\r\n        indexes.sort((indexA: number, indexB: number): number => {\r\n            for (const sortOperation of sortOperations) {\r\n                const comparison = sortOperation.compare(indexA, indexB);\r\n                if (comparison !== 0) {\r\n                    return comparison;\r\n                }\r\n            }\r\n\r\n            return 0;\r\n        });\r\n\r\n        const sortedValues: any[] = [];\r\n\r\n        for (const index of indexes) {\r\n            sortedValues.push(values[index]);\r\n        }        \r\n\r\n        return new ArrayIterator(sortedValues);\r\n    }\r\n}","//\r\n// An iterable to extact an element from an array.\r\n//\r\n\r\nimport { ExtractElementIterator } from '../iterators/extract-element-iterator';\r\n\r\nexport class ExtractElementIterable implements Iterable<any> {\r\n\r\n    arrayIterable: Iterable<any[]>;\r\n    extractIndex: number;\r\n\r\n    constructor(arrayIterable: Iterable<any[]>, extractIndex: number) {\r\n        this.arrayIterable = arrayIterable;\r\n        this.extractIndex = extractIndex;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var arrayIterator = this.arrayIterable[Symbol.iterator]();\r\n        return new ExtractElementIterator(arrayIterator, this.extractIndex);\r\n    }\r\n}","//\r\n// An iterable that skips a number of values.\r\n//\r\n\r\nimport { SkipIterator } from '../iterators/skip-iterator';\r\n\r\nexport class SkipIterable implements Iterable<any> {\r\n\r\n    iterable: Iterable<any>;\r\n    numValues: number;\r\n\r\n    constructor(iterable: Iterable<any>, numValues: number) {\r\n        this.iterable = iterable;\r\n        this.numValues = numValues;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var iterator = this.iterable[Symbol.iterator]();\r\n        return new SkipIterator(iterator, this.numValues);\r\n    }\r\n}","//\r\n// An iterable that skips a sequence of elements while a predicate function returns true.\r\n//\r\n\r\nimport { SkipWhileIterator, PredicateFn } from '../iterators/skip-while-iterator';\r\n\r\nexport class SkipWhileIterable<T> implements Iterable<T> {\r\n\r\n    childIterable: Iterable<T>;\r\n    predicate: PredicateFn<T>;\r\n\r\n    constructor(childIterable: Iterable<T>, predicate: PredicateFn<T>) {\r\n        this.childIterable = childIterable;\r\n        this.predicate = predicate;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var childIterator = this.childIterable[Symbol.iterator]();\r\n        return new SkipWhileIterator(childIterator, this.predicate);\r\n    }\r\n}","var wcwidth\n\ntry {\n  wcwidth = require('wcwidth')\n} catch(e) {}\n\nmodule.exports = Table\n\nfunction Table() {\n  this.rows = []\n  this.row = {__printers : {}}\n}\n\n/**\n * Push the current row to the table and start a new one\n *\n * @returns {Table} `this`\n */\n\nTable.prototype.newRow = function() {\n  this.rows.push(this.row)\n  this.row = {__printers : {}}\n  return this\n}\n\n/**\n * Write cell in the current row\n *\n * @param {String} col          - Column name\n * @param {Any} val             - Cell value\n * @param {Function} [printer]  - Printer function to format the value\n * @returns {Table} `this`\n */\n\nTable.prototype.cell = function(col, val, printer) {\n  this.row[col] = val\n  this.row.__printers[col] = printer || string\n  return this\n}\n\n/**\n * String to separate columns\n */\n\nTable.prototype.separator = '  '\n\nfunction string(val) {\n  return val === undefined ? '' : ''+val\n}\n\nfunction length(str) {\n  var s = str.replace(/\\u001b\\[\\d+m/g, '')\n  return wcwidth == null ? s.length : wcwidth(s)\n}\n\n/**\n * Default printer\n */\n\nTable.string = string\n\n/**\n * Create a printer which right aligns the content by padding with `ch` on the left\n *\n * @param {String} ch\n * @returns {Function}\n */\n\nTable.leftPadder = leftPadder\n\nfunction leftPadder(ch) {\n  return function(val, width) {\n    var str = string(val)\n    var len = length(str)\n    var pad = width > len ? Array(width - len + 1).join(ch) : ''\n    return pad + str\n  }\n}\n\n/**\n * Printer which right aligns the content\n */\n\nvar padLeft = Table.padLeft = leftPadder(' ')\n\n/**\n * Create a printer which pads with `ch` on the right\n *\n * @param {String} ch\n * @returns {Function}\n */\n\nTable.rightPadder = rightPadder\n\nfunction rightPadder(ch) {\n  return function padRight(val, width) {\n    var str = string(val)\n    var len = length(str)\n    var pad = width > len ? Array(width - len + 1).join(ch) : ''\n    return str + pad\n  }\n}\n\nvar padRight = rightPadder(' ')\n\n/**\n * Create a printer for numbers\n *\n * Will do right alignment and optionally fix the number of digits after decimal point\n *\n * @param {Number} [digits] - Number of digits for fixpoint notation\n * @returns {Function}\n */\n\nTable.number = function(digits) {\n  return function(val, width) {\n    if (val == null) return ''\n    if (typeof val != 'number')\n      throw new Error(''+val + ' is not a number')\n    var str = digits == null ? val+'' : val.toFixed(digits)\n    return padLeft(str, width)\n  }\n}\n\nfunction each(row, fn) {\n  for(var key in row) {\n    if (key == '__printers') continue\n    fn(key, row[key])\n  }\n}\n\n/**\n * Get list of columns in printing order\n *\n * @returns {string[]}\n */\n\nTable.prototype.columns = function() {\n  var cols = {}\n  for(var i = 0; i < 2; i++) { // do 2 times\n    this.rows.forEach(function(row) {\n      var idx = 0\n      each(row, function(key) {\n        idx = Math.max(idx, cols[key] || 0)\n        cols[key] = idx\n        idx++\n      })\n    })\n  }\n  return Object.keys(cols).sort(function(a, b) {\n    return cols[a] - cols[b]\n  })\n}\n\n/**\n * Format just rows, i.e. print the table without headers and totals\n *\n * @returns {String} String representaion of the table\n */\n\nTable.prototype.print = function() {\n  var cols = this.columns()\n  var separator = this.separator\n  var widths = {}\n  var out = ''\n\n  // Calc widths\n  this.rows.forEach(function(row) {\n    each(row, function(key, val) {\n      var str = row.__printers[key].call(row, val)\n      widths[key] = Math.max(length(str), widths[key] || 0)\n    })\n  })\n\n  // Now print\n  this.rows.forEach(function(row) {\n    var line = ''\n    cols.forEach(function(key) {\n      var width = widths[key]\n      var str = row.hasOwnProperty(key)\n        ? ''+row.__printers[key].call(row, row[key], width)\n        : ''\n      line += padRight(str, width) + separator\n    })\n    line = line.slice(0, -separator.length)\n    out += line + '\\n'\n  })\n\n  return out\n}\n\n/**\n * Format the table\n *\n * @returns {String}\n */\n\nTable.prototype.toString = function() {\n  var cols = this.columns()\n  var out = new Table()\n\n  // copy options\n  out.separator = this.separator\n\n  // Write header\n  cols.forEach(function(col) {\n    out.cell(col, col)\n  })\n  out.newRow()\n  out.pushDelimeter(cols)\n\n  // Write body\n  out.rows = out.rows.concat(this.rows)\n\n  // Totals\n  if (this.totals && this.rows.length) {\n    out.pushDelimeter(cols)\n    this.forEachTotal(out.cell.bind(out))\n    out.newRow()\n  }\n\n  return out.print()\n}\n\n/**\n * Push delimeter row to the table (with each cell filled with dashs during printing)\n *\n * @param {String[]} [cols]\n * @returns {Table} `this`\n */\n\nTable.prototype.pushDelimeter = function(cols) {\n  cols = cols || this.columns()\n  cols.forEach(function(col) {\n    this.cell(col, undefined, leftPadder('-'))\n  }, this)\n  return this.newRow()\n}\n\n/**\n * Compute all totals and yield the results to `cb`\n *\n * @param {Function} cb - Callback function with signature `(column, value, printer)`\n */\n\nTable.prototype.forEachTotal = function(cb) {\n  for(var key in this.totals) {\n    var aggr = this.totals[key]\n    var acc = aggr.init\n    var len = this.rows.length\n    this.rows.forEach(function(row, idx) {\n      acc = aggr.reduce.call(row, acc, row[key], idx, len)\n    })\n    cb(key, acc, aggr.printer)\n  }\n}\n\n/**\n * Format the table so that each row represents column and each column represents row\n *\n * @param {Object} [opts]\n * @param {String} [ops.separator] - Column separation string\n * @param {Function} [opts.namePrinter] - Printer to format column names\n * @returns {String}\n */\n\nTable.prototype.printTransposed = function(opts) {\n  opts = opts || {}\n  var out = new Table\n  out.separator = opts.separator || this.separator\n  this.columns().forEach(function(col) {\n    out.cell(0, col, opts.namePrinter)\n    this.rows.forEach(function(row, idx) {\n      out.cell(idx+1, row[col], row.__printers[col])\n    })\n    out.newRow()\n  }, this)\n  return out.print()\n}\n\n/**\n * Sort the table\n *\n * @param {Function|string[]} [cmp] - Either compare function or a list of columns to sort on\n * @returns {Table} `this`\n */\n\nTable.prototype.sort = function(cmp) {\n  if (typeof cmp == 'function') {\n    this.rows.sort(cmp)\n    return this\n  }\n\n  var keys = Array.isArray(cmp) ? cmp : this.columns()\n\n  var comparators = keys.map(function(key) {\n    var order = 'asc'\n    var m = /(.*)\\|\\s*(asc|des)\\s*$/.exec(key)\n    if (m) {\n      key = m[1]\n      order = m[2]\n    }\n    return function (a, b) {\n      return order == 'asc'\n        ? compare(a[key], b[key])\n        : compare(b[key], a[key])\n    }\n  })\n\n  return this.sort(function(a, b) {\n    for (var i = 0; i < comparators.length; i++) {\n      var order = comparators[i](a, b)\n      if (order != 0) return order\n    }\n    return 0\n  })\n}\n\nfunction compare(a, b) {\n  if (a === b) return 0\n  if (a === undefined) return 1\n  if (b === undefined) return -1\n  if (a === null) return 1\n  if (b === null) return -1\n  if (a > b) return 1\n  if (a < b) return -1\n  return compare(String(a), String(b))\n}\n\n/**\n * Add a total for the column\n *\n * @param {String} col - column name\n * @param {Object} [opts]\n * @param {Function} [opts.reduce = sum] - reduce(acc, val, idx, length) function to compute the total value\n * @param {Function} [opts.printer = padLeft] - Printer to format the total cell\n * @param {Any} [opts.init = 0] - Initial value for reduction\n * @returns {Table} `this`\n */\n\nTable.prototype.total = function(col, opts) {\n  opts = opts || {}\n  this.totals = this.totals || {}\n  this.totals[col] = {\n    reduce: opts.reduce || Table.aggr.sum,\n    printer: opts.printer || padLeft,\n    init: opts.init == null ? 0 : opts.init\n  }\n  return this\n}\n\n/**\n * Predefined helpers for totals\n */\n\nTable.aggr = {}\n\n/**\n * Create a printer which formats the value with `printer`,\n * adds the `prefix` to it and right aligns the whole thing\n *\n * @param {String} prefix\n * @param {Function} printer\n * @returns {printer}\n */\n\nTable.aggr.printer = function(prefix, printer) {\n  printer = printer || string\n  return function(val, width) {\n    return padLeft(prefix + printer(val), width)\n  }\n}\n\n/**\n * Sum reduction\n */\n\nTable.aggr.sum = function(acc, val) {\n  return acc + val\n}\n\n/**\n * Average reduction\n */\n\nTable.aggr.avg = function(acc, val, idx, len) {\n  acc = acc + val\n  return idx + 1 == len ? acc/len : acc\n}\n\n/**\n * Print the array or object\n *\n * @param {Array|Object} obj - Object to print\n * @param {Function|Object} [format] - Format options\n * @param {Function} [cb] - Table post processing and formating\n * @returns {String}\n */\n\nTable.print = function(obj, format, cb) {\n  var opts = format || {}\n\n  format = typeof format == 'function'\n    ? format\n    : function(obj, cell) {\n      for(var key in obj) {\n        if (!obj.hasOwnProperty(key)) continue\n        var params = opts[key] || {}\n        cell(params.name || key, obj[key], params.printer)\n      }\n    }\n\n  var t = new Table\n  var cell = t.cell.bind(t)\n\n  if (Array.isArray(obj)) {\n    cb = cb || function(t) { return t.toString() }\n    obj.forEach(function(item) {\n      format(item, cell)\n      t.newRow()\n    })\n  } else {\n    cb = cb || function(t) { return t.printTransposed({separator: ' : '}) }\n    format(obj, cell)\n    t.newRow()\n  }\n\n  return cb(t)\n}\n\n/**\n * Same as `Table.print()` but yields the result to `console.log()`\n */\n\nTable.log = function(obj, format, cb) {\n  console.log(Table.print(obj, format, cb))\n}\n\n/**\n * Same as `.toString()` but yields the result to `console.log()`\n */\n\nTable.prototype.log = function() {\n  console.log(this.toString())\n}\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.JSON5 = factory());\n}(this, (function () { 'use strict';\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar _global = createCommonjsModule(function (module) {\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self\n\t  // eslint-disable-next-line no-new-func\n\t  : Function('return this')();\n\tif (typeof __g == 'number') { __g = global; } // eslint-disable-line no-undef\n\t});\n\n\tvar _core = createCommonjsModule(function (module) {\n\tvar core = module.exports = { version: '2.5.7' };\n\tif (typeof __e == 'number') { __e = core; } // eslint-disable-line no-undef\n\t});\n\tvar _core_1 = _core.version;\n\n\tvar _isObject = function (it) {\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n\tvar _anObject = function (it) {\n\t  if (!_isObject(it)) { throw TypeError(it + ' is not an object!'); }\n\t  return it;\n\t};\n\n\tvar _fails = function (exec) {\n\t  try {\n\t    return !!exec();\n\t  } catch (e) {\n\t    return true;\n\t  }\n\t};\n\n\t// Thank's IE8 for his funny defineProperty\n\tvar _descriptors = !_fails(function () {\n\t  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n\t});\n\n\tvar document = _global.document;\n\t// typeof document.createElement is 'object' in old IE\n\tvar is = _isObject(document) && _isObject(document.createElement);\n\tvar _domCreate = function (it) {\n\t  return is ? document.createElement(it) : {};\n\t};\n\n\tvar _ie8DomDefine = !_descriptors && !_fails(function () {\n\t  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;\n\t});\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tvar _toPrimitive = function (it, S) {\n\t  if (!_isObject(it)) { return it; }\n\t  var fn, val;\n\t  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }\n\t  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) { return val; }\n\t  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n\tvar dP = Object.defineProperty;\n\n\tvar f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n\t  _anObject(O);\n\t  P = _toPrimitive(P, true);\n\t  _anObject(Attributes);\n\t  if (_ie8DomDefine) { try {\n\t    return dP(O, P, Attributes);\n\t  } catch (e) { /* empty */ } }\n\t  if ('get' in Attributes || 'set' in Attributes) { throw TypeError('Accessors not supported!'); }\n\t  if ('value' in Attributes) { O[P] = Attributes.value; }\n\t  return O;\n\t};\n\n\tvar _objectDp = {\n\t\tf: f\n\t};\n\n\tvar _propertyDesc = function (bitmap, value) {\n\t  return {\n\t    enumerable: !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable: !(bitmap & 4),\n\t    value: value\n\t  };\n\t};\n\n\tvar _hide = _descriptors ? function (object, key, value) {\n\t  return _objectDp.f(object, key, _propertyDesc(1, value));\n\t} : function (object, key, value) {\n\t  object[key] = value;\n\t  return object;\n\t};\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tvar _has = function (it, key) {\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n\tvar id = 0;\n\tvar px = Math.random();\n\tvar _uid = function (key) {\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n\tvar _redefine = createCommonjsModule(function (module) {\n\tvar SRC = _uid('src');\n\tvar TO_STRING = 'toString';\n\tvar $toString = Function[TO_STRING];\n\tvar TPL = ('' + $toString).split(TO_STRING);\n\n\t_core.inspectSource = function (it) {\n\t  return $toString.call(it);\n\t};\n\n\t(module.exports = function (O, key, val, safe) {\n\t  var isFunction = typeof val == 'function';\n\t  if (isFunction) { _has(val, 'name') || _hide(val, 'name', key); }\n\t  if (O[key] === val) { return; }\n\t  if (isFunction) { _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); }\n\t  if (O === _global) {\n\t    O[key] = val;\n\t  } else if (!safe) {\n\t    delete O[key];\n\t    _hide(O, key, val);\n\t  } else if (O[key]) {\n\t    O[key] = val;\n\t  } else {\n\t    _hide(O, key, val);\n\t  }\n\t// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\t})(Function.prototype, TO_STRING, function toString() {\n\t  return typeof this == 'function' && this[SRC] || $toString.call(this);\n\t});\n\t});\n\n\tvar _aFunction = function (it) {\n\t  if (typeof it != 'function') { throw TypeError(it + ' is not a function!'); }\n\t  return it;\n\t};\n\n\t// optional / simple context binding\n\n\tvar _ctx = function (fn, that, length) {\n\t  _aFunction(fn);\n\t  if (that === undefined) { return fn; }\n\t  switch (length) {\n\t    case 1: return function (a) {\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function (a, b) {\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function (a, b, c) {\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function (/* ...args */) {\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n\tvar PROTOTYPE = 'prototype';\n\n\tvar $export = function (type, name, source) {\n\t  var IS_FORCED = type & $export.F;\n\t  var IS_GLOBAL = type & $export.G;\n\t  var IS_STATIC = type & $export.S;\n\t  var IS_PROTO = type & $export.P;\n\t  var IS_BIND = type & $export.B;\n\t  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];\n\t  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});\n\t  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n\t  var key, own, out, exp;\n\t  if (IS_GLOBAL) { source = name; }\n\t  for (key in source) {\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    // export native or passed\n\t    out = (own ? target : source)[key];\n\t    // bind timers to global for call from export context\n\t    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;\n\t    // extend global\n\t    if (target) { _redefine(target, key, out, type & $export.U); }\n\t    // export\n\t    if (exports[key] != out) { _hide(exports, key, exp); }\n\t    if (IS_PROTO && expProto[key] != out) { expProto[key] = out; }\n\t  }\n\t};\n\t_global.core = _core;\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library`\n\tvar _export = $export;\n\n\t// 7.1.4 ToInteger\n\tvar ceil = Math.ceil;\n\tvar floor = Math.floor;\n\tvar _toInteger = function (it) {\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tvar _defined = function (it) {\n\t  if (it == undefined) { throw TypeError(\"Can't call method on  \" + it); }\n\t  return it;\n\t};\n\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tvar _stringAt = function (TO_STRING) {\n\t  return function (that, pos) {\n\t    var s = String(_defined(that));\n\t    var i = _toInteger(pos);\n\t    var l = s.length;\n\t    var a, b;\n\t    if (i < 0 || i >= l) { return TO_STRING ? '' : undefined; }\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n\tvar $at = _stringAt(false);\n\t_export(_export.P, 'String', {\n\t  // 21.1.3.3 String.prototype.codePointAt(pos)\n\t  codePointAt: function codePointAt(pos) {\n\t    return $at(this, pos);\n\t  }\n\t});\n\n\tvar codePointAt = _core.String.codePointAt;\n\n\tvar max = Math.max;\n\tvar min = Math.min;\n\tvar _toAbsoluteIndex = function (index, length) {\n\t  index = _toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n\tvar fromCharCode = String.fromCharCode;\n\tvar $fromCodePoint = String.fromCodePoint;\n\n\t// length should be 1, old FF problem\n\t_export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n\t  // 21.1.2.2 String.fromCodePoint(...codePoints)\n\t  fromCodePoint: function fromCodePoint(x) {\n\t    var arguments$1 = arguments;\n\t // eslint-disable-line no-unused-vars\n\t    var res = [];\n\t    var aLen = arguments.length;\n\t    var i = 0;\n\t    var code;\n\t    while (aLen > i) {\n\t      code = +arguments$1[i++];\n\t      if (_toAbsoluteIndex(code, 0x10ffff) !== code) { throw RangeError(code + ' is not a valid code point'); }\n\t      res.push(code < 0x10000\n\t        ? fromCharCode(code)\n\t        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n\t      );\n\t    } return res.join('');\n\t  }\n\t});\n\n\tvar fromCodePoint = _core.String.fromCodePoint;\n\n\t// This is a generated file. Do not edit.\n\tvar Space_Separator = /[\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/;\n\tvar ID_Start = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE83\\uDE86-\\uDE89\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]/;\n\tvar ID_Continue = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF9\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE83\\uDE86-\\uDE99\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/;\n\n\tvar unicode = {\n\t\tSpace_Separator: Space_Separator,\n\t\tID_Start: ID_Start,\n\t\tID_Continue: ID_Continue\n\t};\n\n\tvar util = {\n\t    isSpaceSeparator: function isSpaceSeparator (c) {\n\t        return unicode.Space_Separator.test(c)\n\t    },\n\n\t    isIdStartChar: function isIdStartChar (c) {\n\t        return (\n\t            (c >= 'a' && c <= 'z') ||\n\t        (c >= 'A' && c <= 'Z') ||\n\t        (c === '$') || (c === '_') ||\n\t        unicode.ID_Start.test(c)\n\t        )\n\t    },\n\n\t    isIdContinueChar: function isIdContinueChar (c) {\n\t        return (\n\t            (c >= 'a' && c <= 'z') ||\n\t        (c >= 'A' && c <= 'Z') ||\n\t        (c >= '0' && c <= '9') ||\n\t        (c === '$') || (c === '_') ||\n\t        (c === '\\u200C') || (c === '\\u200D') ||\n\t        unicode.ID_Continue.test(c)\n\t        )\n\t    },\n\n\t    isDigit: function isDigit (c) {\n\t        return /[0-9]/.test(c)\n\t    },\n\n\t    isHexDigit: function isHexDigit (c) {\n\t        return /[0-9A-Fa-f]/.test(c)\n\t    },\n\t};\n\n\tvar source;\n\tvar parseState;\n\tvar stack;\n\tvar pos;\n\tvar line;\n\tvar column;\n\tvar token;\n\tvar key;\n\tvar root;\n\n\tvar parse = function parse (text, reviver) {\n\t    source = String(text);\n\t    parseState = 'start';\n\t    stack = [];\n\t    pos = 0;\n\t    line = 1;\n\t    column = 0;\n\t    token = undefined;\n\t    key = undefined;\n\t    root = undefined;\n\n\t    do {\n\t        token = lex();\n\n\t        // This code is unreachable.\n\t        // if (!parseStates[parseState]) {\n\t        //     throw invalidParseState()\n\t        // }\n\n\t        parseStates[parseState]();\n\t    } while (token.type !== 'eof')\n\n\t    if (typeof reviver === 'function') {\n\t        return internalize({'': root}, '', reviver)\n\t    }\n\n\t    return root\n\t};\n\n\tfunction internalize (holder, name, reviver) {\n\t    var value = holder[name];\n\t    if (value != null && typeof value === 'object') {\n\t        for (var key in value) {\n\t            var replacement = internalize(value, key, reviver);\n\t            if (replacement === undefined) {\n\t                delete value[key];\n\t            } else {\n\t                value[key] = replacement;\n\t            }\n\t        }\n\t    }\n\n\t    return reviver.call(holder, name, value)\n\t}\n\n\tvar lexState;\n\tvar buffer;\n\tvar doubleQuote;\n\tvar sign;\n\tvar c;\n\n\tfunction lex () {\n\t    lexState = 'default';\n\t    buffer = '';\n\t    doubleQuote = false;\n\t    sign = 1;\n\n\t    for (;;) {\n\t        c = peek();\n\n\t        // This code is unreachable.\n\t        // if (!lexStates[lexState]) {\n\t        //     throw invalidLexState(lexState)\n\t        // }\n\n\t        var token = lexStates[lexState]();\n\t        if (token) {\n\t            return token\n\t        }\n\t    }\n\t}\n\n\tfunction peek () {\n\t    if (source[pos]) {\n\t        return String.fromCodePoint(source.codePointAt(pos))\n\t    }\n\t}\n\n\tfunction read () {\n\t    var c = peek();\n\n\t    if (c === '\\n') {\n\t        line++;\n\t        column = 0;\n\t    } else if (c) {\n\t        column += c.length;\n\t    } else {\n\t        column++;\n\t    }\n\n\t    if (c) {\n\t        pos += c.length;\n\t    }\n\n\t    return c\n\t}\n\n\tvar lexStates = {\n\t    default: function default$1 () {\n\t        switch (c) {\n\t        case '\\t':\n\t        case '\\v':\n\t        case '\\f':\n\t        case ' ':\n\t        case '\\u00A0':\n\t        case '\\uFEFF':\n\t        case '\\n':\n\t        case '\\r':\n\t        case '\\u2028':\n\t        case '\\u2029':\n\t            read();\n\t            return\n\n\t        case '/':\n\t            read();\n\t            lexState = 'comment';\n\t            return\n\n\t        case undefined:\n\t            read();\n\t            return newToken('eof')\n\t        }\n\n\t        if (util.isSpaceSeparator(c)) {\n\t            read();\n\t            return\n\t        }\n\n\t        // This code is unreachable.\n\t        // if (!lexStates[parseState]) {\n\t        //     throw invalidLexState(parseState)\n\t        // }\n\n\t        return lexStates[parseState]()\n\t    },\n\n\t    comment: function comment () {\n\t        switch (c) {\n\t        case '*':\n\t            read();\n\t            lexState = 'multiLineComment';\n\t            return\n\n\t        case '/':\n\t            read();\n\t            lexState = 'singleLineComment';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    multiLineComment: function multiLineComment () {\n\t        switch (c) {\n\t        case '*':\n\t            read();\n\t            lexState = 'multiLineCommentAsterisk';\n\t            return\n\n\t        case undefined:\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t    },\n\n\t    multiLineCommentAsterisk: function multiLineCommentAsterisk () {\n\t        switch (c) {\n\t        case '*':\n\t            read();\n\t            return\n\n\t        case '/':\n\t            read();\n\t            lexState = 'default';\n\t            return\n\n\t        case undefined:\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t        lexState = 'multiLineComment';\n\t    },\n\n\t    singleLineComment: function singleLineComment () {\n\t        switch (c) {\n\t        case '\\n':\n\t        case '\\r':\n\t        case '\\u2028':\n\t        case '\\u2029':\n\t            read();\n\t            lexState = 'default';\n\t            return\n\n\t        case undefined:\n\t            read();\n\t            return newToken('eof')\n\t        }\n\n\t        read();\n\t    },\n\n\t    value: function value () {\n\t        switch (c) {\n\t        case '{':\n\t        case '[':\n\t            return newToken('punctuator', read())\n\n\t        case 'n':\n\t            read();\n\t            literal('ull');\n\t            return newToken('null', null)\n\n\t        case 't':\n\t            read();\n\t            literal('rue');\n\t            return newToken('boolean', true)\n\n\t        case 'f':\n\t            read();\n\t            literal('alse');\n\t            return newToken('boolean', false)\n\n\t        case '-':\n\t        case '+':\n\t            if (read() === '-') {\n\t                sign = -1;\n\t            }\n\n\t            lexState = 'sign';\n\t            return\n\n\t        case '.':\n\t            buffer = read();\n\t            lexState = 'decimalPointLeading';\n\t            return\n\n\t        case '0':\n\t            buffer = read();\n\t            lexState = 'zero';\n\t            return\n\n\t        case '1':\n\t        case '2':\n\t        case '3':\n\t        case '4':\n\t        case '5':\n\t        case '6':\n\t        case '7':\n\t        case '8':\n\t        case '9':\n\t            buffer = read();\n\t            lexState = 'decimalInteger';\n\t            return\n\n\t        case 'I':\n\t            read();\n\t            literal('nfinity');\n\t            return newToken('numeric', Infinity)\n\n\t        case 'N':\n\t            read();\n\t            literal('aN');\n\t            return newToken('numeric', NaN)\n\n\t        case '\"':\n\t        case \"'\":\n\t            doubleQuote = (read() === '\"');\n\t            buffer = '';\n\t            lexState = 'string';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    identifierNameStartEscape: function identifierNameStartEscape () {\n\t        if (c !== 'u') {\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t        var u = unicodeEscape();\n\t        switch (u) {\n\t        case '$':\n\t        case '_':\n\t            break\n\n\t        default:\n\t            if (!util.isIdStartChar(u)) {\n\t                throw invalidIdentifier()\n\t            }\n\n\t            break\n\t        }\n\n\t        buffer += u;\n\t        lexState = 'identifierName';\n\t    },\n\n\t    identifierName: function identifierName () {\n\t        switch (c) {\n\t        case '$':\n\t        case '_':\n\t        case '\\u200C':\n\t        case '\\u200D':\n\t            buffer += read();\n\t            return\n\n\t        case '\\\\':\n\t            read();\n\t            lexState = 'identifierNameEscape';\n\t            return\n\t        }\n\n\t        if (util.isIdContinueChar(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('identifier', buffer)\n\t    },\n\n\t    identifierNameEscape: function identifierNameEscape () {\n\t        if (c !== 'u') {\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t        var u = unicodeEscape();\n\t        switch (u) {\n\t        case '$':\n\t        case '_':\n\t        case '\\u200C':\n\t        case '\\u200D':\n\t            break\n\n\t        default:\n\t            if (!util.isIdContinueChar(u)) {\n\t                throw invalidIdentifier()\n\t            }\n\n\t            break\n\t        }\n\n\t        buffer += u;\n\t        lexState = 'identifierName';\n\t    },\n\n\t    sign: function sign$1 () {\n\t        switch (c) {\n\t        case '.':\n\t            buffer = read();\n\t            lexState = 'decimalPointLeading';\n\t            return\n\n\t        case '0':\n\t            buffer = read();\n\t            lexState = 'zero';\n\t            return\n\n\t        case '1':\n\t        case '2':\n\t        case '3':\n\t        case '4':\n\t        case '5':\n\t        case '6':\n\t        case '7':\n\t        case '8':\n\t        case '9':\n\t            buffer = read();\n\t            lexState = 'decimalInteger';\n\t            return\n\n\t        case 'I':\n\t            read();\n\t            literal('nfinity');\n\t            return newToken('numeric', sign * Infinity)\n\n\t        case 'N':\n\t            read();\n\t            literal('aN');\n\t            return newToken('numeric', NaN)\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    zero: function zero () {\n\t        switch (c) {\n\t        case '.':\n\t            buffer += read();\n\t            lexState = 'decimalPoint';\n\t            return\n\n\t        case 'e':\n\t        case 'E':\n\t            buffer += read();\n\t            lexState = 'decimalExponent';\n\t            return\n\n\t        case 'x':\n\t        case 'X':\n\t            buffer += read();\n\t            lexState = 'hexadecimal';\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * 0)\n\t    },\n\n\t    decimalInteger: function decimalInteger () {\n\t        switch (c) {\n\t        case '.':\n\t            buffer += read();\n\t            lexState = 'decimalPoint';\n\t            return\n\n\t        case 'e':\n\t        case 'E':\n\t            buffer += read();\n\t            lexState = 'decimalExponent';\n\t            return\n\t        }\n\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    decimalPointLeading: function decimalPointLeading () {\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'decimalFraction';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    decimalPoint: function decimalPoint () {\n\t        switch (c) {\n\t        case 'e':\n\t        case 'E':\n\t            buffer += read();\n\t            lexState = 'decimalExponent';\n\t            return\n\t        }\n\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'decimalFraction';\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    decimalFraction: function decimalFraction () {\n\t        switch (c) {\n\t        case 'e':\n\t        case 'E':\n\t            buffer += read();\n\t            lexState = 'decimalExponent';\n\t            return\n\t        }\n\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    decimalExponent: function decimalExponent () {\n\t        switch (c) {\n\t        case '+':\n\t        case '-':\n\t            buffer += read();\n\t            lexState = 'decimalExponentSign';\n\t            return\n\t        }\n\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'decimalExponentInteger';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    decimalExponentSign: function decimalExponentSign () {\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'decimalExponentInteger';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    decimalExponentInteger: function decimalExponentInteger () {\n\t        if (util.isDigit(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    hexadecimal: function hexadecimal () {\n\t        if (util.isHexDigit(c)) {\n\t            buffer += read();\n\t            lexState = 'hexadecimalInteger';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    hexadecimalInteger: function hexadecimalInteger () {\n\t        if (util.isHexDigit(c)) {\n\t            buffer += read();\n\t            return\n\t        }\n\n\t        return newToken('numeric', sign * Number(buffer))\n\t    },\n\n\t    string: function string () {\n\t        switch (c) {\n\t        case '\\\\':\n\t            read();\n\t            buffer += escape();\n\t            return\n\n\t        case '\"':\n\t            if (doubleQuote) {\n\t                read();\n\t                return newToken('string', buffer)\n\t            }\n\n\t            buffer += read();\n\t            return\n\n\t        case \"'\":\n\t            if (!doubleQuote) {\n\t                read();\n\t                return newToken('string', buffer)\n\t            }\n\n\t            buffer += read();\n\t            return\n\n\t        case '\\n':\n\t        case '\\r':\n\t            throw invalidChar(read())\n\n\t        case '\\u2028':\n\t        case '\\u2029':\n\t            separatorChar(c);\n\t            break\n\n\t        case undefined:\n\t            throw invalidChar(read())\n\t        }\n\n\t        buffer += read();\n\t    },\n\n\t    start: function start () {\n\t        switch (c) {\n\t        case '{':\n\t        case '[':\n\t            return newToken('punctuator', read())\n\n\t        // This code is unreachable since the default lexState handles eof.\n\t        // case undefined:\n\t        //     return newToken('eof')\n\t        }\n\n\t        lexState = 'value';\n\t    },\n\n\t    beforePropertyName: function beforePropertyName () {\n\t        switch (c) {\n\t        case '$':\n\t        case '_':\n\t            buffer = read();\n\t            lexState = 'identifierName';\n\t            return\n\n\t        case '\\\\':\n\t            read();\n\t            lexState = 'identifierNameStartEscape';\n\t            return\n\n\t        case '}':\n\t            return newToken('punctuator', read())\n\n\t        case '\"':\n\t        case \"'\":\n\t            doubleQuote = (read() === '\"');\n\t            lexState = 'string';\n\t            return\n\t        }\n\n\t        if (util.isIdStartChar(c)) {\n\t            buffer += read();\n\t            lexState = 'identifierName';\n\t            return\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    afterPropertyName: function afterPropertyName () {\n\t        if (c === ':') {\n\t            return newToken('punctuator', read())\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    beforePropertyValue: function beforePropertyValue () {\n\t        lexState = 'value';\n\t    },\n\n\t    afterPropertyValue: function afterPropertyValue () {\n\t        switch (c) {\n\t        case ',':\n\t        case '}':\n\t            return newToken('punctuator', read())\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    beforeArrayValue: function beforeArrayValue () {\n\t        if (c === ']') {\n\t            return newToken('punctuator', read())\n\t        }\n\n\t        lexState = 'value';\n\t    },\n\n\t    afterArrayValue: function afterArrayValue () {\n\t        switch (c) {\n\t        case ',':\n\t        case ']':\n\t            return newToken('punctuator', read())\n\t        }\n\n\t        throw invalidChar(read())\n\t    },\n\n\t    end: function end () {\n\t        // This code is unreachable since it's handled by the default lexState.\n\t        // if (c === undefined) {\n\t        //     read()\n\t        //     return newToken('eof')\n\t        // }\n\n\t        throw invalidChar(read())\n\t    },\n\t};\n\n\tfunction newToken (type, value) {\n\t    return {\n\t        type: type,\n\t        value: value,\n\t        line: line,\n\t        column: column,\n\t    }\n\t}\n\n\tfunction literal (s) {\n\t    for (var i = 0, list = s; i < list.length; i += 1) {\n\t        var c = list[i];\n\n\t        var p = peek();\n\n\t        if (p !== c) {\n\t            throw invalidChar(read())\n\t        }\n\n\t        read();\n\t    }\n\t}\n\n\tfunction escape () {\n\t    var c = peek();\n\t    switch (c) {\n\t    case 'b':\n\t        read();\n\t        return '\\b'\n\n\t    case 'f':\n\t        read();\n\t        return '\\f'\n\n\t    case 'n':\n\t        read();\n\t        return '\\n'\n\n\t    case 'r':\n\t        read();\n\t        return '\\r'\n\n\t    case 't':\n\t        read();\n\t        return '\\t'\n\n\t    case 'v':\n\t        read();\n\t        return '\\v'\n\n\t    case '0':\n\t        read();\n\t        if (util.isDigit(peek())) {\n\t            throw invalidChar(read())\n\t        }\n\n\t        return '\\0'\n\n\t    case 'x':\n\t        read();\n\t        return hexEscape()\n\n\t    case 'u':\n\t        read();\n\t        return unicodeEscape()\n\n\t    case '\\n':\n\t    case '\\u2028':\n\t    case '\\u2029':\n\t        read();\n\t        return ''\n\n\t    case '\\r':\n\t        read();\n\t        if (peek() === '\\n') {\n\t            read();\n\t        }\n\n\t        return ''\n\n\t    case '1':\n\t    case '2':\n\t    case '3':\n\t    case '4':\n\t    case '5':\n\t    case '6':\n\t    case '7':\n\t    case '8':\n\t    case '9':\n\t        throw invalidChar(read())\n\n\t    case undefined:\n\t        throw invalidChar(read())\n\t    }\n\n\t    return read()\n\t}\n\n\tfunction hexEscape () {\n\t    var buffer = '';\n\t    var c = peek();\n\n\t    if (!util.isHexDigit(c)) {\n\t        throw invalidChar(read())\n\t    }\n\n\t    buffer += read();\n\n\t    c = peek();\n\t    if (!util.isHexDigit(c)) {\n\t        throw invalidChar(read())\n\t    }\n\n\t    buffer += read();\n\n\t    return String.fromCodePoint(parseInt(buffer, 16))\n\t}\n\n\tfunction unicodeEscape () {\n\t    var buffer = '';\n\t    var count = 4;\n\n\t    while (count-- > 0) {\n\t        var c = peek();\n\t        if (!util.isHexDigit(c)) {\n\t            throw invalidChar(read())\n\t        }\n\n\t        buffer += read();\n\t    }\n\n\t    return String.fromCodePoint(parseInt(buffer, 16))\n\t}\n\n\tvar parseStates = {\n\t    start: function start () {\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        push();\n\t    },\n\n\t    beforePropertyName: function beforePropertyName () {\n\t        switch (token.type) {\n\t        case 'identifier':\n\t        case 'string':\n\t            key = token.value;\n\t            parseState = 'afterPropertyName';\n\t            return\n\n\t        case 'punctuator':\n\t            // This code is unreachable since it's handled by the lexState.\n\t            // if (token.value !== '}') {\n\t            //     throw invalidToken()\n\t            // }\n\n\t            pop();\n\t            return\n\n\t        case 'eof':\n\t            throw invalidEOF()\n\t        }\n\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // throw invalidToken()\n\t    },\n\n\t    afterPropertyName: function afterPropertyName () {\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // if (token.type !== 'punctuator' || token.value !== ':') {\n\t        //     throw invalidToken()\n\t        // }\n\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        parseState = 'beforePropertyValue';\n\t    },\n\n\t    beforePropertyValue: function beforePropertyValue () {\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        push();\n\t    },\n\n\t    beforeArrayValue: function beforeArrayValue () {\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        if (token.type === 'punctuator' && token.value === ']') {\n\t            pop();\n\t            return\n\t        }\n\n\t        push();\n\t    },\n\n\t    afterPropertyValue: function afterPropertyValue () {\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // if (token.type !== 'punctuator') {\n\t        //     throw invalidToken()\n\t        // }\n\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        switch (token.value) {\n\t        case ',':\n\t            parseState = 'beforePropertyName';\n\t            return\n\n\t        case '}':\n\t            pop();\n\t        }\n\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // throw invalidToken()\n\t    },\n\n\t    afterArrayValue: function afterArrayValue () {\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // if (token.type !== 'punctuator') {\n\t        //     throw invalidToken()\n\t        // }\n\n\t        if (token.type === 'eof') {\n\t            throw invalidEOF()\n\t        }\n\n\t        switch (token.value) {\n\t        case ',':\n\t            parseState = 'beforeArrayValue';\n\t            return\n\n\t        case ']':\n\t            pop();\n\t        }\n\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // throw invalidToken()\n\t    },\n\n\t    end: function end () {\n\t        // This code is unreachable since it's handled by the lexState.\n\t        // if (token.type !== 'eof') {\n\t        //     throw invalidToken()\n\t        // }\n\t    },\n\t};\n\n\tfunction push () {\n\t    var value;\n\n\t    switch (token.type) {\n\t    case 'punctuator':\n\t        switch (token.value) {\n\t        case '{':\n\t            value = {};\n\t            break\n\n\t        case '[':\n\t            value = [];\n\t            break\n\t        }\n\n\t        break\n\n\t    case 'null':\n\t    case 'boolean':\n\t    case 'numeric':\n\t    case 'string':\n\t        value = token.value;\n\t        break\n\n\t    // This code is unreachable.\n\t    // default:\n\t    //     throw invalidToken()\n\t    }\n\n\t    if (root === undefined) {\n\t        root = value;\n\t    } else {\n\t        var parent = stack[stack.length - 1];\n\t        if (Array.isArray(parent)) {\n\t            parent.push(value);\n\t        } else {\n\t            parent[key] = value;\n\t        }\n\t    }\n\n\t    if (value !== null && typeof value === 'object') {\n\t        stack.push(value);\n\n\t        if (Array.isArray(value)) {\n\t            parseState = 'beforeArrayValue';\n\t        } else {\n\t            parseState = 'beforePropertyName';\n\t        }\n\t    } else {\n\t        var current = stack[stack.length - 1];\n\t        if (current == null) {\n\t            parseState = 'end';\n\t        } else if (Array.isArray(current)) {\n\t            parseState = 'afterArrayValue';\n\t        } else {\n\t            parseState = 'afterPropertyValue';\n\t        }\n\t    }\n\t}\n\n\tfunction pop () {\n\t    stack.pop();\n\n\t    var current = stack[stack.length - 1];\n\t    if (current == null) {\n\t        parseState = 'end';\n\t    } else if (Array.isArray(current)) {\n\t        parseState = 'afterArrayValue';\n\t    } else {\n\t        parseState = 'afterPropertyValue';\n\t    }\n\t}\n\n\t// This code is unreachable.\n\t// function invalidParseState () {\n\t//     return new Error(`JSON5: invalid parse state '${parseState}'`)\n\t// }\n\n\t// This code is unreachable.\n\t// function invalidLexState (state) {\n\t//     return new Error(`JSON5: invalid lex state '${state}'`)\n\t// }\n\n\tfunction invalidChar (c) {\n\t    if (c === undefined) {\n\t        return syntaxError((\"JSON5: invalid end of input at \" + line + \":\" + column))\n\t    }\n\n\t    return syntaxError((\"JSON5: invalid character '\" + (formatChar(c)) + \"' at \" + line + \":\" + column))\n\t}\n\n\tfunction invalidEOF () {\n\t    return syntaxError((\"JSON5: invalid end of input at \" + line + \":\" + column))\n\t}\n\n\t// This code is unreachable.\n\t// function invalidToken () {\n\t//     if (token.type === 'eof') {\n\t//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)\n\t//     }\n\n\t//     const c = String.fromCodePoint(token.value.codePointAt(0))\n\t//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)\n\t// }\n\n\tfunction invalidIdentifier () {\n\t    column -= 5;\n\t    return syntaxError((\"JSON5: invalid identifier character at \" + line + \":\" + column))\n\t}\n\n\tfunction separatorChar (c) {\n\t    console.warn((\"JSON5: '\" + (formatChar(c)) + \"' in strings is not valid ECMAScript; consider escaping\"));\n\t}\n\n\tfunction formatChar (c) {\n\t    var replacements = {\n\t        \"'\": \"\\\\'\",\n\t        '\"': '\\\\\"',\n\t        '\\\\': '\\\\\\\\',\n\t        '\\b': '\\\\b',\n\t        '\\f': '\\\\f',\n\t        '\\n': '\\\\n',\n\t        '\\r': '\\\\r',\n\t        '\\t': '\\\\t',\n\t        '\\v': '\\\\v',\n\t        '\\0': '\\\\0',\n\t        '\\u2028': '\\\\u2028',\n\t        '\\u2029': '\\\\u2029',\n\t    };\n\n\t    if (replacements[c]) {\n\t        return replacements[c]\n\t    }\n\n\t    if (c < ' ') {\n\t        var hexString = c.charCodeAt(0).toString(16);\n\t        return '\\\\x' + ('00' + hexString).substring(hexString.length)\n\t    }\n\n\t    return c\n\t}\n\n\tfunction syntaxError (message) {\n\t    var err = new SyntaxError(message);\n\t    err.lineNumber = line;\n\t    err.columnNumber = column;\n\t    return err\n\t}\n\n\tvar stringify = function stringify (value, replacer, space) {\n\t    var stack = [];\n\t    var indent = '';\n\t    var propertyList;\n\t    var replacerFunc;\n\t    var gap = '';\n\t    var quote;\n\n\t    if (\n\t        replacer != null &&\n\t        typeof replacer === 'object' &&\n\t        !Array.isArray(replacer)\n\t    ) {\n\t        space = replacer.space;\n\t        quote = replacer.quote;\n\t        replacer = replacer.replacer;\n\t    }\n\n\t    if (typeof replacer === 'function') {\n\t        replacerFunc = replacer;\n\t    } else if (Array.isArray(replacer)) {\n\t        propertyList = [];\n\t        for (var i = 0, list = replacer; i < list.length; i += 1) {\n\t            var v = list[i];\n\n\t            var item = (void 0);\n\n\t            if (typeof v === 'string') {\n\t                item = v;\n\t            } else if (\n\t                typeof v === 'number' ||\n\t                v instanceof String ||\n\t                v instanceof Number\n\t            ) {\n\t                item = String(v);\n\t            }\n\n\t            if (item !== undefined && propertyList.indexOf(item) < 0) {\n\t                propertyList.push(item);\n\t            }\n\t        }\n\t    }\n\n\t    if (space instanceof Number) {\n\t        space = Number(space);\n\t    } else if (space instanceof String) {\n\t        space = String(space);\n\t    }\n\n\t    if (typeof space === 'number') {\n\t        if (space > 0) {\n\t            space = Math.min(10, Math.floor(space));\n\t            gap = '          '.substr(0, space);\n\t        }\n\t    } else if (typeof space === 'string') {\n\t        gap = space.substr(0, 10);\n\t    }\n\n\t    return serializeProperty('', {'': value})\n\n\t    function serializeProperty (key, holder) {\n\t        var value = holder[key];\n\t        if (value != null) {\n\t            if (typeof value.toJSON5 === 'function') {\n\t                value = value.toJSON5(key);\n\t            } else if (typeof value.toJSON === 'function') {\n\t                value = value.toJSON(key);\n\t            }\n\t        }\n\n\t        if (replacerFunc) {\n\t            value = replacerFunc.call(holder, key, value);\n\t        }\n\n\t        if (value instanceof Number) {\n\t            value = Number(value);\n\t        } else if (value instanceof String) {\n\t            value = String(value);\n\t        } else if (value instanceof Boolean) {\n\t            value = value.valueOf();\n\t        }\n\n\t        switch (value) {\n\t        case null: return 'null'\n\t        case true: return 'true'\n\t        case false: return 'false'\n\t        }\n\n\t        if (typeof value === 'string') {\n\t            return quoteString(value, false)\n\t        }\n\n\t        if (typeof value === 'number') {\n\t            return String(value)\n\t        }\n\n\t        if (typeof value === 'object') {\n\t            return Array.isArray(value) ? serializeArray(value) : serializeObject(value)\n\t        }\n\n\t        return undefined\n\t    }\n\n\t    function quoteString (value) {\n\t        var quotes = {\n\t            \"'\": 0.1,\n\t            '\"': 0.2,\n\t        };\n\n\t        var replacements = {\n\t            \"'\": \"\\\\'\",\n\t            '\"': '\\\\\"',\n\t            '\\\\': '\\\\\\\\',\n\t            '\\b': '\\\\b',\n\t            '\\f': '\\\\f',\n\t            '\\n': '\\\\n',\n\t            '\\r': '\\\\r',\n\t            '\\t': '\\\\t',\n\t            '\\v': '\\\\v',\n\t            '\\0': '\\\\0',\n\t            '\\u2028': '\\\\u2028',\n\t            '\\u2029': '\\\\u2029',\n\t        };\n\n\t        var product = '';\n\n\t        for (var i = 0, list = value; i < list.length; i += 1) {\n\t            var c = list[i];\n\n\t            switch (c) {\n\t            case \"'\":\n\t            case '\"':\n\t                quotes[c]++;\n\t                product += c;\n\t                continue\n\t            }\n\n\t            if (replacements[c]) {\n\t                product += replacements[c];\n\t                continue\n\t            }\n\n\t            if (c < ' ') {\n\t                var hexString = c.charCodeAt(0).toString(16);\n\t                product += '\\\\x' + ('00' + hexString).substring(hexString.length);\n\t                continue\n\t            }\n\n\t            product += c;\n\t        }\n\n\t        var quoteChar = quote || Object.keys(quotes).reduce(function (a, b) { return (quotes[a] < quotes[b]) ? a : b; });\n\n\t        product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);\n\n\t        return quoteChar + product + quoteChar\n\t    }\n\n\t    function serializeObject (value) {\n\t        if (stack.indexOf(value) >= 0) {\n\t            throw TypeError('Converting circular structure to JSON5')\n\t        }\n\n\t        stack.push(value);\n\n\t        var stepback = indent;\n\t        indent = indent + gap;\n\n\t        var keys = propertyList || Object.keys(value);\n\t        var partial = [];\n\t        for (var i = 0, list = keys; i < list.length; i += 1) {\n\t            var key = list[i];\n\n\t            var propertyString = serializeProperty(key, value);\n\t            if (propertyString !== undefined) {\n\t                var member = serializeKey(key) + ':';\n\t                if (gap !== '') {\n\t                    member += ' ';\n\t                }\n\t                member += propertyString;\n\t                partial.push(member);\n\t            }\n\t        }\n\n\t        var final;\n\t        if (partial.length === 0) {\n\t            final = '{}';\n\t        } else {\n\t            var properties;\n\t            if (gap === '') {\n\t                properties = partial.join(',');\n\t                final = '{' + properties + '}';\n\t            } else {\n\t                var separator = ',\\n' + indent;\n\t                properties = partial.join(separator);\n\t                final = '{\\n' + indent + properties + ',\\n' + stepback + '}';\n\t            }\n\t        }\n\n\t        stack.pop();\n\t        indent = stepback;\n\t        return final\n\t    }\n\n\t    function serializeKey (key) {\n\t        if (key.length === 0) {\n\t            return quoteString(key, true)\n\t        }\n\n\t        var firstChar = String.fromCodePoint(key.codePointAt(0));\n\t        if (!util.isIdStartChar(firstChar)) {\n\t            return quoteString(key, true)\n\t        }\n\n\t        for (var i = firstChar.length; i < key.length; i++) {\n\t            if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {\n\t                return quoteString(key, true)\n\t            }\n\t        }\n\n\t        return key\n\t    }\n\n\t    function serializeArray (value) {\n\t        if (stack.indexOf(value) >= 0) {\n\t            throw TypeError('Converting circular structure to JSON5')\n\t        }\n\n\t        stack.push(value);\n\n\t        var stepback = indent;\n\t        indent = indent + gap;\n\n\t        var partial = [];\n\t        for (var i = 0; i < value.length; i++) {\n\t            var propertyString = serializeProperty(String(i), value);\n\t            partial.push((propertyString !== undefined) ? propertyString : 'null');\n\t        }\n\n\t        var final;\n\t        if (partial.length === 0) {\n\t            final = '[]';\n\t        } else {\n\t            if (gap === '') {\n\t                var properties = partial.join(',');\n\t                final = '[' + properties + ']';\n\t            } else {\n\t                var separator = ',\\n' + indent;\n\t                var properties$1 = partial.join(separator);\n\t                final = '[\\n' + indent + properties$1 + ',\\n' + stepback + ']';\n\t            }\n\t        }\n\n\t        stack.pop();\n\t        indent = stepback;\n\t        return final\n\t    }\n\t};\n\n\tvar JSON5 = {\n\t    parse: parse,\n\t    stringify: stringify,\n\t};\n\n\tvar lib = JSON5;\n\n\tvar es5 = lib;\n\n\treturn es5;\n\n})));\n","/* @license\nPapa Parse\nv5.2.0\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/\n!function(e,t){\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof module&&\"undefined\"!=typeof exports?module.exports=t():e.Papa=t()}(this,function s(){\"use strict\";var f=\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:void 0!==f?f:{};var n=!f.document&&!!f.postMessage,o=n&&/blob:/i.test((f.location||{}).protocol),a={},h=0,b={parse:function(e,t){var i=(t=t||{}).dynamicTyping||!1;U(i)&&(t.dynamicTypingFunction=i,i={});if(t.dynamicTyping=i,t.transform=!!U(t.transform)&&t.transform,t.worker&&b.WORKERS_SUPPORTED){var r=function(){if(!b.WORKERS_SUPPORTED)return!1;var e=(i=f.URL||f.webkitURL||null,r=s.toString(),b.BLOB_URL||(b.BLOB_URL=i.createObjectURL(new Blob([\"(\",r,\")();\"],{type:\"text/javascript\"})))),t=new f.Worker(e);var i,r;return t.onmessage=_,t.id=h++,a[t.id]=t}();return r.userStep=t.step,r.userChunk=t.chunk,r.userComplete=t.complete,r.userError=t.error,t.step=U(t.step),t.chunk=U(t.chunk),t.complete=U(t.complete),t.error=U(t.error),delete t.worker,void r.postMessage({input:e,config:t,workerId:r.id})}var n=null;b.NODE_STREAM_INPUT,\"string\"==typeof e?n=t.download?new l(t):new p(t):!0===e.readable&&U(e.read)&&U(e.on)?n=new g(t):(f.File&&e instanceof File||e instanceof Object)&&(n=new c(t));return n.stream(e)},unparse:function(e,t){var n=!1,_=!0,m=\",\",v=\"\\r\\n\",s='\"',a=s+s,i=!1,r=null;!function(){if(\"object\"!=typeof t)return;\"string\"!=typeof t.delimiter||b.BAD_DELIMITERS.filter(function(e){return-1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter);(\"boolean\"==typeof t.quotes||\"function\"==typeof t.quotes||Array.isArray(t.quotes))&&(n=t.quotes);\"boolean\"!=typeof t.skipEmptyLines&&\"string\"!=typeof t.skipEmptyLines||(i=t.skipEmptyLines);\"string\"==typeof t.newline&&(v=t.newline);\"string\"==typeof t.quoteChar&&(s=t.quoteChar);\"boolean\"==typeof t.header&&(_=t.header);if(Array.isArray(t.columns)){if(0===t.columns.length)throw new Error(\"Option columns is empty\");r=t.columns}void 0!==t.escapeChar&&(a=t.escapeChar+s)}();var o=new RegExp(q(s),\"g\");\"string\"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return u(null,e,i);if(\"object\"==typeof e[0])return u(r||h(e[0]),e,i)}else if(\"object\"==typeof e)return\"string\"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:h(e.data[0])),Array.isArray(e.data[0])||\"object\"==typeof e.data[0]||(e.data=[e.data])),u(e.fields||[],e.data||[],i);throw new Error(\"Unable to serialize unrecognized input\");function h(e){if(\"object\"!=typeof e)return[];var t=[];for(var i in e)t.push(i);return t}function u(e,t,i){var r=\"\";\"string\"==typeof e&&(e=JSON.parse(e)),\"string\"==typeof t&&(t=JSON.parse(t));var n=Array.isArray(e)&&0<e.length,s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(r+=m),r+=y(e[a],a);0<t.length&&(r+=v)}for(var o=0;o<t.length;o++){var h=n?e.length:t[o].length,u=!1,f=n?0===Object.keys(t[o]).length:0===t[o].length;if(i&&!n&&(u=\"greedy\"===i?\"\"===t[o].join(\"\").trim():1===t[o].length&&0===t[o][0].length),\"greedy\"===i&&n){for(var d=[],l=0;l<h;l++){var c=s?e[l]:l;d.push(t[o][c])}u=\"\"===d.join(\"\").trim()}if(!u){for(var p=0;p<h;p++){0<p&&!f&&(r+=m);var g=n&&s?e[p]:p;r+=y(t[o][g],p)}o<t.length-1&&(!i||0<h&&!f)&&(r+=v)}}return r}function y(e,t){if(null==e)return\"\";if(e.constructor===Date)return JSON.stringify(e).slice(1,25);var i=e.toString().replace(o,a),r=\"boolean\"==typeof n&&n||\"function\"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||function(e,t){for(var i=0;i<t.length;i++)if(-1<e.indexOf(t[i]))return!0;return!1}(i,b.BAD_DELIMITERS)||-1<i.indexOf(m)||\" \"===i.charAt(0)||\" \"===i.charAt(i.length-1);return r?s+i+s:i}}};if(b.RECORD_SEP=String.fromCharCode(30),b.UNIT_SEP=String.fromCharCode(31),b.BYTE_ORDER_MARK=\"\\ufeff\",b.BAD_DELIMITERS=[\"\\r\",\"\\n\",'\"',b.BYTE_ORDER_MARK],b.WORKERS_SUPPORTED=!n&&!!f.Worker,b.NODE_STREAM_INPUT=1,b.LocalChunkSize=10485760,b.RemoteChunkSize=5242880,b.DefaultDelimiter=\",\",b.Parser=w,b.ParserHandle=i,b.NetworkStreamer=l,b.FileStreamer=c,b.StringStreamer=p,b.ReadableStreamStreamer=g,f.jQuery){var d=f.jQuery;d.fn.parse=function(o){var i=o.config||{},h=[];return this.each(function(e){if(!(\"INPUT\"===d(this).prop(\"tagName\").toUpperCase()&&\"file\"===d(this).attr(\"type\").toLowerCase()&&f.FileReader)||!this.files||0===this.files.length)return!0;for(var t=0;t<this.files.length;t++)h.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},i)})}),e(),this;function e(){if(0!==h.length){var e,t,i,r,n=h[0];if(U(o.before)){var s=o.before(n.file,n.inputElem);if(\"object\"==typeof s){if(\"abort\"===s.action)return e=\"AbortError\",t=n.file,i=n.inputElem,r=s.reason,void(U(o.error)&&o.error({name:e},t,i,r));if(\"skip\"===s.action)return void u();\"object\"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config))}else if(\"skip\"===s)return void u()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){U(a)&&a(e,n.file,n.inputElem),u()},b.parse(n.file,n.instanceConfig)}else U(o.complete)&&o.complete()}function u(){h.splice(0,1),e()}}}function u(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine=\"\",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=E(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new i(t),(this._handle.streamer=this)._config=t}.call(this,e),this.parseChunk=function(e,t){if(this.isFirstChunk&&U(this._config.beforeFirstChunk)){var i=this._config.beforeFirstChunk(e);void 0!==i&&(e=i)}this.isFirstChunk=!1,this._halted=!1;var r=this._partialLine+e;this._partialLine=\"\";var n=this._handle.parse(r,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var s=n.meta.cursor;this._finished||(this._partialLine=r.substring(s-this._baseIndex),this._baseIndex=s),n&&n.data&&(this._rowCount+=n.data.length);var a=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(o)f.postMessage({results:n,workerId:b.WORKER_ID,finished:a});else if(U(this._config.chunk)&&!t){if(this._config.chunk(n,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);n=void 0,this._completeResults=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(n.data),this._completeResults.errors=this._completeResults.errors.concat(n.errors),this._completeResults.meta=n.meta),this._completed||!a||!U(this._config.complete)||n&&n.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),a||n&&n.meta.paused||this._nextChunk(),n}this._halted=!0},this._sendError=function(e){U(this._config.error)?this._config.error(e):o&&this._config.error&&f.postMessage({workerId:b.WORKER_ID,error:e,finished:!1})}}function l(e){var r;(e=e||{}).chunkSize||(e.chunkSize=b.RemoteChunkSize),u.call(this,e),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(e){this._input=e,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(r=new XMLHttpRequest,this._config.withCredentials&&(r.withCredentials=this._config.withCredentials),n||(r.onload=y(this._chunkLoaded,this),r.onerror=y(this._chunkError,this)),r.open(this._config.downloadRequestBody?\"POST\":\"GET\",this._input,!n),this._config.downloadRequestHeaders){var e=this._config.downloadRequestHeaders;for(var t in e)r.setRequestHeader(t,e[t])}if(this._config.chunkSize){var i=this._start+this._config.chunkSize-1;r.setRequestHeader(\"Range\",\"bytes=\"+this._start+\"-\"+i)}try{r.send(this._config.downloadRequestBody)}catch(e){this._chunkError(e.message)}n&&0===r.status&&this._chunkError()}},this._chunkLoaded=function(){4===r.readyState&&(r.status<200||400<=r.status?this._chunkError():(this._start+=this._config.chunkSize?this._config.chunkSize:r.responseText.length,this._finished=!this._config.chunkSize||this._start>=function(e){var t=e.getResponseHeader(\"Content-Range\");if(null===t)return-1;return parseInt(t.substring(t.lastIndexOf(\"/\")+1))}(r),this.parseChunk(r.responseText)))},this._chunkError=function(e){var t=r.statusText||e;this._sendError(new Error(t))}}function c(e){var r,n;(e=e||{}).chunkSize||(e.chunkSize=b.LocalChunkSize),u.call(this,e);var s=\"undefined\"!=typeof FileReader;this.stream=function(e){this._input=e,n=e.slice||e.webkitSlice||e.mozSlice,s?((r=new FileReader).onload=y(this._chunkLoaded,this),r.onerror=y(this._chunkError,this)):r=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var e=this._input;if(this._config.chunkSize){var t=Math.min(this._start+this._config.chunkSize,this._input.size);e=n.call(e,this._start,t)}var i=r.readAsText(e,this._config.encoding);s||this._chunkLoaded({target:{result:i}})},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result)},this._chunkError=function(){this._sendError(r.error)}}function p(e){var i;u.call(this,e=e||{}),this.stream=function(e){return i=e,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var e,t=this._config.chunkSize;return t?(e=i.substring(0,t),i=i.substring(t)):(e=i,i=\"\"),this._finished=!i,this.parseChunk(e)}}}function g(e){u.call(this,e=e||{});var t=[],i=!0,r=!1;this.pause=function(){u.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){u.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(e){this._input=e,this._input.on(\"data\",this._streamData),this._input.on(\"end\",this._streamEnd),this._input.on(\"error\",this._streamError)},this._checkIsFinished=function(){r&&1===t.length&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):i=!0},this._streamData=y(function(e){try{t.push(\"string\"==typeof e?e:e.toString(this._config.encoding)),i&&(i=!1,this._checkIsFinished(),this.parseChunk(t.shift()))}catch(e){this._streamError(e)}},this),this._streamError=y(function(e){this._streamCleanUp(),this._sendError(e)},this),this._streamEnd=y(function(){this._streamCleanUp(),r=!0,this._streamData(\"\")},this),this._streamCleanUp=y(function(){this._input.removeListener(\"data\",this._streamData),this._input.removeListener(\"end\",this._streamEnd),this._input.removeListener(\"error\",this._streamError)},this)}function i(m){var a,o,h,r=Math.pow(2,53),n=-r,s=/^\\s*-?(\\d+\\.?|\\.\\d+|\\d+\\.\\d+)(e[-+]?\\d+)?\\s*$/,u=/(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/,t=this,i=0,f=0,d=!1,e=!1,l=[],c={data:[],errors:[],meta:{}};if(U(m.step)){var p=m.step;m.step=function(e){if(c=e,_())g();else{if(g(),0===c.data.length)return;i+=e.data.length,m.preview&&i>m.preview?o.abort():(c.data=c.data[0],p(c,t))}}}function v(e){return\"greedy\"===m.skipEmptyLines?\"\"===e.join(\"\").trim():1===e.length&&0===e[0].length}function g(){if(c&&h&&(k(\"Delimiter\",\"UndetectableDelimiter\",\"Unable to auto-detect delimiting character; defaulted to '\"+b.DefaultDelimiter+\"'\"),h=!1),m.skipEmptyLines)for(var e=0;e<c.data.length;e++)v(c.data[e])&&c.data.splice(e--,1);return _()&&function(){if(!c)return;function e(e){U(m.transformHeader)&&(e=m.transformHeader(e)),l.push(e)}if(Array.isArray(c.data[0])){for(var t=0;_()&&t<c.data.length;t++)c.data[t].forEach(e);c.data.splice(0,1)}else c.data.forEach(e)}(),function(){if(!c||!m.header&&!m.dynamicTyping&&!m.transform)return c;function e(e,t){var i,r=m.header?{}:[];for(i=0;i<e.length;i++){var n=i,s=e[i];m.header&&(n=i>=l.length?\"__parsed_extra\":l[i]),m.transform&&(s=m.transform(s,n)),s=y(n,s),\"__parsed_extra\"===n?(r[n]=r[n]||[],r[n].push(s)):r[n]=s}return m.header&&(i>l.length?k(\"FieldMismatch\",\"TooManyFields\",\"Too many fields: expected \"+l.length+\" fields but parsed \"+i,f+t):i<l.length&&k(\"FieldMismatch\",\"TooFewFields\",\"Too few fields: expected \"+l.length+\" fields but parsed \"+i,f+t)),r}var t=1;!c.data.length||Array.isArray(c.data[0])?(c.data=c.data.map(e),t=c.data.length):c.data=e(c.data,0);m.header&&c.meta&&(c.meta.fields=l);return f+=t,c}()}function _(){return m.header&&0===l.length}function y(e,t){return i=e,m.dynamicTypingFunction&&void 0===m.dynamicTyping[i]&&(m.dynamicTyping[i]=m.dynamicTypingFunction(i)),!0===(m.dynamicTyping[i]||m.dynamicTyping)?\"true\"===t||\"TRUE\"===t||\"false\"!==t&&\"FALSE\"!==t&&(function(e){if(s.test(e)){var t=parseFloat(e);if(n<t&&t<r)return!0}return!1}(t)?parseFloat(t):u.test(t)?new Date(t):\"\"===t?null:t):t;var i}function k(e,t,i,r){var n={type:e,code:t,message:i};void 0!==r&&(n.row=r),c.errors.push(n)}this.parse=function(e,t,i){var r=m.quoteChar||'\"';if(m.newline||(m.newline=function(e,t){e=e.substring(0,1048576);var i=new RegExp(q(t)+\"([^]*?)\"+q(t),\"gm\"),r=(e=e.replace(i,\"\")).split(\"\\r\"),n=e.split(\"\\n\"),s=1<n.length&&n[0].length<r[0].length;if(1===r.length||s)return\"\\n\";for(var a=0,o=0;o<r.length;o++)\"\\n\"===r[o][0]&&a++;return a>=r.length/2?\"\\r\\n\":\"\\r\"}(e,r)),h=!1,m.delimiter)U(m.delimiter)&&(m.delimiter=m.delimiter(e),c.meta.delimiter=m.delimiter);else{var n=function(e,t,i,r,n){var s,a,o,h;n=n||[\",\",\"\\t\",\"|\",\";\",b.RECORD_SEP,b.UNIT_SEP];for(var u=0;u<n.length;u++){var f=n[u],d=0,l=0,c=0;o=void 0;for(var p=new w({comments:r,delimiter:f,newline:t,preview:10}).parse(e),g=0;g<p.data.length;g++)if(i&&v(p.data[g]))c++;else{var _=p.data[g].length;l+=_,void 0!==o?0<_&&(d+=Math.abs(_-o),o=_):o=_}0<p.data.length&&(l/=p.data.length-c),(void 0===a||d<=a)&&(void 0===h||h<l)&&1.99<l&&(a=d,s=f,h=l)}return{successful:!!(m.delimiter=s),bestDelimiter:s}}(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess);n.successful?m.delimiter=n.bestDelimiter:(h=!0,m.delimiter=b.DefaultDelimiter),c.meta.delimiter=m.delimiter}var s=E(m);return m.preview&&m.header&&s.preview++,a=e,o=new w(s),c=o.parse(a,t,i),g(),d?{meta:{paused:!0}}:c||{meta:{paused:!1}}},this.paused=function(){return d},this.pause=function(){d=!0,o.abort(),a=U(m.chunk)?\"\":a.substring(o.getCharIndex())},this.resume=function(){t.streamer._halted?(d=!1,t.streamer.parseChunk(a,!0)):setTimeout(t.resume,3)},this.aborted=function(){return e},this.abort=function(){e=!0,o.abort(),c.meta.aborted=!0,U(m.complete)&&m.complete(c),a=\"\"}}function q(e){return e.replace(/[.*+?^${}()|[\\]\\\\]/g,\"\\\\$&\")}function w(e){var O,D=(e=e||{}).delimiter,I=e.newline,T=e.comments,A=e.step,L=e.preview,F=e.fastMode,z=O=void 0===e.quoteChar?'\"':e.quoteChar;if(void 0!==e.escapeChar&&(z=e.escapeChar),(\"string\"!=typeof D||-1<b.BAD_DELIMITERS.indexOf(D))&&(D=\",\"),T===D)throw new Error(\"Comment character same as delimiter\");!0===T?T=\"#\":(\"string\"!=typeof T||-1<b.BAD_DELIMITERS.indexOf(T))&&(T=!1),\"\\n\"!==I&&\"\\r\"!==I&&\"\\r\\n\"!==I&&(I=\"\\n\");var M=0,j=!1;this.parse=function(a,t,i){if(\"string\"!=typeof a)throw new Error(\"Input must be a string\");var r=a.length,e=D.length,n=I.length,s=T.length,o=U(A),h=[],u=[],f=[],d=M=0;if(!a)return R();if(F||!1!==F&&-1===a.indexOf(O)){for(var l=a.split(I),c=0;c<l.length;c++){if(f=l[c],M+=f.length,c!==l.length-1)M+=I.length;else if(i)return R();if(!T||f.substring(0,s)!==T){if(o){if(h=[],b(f.split(D)),S(),j)return R()}else b(f.split(D));if(L&&L<=c)return h=h.slice(0,L),R(!0)}}return R()}for(var p=a.indexOf(D,M),g=a.indexOf(I,M),_=new RegExp(q(z)+q(O),\"g\"),m=a.indexOf(O,M);;)if(a[M]!==O)if(T&&0===f.length&&a.substring(M,M+s)===T){if(-1===g)return R();M=g+n,g=a.indexOf(I,M),p=a.indexOf(D,M)}else{if(-1!==p&&(p<g||-1===g)){if(!(p<m)){f.push(a.substring(M,p)),M=p+e,p=a.indexOf(D,M);continue}var v=x(p,m,g);if(v&&void 0!==v.nextDelim){p=v.nextDelim,m=v.quoteSearch,f.push(a.substring(M,p)),M=p+e,p=a.indexOf(D,M);continue}}if(-1===g)break;if(f.push(a.substring(M,g)),C(g+n),o&&(S(),j))return R();if(L&&h.length>=L)return R(!0)}else for(m=M,M++;;){if(-1===(m=a.indexOf(O,m+1)))return i||u.push({type:\"Quotes\",code:\"MissingQuotes\",message:\"Quoted field unterminated\",row:h.length,index:M}),E();if(m===r-1)return E(a.substring(M,m).replace(_,O));if(O!==z||a[m+1]!==z){if(O===z||0===m||a[m-1]!==z){-1!==p&&p<m+1&&(p=a.indexOf(D,m+1)),-1!==g&&g<m+1&&(g=a.indexOf(I,m+1));var y=w(-1===g?p:Math.min(p,g));if(a[m+1+y]===D){f.push(a.substring(M,m).replace(_,O)),a[M=m+1+y+e]!==O&&(m=a.indexOf(O,M)),p=a.indexOf(D,M),g=a.indexOf(I,M);break}var k=w(g);if(a.substring(m+1+k,m+1+k+n)===I){if(f.push(a.substring(M,m).replace(_,O)),C(m+1+k+n),p=a.indexOf(D,M),m=a.indexOf(O,M),o&&(S(),j))return R();if(L&&h.length>=L)return R(!0);break}u.push({type:\"Quotes\",code:\"InvalidQuotes\",message:\"Trailing quote on quoted field is malformed\",row:h.length,index:M}),m++}}else m++}return E();function b(e){h.push(e),d=M}function w(e){var t=0;if(-1!==e){var i=a.substring(m+1,e);i&&\"\"===i.trim()&&(t=i.length)}return t}function E(e){return i||(void 0===e&&(e=a.substring(M)),f.push(e),M=r,b(f),o&&S()),R()}function C(e){M=e,b(f),f=[],g=a.indexOf(I,M)}function R(e){return{data:h,errors:u,meta:{delimiter:D,linebreak:I,aborted:j,truncated:!!e,cursor:d+(t||0)}}}function S(){A(R()),h=[],u=[]}function x(e,t,i){var r={nextDelim:void 0,quoteSearch:void 0},n=a.indexOf(O,t+1);if(t<e&&e<n&&(n<i||-1===i)){var s=a.indexOf(D,n);if(-1===s)return r;n<s&&(n=a.indexOf(O,n+1)),r=x(s,n,i)}else r={nextDelim:e,quoteSearch:t};return r}},this.abort=function(){j=!0},this.getCharIndex=function(){return M}}function _(e){var t=e.data,i=a[t.workerId],r=!1;if(t.error)i.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){r=!0,m(t.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:v,resume:v};if(U(i.userStep)){for(var s=0;s<t.results.data.length&&(i.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!r);s++);delete t.results}else U(i.userChunk)&&(i.userChunk(t.results,n,t.file),delete t.results)}t.finished&&!r&&m(t.workerId,t.results)}function m(e,t){var i=a[e];U(i.userComplete)&&i.userComplete(t),i.terminate(),delete a[e]}function v(){throw new Error(\"Not implemented.\")}function E(e){if(\"object\"!=typeof e||null===e)return e;var t=Array.isArray(e)?[]:{};for(var i in e)t[i]=E(e[i]);return t}function y(e,t){return function(){e.apply(t,arguments)}}function U(e){return\"function\"==typeof e}return o&&(f.onmessage=function(e){var t=e.data;void 0===b.WORKER_ID&&t&&(b.WORKER_ID=t.workerId);if(\"string\"==typeof t.input)f.postMessage({workerId:b.WORKER_ID,results:b.parse(t.input,t.config),finished:!0});else if(f.File&&t.input instanceof File||t.input instanceof Object){var i=b.parse(t.input,t.config);i&&f.postMessage({workerId:b.WORKER_ID,results:i,finished:!0})}}),(l.prototype=Object.create(u.prototype)).constructor=l,(c.prototype=Object.create(u.prototype)).constructor=c,(p.prototype=Object.create(p.prototype)).constructor=p,(g.prototype=Object.create(u.prototype)).constructor=g,b});","//\r\n// An iterable that captures an iterator (e.g. from a generator function)\r\n// and caches it to make it resusable \r\n// (iterators or the output of a generator is generally not reusable).\r\n//\r\n\r\nimport { CachedIterator } from '../iterators/cached-iterator';\r\n\r\nexport class CachedIteratorIterable<T> implements Iterable<T> {\r\n\r\n    private cached: T[] = [];\r\n\r\n    constructor(private iterator: Iterator<T>) {\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        return new CachedIterator<T>(this);\r\n    }\r\n\r\n    //\r\n    // Gets from the cache or populates the cache.\r\n    //\r\n    _next(index: number): IteratorResult<T> {\r\n\r\n        if (index >= this.cached.length) {\r\n            // Beyond the cache.\r\n            const result = this.iterator.next();\r\n            if (result.done) {\r\n                // Finished.\r\n                return ({ done: true } as IteratorResult<T>)  // <= explicit cast here!;\r\n            }\r\n\r\n            // Cache result and return it.\r\n            this.cached.push(result.value);\r\n        }\r\n\r\n        return {\r\n            done: false, \r\n            value: this.cached[index],\r\n        };\r\n    }\r\n}\r\n\r\n\r\n","!function(t,n){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=n():\"function\"==typeof define&&define.amd?define(n):t.dayjs_plugin_customParseFormat=n()}(this,function(){\"use strict\";var t,n=/(\\[[^[]*\\])|([-:/.()\\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,e=/\\d\\d/,r=/\\d\\d?/,o=/\\d*[^\\s\\d-:/.()]+/;var s=function(t){return function(n){this[t]=+n}},i=[/[+-]\\d\\d:?\\d\\d/,function(t){var n,e;(this.zone||(this.zone={})).offset=(n=t.match(/([+-]|\\d\\d)/g),0===(e=60*n[1]+ +n[2])?0:\"+\"===n[0]?-e:e)}],a={A:[/[AP]M/,function(t){this.afternoon=\"PM\"===t}],a:[/[ap]m/,function(t){this.afternoon=\"pm\"===t}],S:[/\\d/,function(t){this.milliseconds=100*+t}],SS:[e,function(t){this.milliseconds=10*+t}],SSS:[/\\d{3}/,function(t){this.milliseconds=+t}],s:[r,s(\"seconds\")],ss:[r,s(\"seconds\")],m:[r,s(\"minutes\")],mm:[r,s(\"minutes\")],H:[r,s(\"hours\")],h:[r,s(\"hours\")],HH:[r,s(\"hours\")],hh:[r,s(\"hours\")],D:[r,s(\"day\")],DD:[e,s(\"day\")],Do:[o,function(n){var e=t.ordinal,r=n.match(/\\d+/);if(this.day=r[0],e)for(var o=1;o<=31;o+=1)e(o).replace(/\\[|\\]/g,\"\")===n&&(this.day=o)}],M:[r,s(\"month\")],MM:[e,s(\"month\")],MMM:[o,function(n){var e=t,r=e.months,o=e.monthsShort,s=o?o.findIndex(function(t){return t===n}):r.findIndex(function(t){return t.substr(0,3)===n});if(s<0)throw new Error;this.month=s+1}],MMMM:[o,function(n){var e=t.months.indexOf(n);if(e<0)throw new Error;this.month=e+1}],Y:[/[+-]?\\d+/,s(\"year\")],YY:[e,function(t){t=+t,this.year=t+(t>68?1900:2e3)}],YYYY:[/\\d{4}/,s(\"year\")],Z:i,ZZ:i};var u=function(t,e,r){try{var o=function(t){for(var e=t.match(n),r=e.length,o=0;o<r;o+=1){var s=e[o],i=a[s],u=i&&i[0],f=i&&i[1];e[o]=f?{regex:u,parser:f}:s.replace(/^\\[|\\]$/g,\"\")}return function(t){for(var n={},o=0,s=0;o<r;o+=1){var i=e[o];if(\"string\"==typeof i)s+=i.length;else{var a=i.regex,u=i.parser,f=t.substr(s),h=a.exec(f)[0];u.call(n,h),s+=h.length}}return function(t){var n=t.afternoon;if(void 0!==n){var e=t.hours;n?e<12&&(t.hours+=12):12===e&&(t.hours=0),delete t.afternoon}}(n),n}}(e)(t),s=o.year,i=o.month,u=o.day,f=o.hours,h=o.minutes,d=o.seconds,c=o.milliseconds,m=o.zone;if(m)return new Date(Date.UTC(s,i-1,u,f||0,h||0,d||0,c||0)+60*m.offset*1e3);var l=new Date,v=s||l.getFullYear(),p=i>0?i-1:l.getMonth(),M=u||l.getDate(),y=f||0,D=h||0,g=d||0,Y=c||0;return r?new Date(Date.UTC(v,p,M,y,D,g,Y)):new Date(v,p,M,y,D,g,Y)}catch(t){return new Date(\"\")}};return function(n,e,r){var o=e.prototype,s=o.parse;o.parse=function(n){var e=n.date,o=n.format,i=n.pl,a=n.utc;this.$u=a,o?(t=i?r.Ls[i]:this.$locale(),this.$d=u(e,o,a),this.init(n)):s.call(this,n)}}});\n","//\r\n// An iterator that returns no values.\r\n//\r\n\r\nexport class EmptyIterator implements Iterator<any> {\r\n\r\n    next(): IteratorResult<any> {\r\n        return {\r\n            done: true,\r\n            value: null\r\n        };\r\n    }\r\n}","//\r\n// An iterator that simply counts up from zero.\r\n// This creates the default index in Data-Forge.\r\n//\r\n\r\nexport class CountIterator implements Iterator<number> {\r\n\r\n    index = 0;\r\n\r\n    next(): IteratorResult<number> {\r\n        return {\r\n            done: false,\r\n            value: this.index++\r\n        };\r\n    }\r\n\r\n}","//\r\n// An iterator that can iterate multiple other iterators at once.\r\n// This allows iterators to be composed.\r\n// This is used in Data-Forge to combine iterators for index and values.\r\n//\r\n\r\nexport class MultiIterator implements Iterator<any[]> {\r\n\r\n    iterators: Iterator<any>[];\r\n\r\n    constructor(iterators: Iterator<any>[]) {\r\n        this.iterators = iterators;\r\n    }\r\n\r\n    next(): IteratorResult<any[]> {\r\n\r\n        if (this.iterators.length === 0) {\r\n            return {\r\n                done: true,\r\n                value: [],\r\n            };\r\n        }\r\n\r\n        var multiResult = [];\r\n\r\n        for (const iterator of this.iterators) {\r\n            var result = iterator.next();\r\n            if (result.done) {\r\n                return { \r\n                    done: true,\r\n                    value: [],\r\n                };\r\n            }\r\n\r\n            multiResult.push(result.value);\r\n        }\r\n\r\n        return {\r\n            done: false,\r\n            value: multiResult\r\n        };\r\n    }\r\n\r\n}","//\r\n// An iterator that applies a selector function to each item.\r\n//\r\n\r\nexport type SelectorFn<ValueT, ToT> = (value: ValueT, index: number) => ToT;\r\n\r\nexport class SelectIterator<ValueT, ToT> implements Iterator<ToT> {\r\n\r\n    iterator: Iterator<ValueT>;\r\n    selector: SelectorFn<ValueT, ToT>;\r\n    index = 0;\r\n\r\n    constructor(iterator: Iterator<ValueT>, selector: SelectorFn<ValueT, ToT>) {\r\n        this.iterator = iterator;\r\n        this.selector = selector;\r\n    }\r\n\r\n    next(): IteratorResult<ToT> {\r\n        var result = this.iterator.next();\r\n        if (result.done) {\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<ToT>)  // <= explicit cast here!;\r\n        }\r\n\r\n        return {\r\n            done: false,\r\n            value: this.selector(result.value, this.index++)\r\n        };\r\n    }\r\n}","//\r\n// An iterator that applies a selector function to each item.\r\n//\r\n\r\nexport type SelectorFn<ValueT, ToT> = (value: ValueT, index: number) => Iterable<ToT>;\r\n\r\nexport class SelectManyIterator<ValueT, ToT> implements Iterator<ToT> {\r\n\r\n    iterator: Iterator<ValueT>;\r\n    outputIterator: Iterator<ToT> | null;\r\n    selector: SelectorFn<ValueT, ToT>;\r\n    index = 0;\r\n\r\n    constructor(iterator: Iterator<ValueT>, selector: SelectorFn<ValueT, ToT>) {\r\n        this.iterator = iterator;\r\n        this.selector = selector;\r\n        this.outputIterator = null;\r\n    }\r\n\r\n    next(): IteratorResult<ToT> {     \r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            if (this.outputIterator === null) {\r\n                var result = this.iterator.next();\r\n                if (result.done) {\r\n                    // https://github.com/Microsoft/TypeScript/issues/8938\r\n                    return ({ done: true } as IteratorResult<ToT>)  // <= explicit cast here!;\r\n                }\r\n\r\n                const outputIterable = this.selector(result.value, this.index++);\r\n                this.outputIterator = outputIterable[Symbol.iterator]();\r\n            }\r\n\r\n            var outputResult = this.outputIterator!.next();\r\n            if (outputResult.done) {\r\n                this.outputIterator = null;\r\n                continue;\r\n            }\r\n            else {\r\n                return outputResult;\r\n            }\r\n        }   \r\n    }\r\n}","//\r\n// An iterator that a sequence of elements while a predicate function returns true.\r\n//\r\n\r\nexport class TakeIterator<T> implements Iterator<T> {\r\n\r\n    childIterator: Iterator<T>;\r\n    numElements: number;\r\n\r\n    constructor(childIterator: Iterator<T>, numElements: number) {\r\n        this.childIterator = childIterator;\r\n        this.numElements = numElements;\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n        if (this.numElements <= 0) {\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<T>)  // <= explicit cast here!;\r\n        }\r\n\r\n        --this.numElements;\r\n        return this.childIterator.next();\r\n    }\r\n}","//\r\n// An iterator that takes a sequence of elements while a predicate function returns true.\r\n//\r\n\r\n/**\r\n * A predicate function, returns true or false based on input.\r\n */\r\nexport type PredicateFn<InputT> = (value: InputT) => boolean;\r\n\r\nexport class TakeWhileIterator<T> implements Iterator<T> {\r\n\r\n    childIterator: Iterator<T>;\r\n    predicate: PredicateFn<T>;\r\n    done = false;\r\n\r\n    constructor(childIterator: Iterator<T>, predicate: PredicateFn<T>) {\r\n        this.childIterator = childIterator;\r\n        this.predicate = predicate;\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n        if (!this.done) {\r\n            var result = this.childIterator.next();\r\n            if (result.done) {\r\n                this.done = true;\r\n            }\r\n            else if (this.predicate(result.value)) {\r\n                return result;\r\n            }\r\n            else {\r\n                this.done = true;\r\n            }\r\n        }\r\n\r\n        // https://github.com/Microsoft/TypeScript/issues/8938\r\n        return ({ done: true } as IteratorResult<T>)  // <= explicit cast here!;\r\n    }\r\n}","//\r\n// An iterator that takes elements from a child iterator based on a predicate function.\r\n//\r\n\r\n/**\r\n * A predicate function, returns true or false based on input.\r\n */\r\nexport type PredicateFn<InputT> = (value: InputT) => boolean;\r\n\r\nexport class WhereIterator<T> implements Iterator<T> {\r\n\r\n    childIterator: Iterator<T>;\r\n    predicate: PredicateFn<T>;\r\n\r\n    constructor(childIterator: Iterator<T>, predicate: PredicateFn<T>) {\r\n        this.childIterator = childIterator;\r\n        this.predicate = predicate;\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            var result = this.childIterator.next();\r\n            if (result.done) {\r\n                return result;\r\n            }\r\n\r\n            if (this.predicate(result.value)) {\r\n                // It matches the predicate.\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n}","//\r\n// An iterator that concatenates multiple iterables.\r\n//\r\n\r\nexport class ConcatIterator<T> implements Iterator<T> {\r\n\r\n    iterables: Iterable<Iterable<T>>\r\n    iterator: Iterator<Iterable<T>>;\r\n    curIterator: Iterator<T> | null = null;\r\n\r\n    constructor(iterables: Iterable<Iterable<T>>) {\r\n        this.iterables = iterables;\r\n        this.iterator = iterables[Symbol.iterator]();\r\n        this.moveToNextIterable();\r\n    }\r\n\r\n    //\r\n    // Move onto the next iterable.\r\n    //\r\n    private moveToNextIterable () {\r\n        const nextIterable = this.iterator.next();\r\n        if (nextIterable.done) {\r\n            this.curIterator = null;\r\n        }\r\n        else {\r\n            this.curIterator = nextIterable.value[Symbol.iterator]();\r\n        }        \r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            if (this.curIterator == null) {\r\n                // Finished iterating all sub-iterators.\r\n                // https://github.com/Microsoft/TypeScript/issues/8938\r\n                return ({ done: true } as IteratorResult<T>)  // <= explicit cast here!;\r\n            }\r\n\r\n            const result = this.curIterator.next();\r\n            if (!result.done) {\r\n                return result; // Found a valid result from the current iterable.    \r\n            }\r\n\r\n            // Find the next non empty iterable.\r\n            this.moveToNextIterable();\r\n        }\r\n    }\r\n\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { SeriesWindowIterator } from '../iterators/series-window-iterator';\r\nimport { ISeries, WhichIndex } from '../series';\r\n\r\nexport class SeriesWindowIterable<IndexT, ValueT> implements Iterable<[IndexT,ISeries<IndexT, ValueT>]> {\r\n\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    period: number;\r\n    whichIndex: WhichIndex;\r\n\r\n    constructor(iterable: Iterable<[IndexT, ValueT]>, period: number, whichIndex: WhichIndex) {\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n        this.whichIndex = whichIndex;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<[IndexT,ISeries<IndexT, ValueT>]> {\r\n        return new SeriesWindowIterator(this.iterable, this.period, this.whichIndex);\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { TakeIterable } from '../iterables/take-iterable';\r\nimport { SkipIterable } from '../iterables/skip-iterable';\r\nimport { Series, ISeries, WhichIndex } from '../series';\r\n\r\nexport class SeriesWindowIterator<IndexT, ValueT> implements Iterator<[IndexT,ISeries<IndexT, ValueT>]> {\r\n\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    iterator: Iterator<[IndexT, ValueT]> | undefined;\r\n    period: number;\r\n    whichIndex: WhichIndex;\r\n    \r\n    constructor(iterable: Iterable<[IndexT, ValueT]>, period: number, whichIndex: WhichIndex) {\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n        this.whichIndex = whichIndex;\r\n    }\r\n\r\n    next(): IteratorResult<[IndexT,ISeries<IndexT, ValueT>]> {\r\n\r\n        if (!this.iterator) {\r\n            this.iterator = this.iterable[Symbol.iterator]();\r\n        }\r\n\r\n        const curWindow = [];\r\n\r\n        for (let i = 0; i < this.period; ++i) {\r\n            const curPos = this.iterator.next();\r\n            if (curPos.done) {\r\n                // Underlying iterator is finished.\r\n                break;\r\n            }\r\n            curWindow.push(curPos.value);\r\n        }\r\n\r\n        if (curWindow.length === 0) {\r\n            // Underlying iterator doesn't have required number of elements.\r\n            return ({ done: true } as IteratorResult<[IndexT,ISeries<IndexT, ValueT>]>);\r\n        }\r\n    \r\n        const window = new Series<IndexT, ValueT>({\r\n            pairs: curWindow\r\n        });\r\n\r\n        return {\r\n            //TODO: The way the index is figured out could have much better performance.\r\n            value: [this.whichIndex === WhichIndex.Start ? window.getIndex().first() : window.getIndex().last(), window],\r\n            done: false,\r\n        };\r\n\r\n    }\r\n}","//\r\n// An iterator that zips together each set of elements in child iterables.\r\n//\r\nimport { Series, ISeries } from '../series';\r\n\r\nexport type ZipFn<ValueT, ReturnT> = (input: ISeries<number, ValueT>) => ReturnT;\r\n\r\nexport class ZipIterator<ValueT, ReturnT> implements Iterator<ReturnT> {\r\n\r\n    iterators: Iterator<ValueT>[];\r\n    zipper: ZipFn<ValueT, ReturnT>;\r\n\r\n    constructor(iterables: Iterable<ValueT>[], zipper: ZipFn<ValueT, ReturnT>) {\r\n        this.iterators = iterables.map(iterable => iterable[Symbol.iterator]());\r\n        this.zipper = zipper;\r\n    }\r\n\r\n    next(): IteratorResult<ReturnT> {\r\n        const results = this.iterators.map(iterator => iterator.next());\r\n        for (const result of results) {\r\n            if (result.done) {\r\n                // If any are done we are all done.\r\n                // https://github.com/Microsoft/TypeScript/issues/8938\r\n                return ({ done: true } as IteratorResult<ReturnT>)  // <= explicit cast here!;                \r\n            }\r\n        }\r\n\r\n        const zippedValues = results.map(result => result.value);\r\n        const zipperInput = new Series<number, ValueT>(zippedValues);\r\n        return {\r\n            done: false,\r\n            value: this.zipper(zipperInput)\r\n        };\r\n    }\r\n}","//\r\n// An iterator that iterates the only distinct elements of another iterable.\r\n//\r\n\r\n/**\r\n * A selector function with no index. Transforms a value into another kind of value.\r\n */\r\nexport type SelectorFnNoIndex<FromT, ToT> = (value: FromT) => ToT;\r\n\r\nexport class DistinctIterator<FromT, ToT> implements Iterator<FromT> {\r\n\r\n    iterator: Iterator<FromT>;\r\n    selector?: SelectorFnNoIndex<FromT, ToT>;\r\n    valuesAlreadySeen: Set<any> = new Set<any>();\r\n\r\n    constructor(iterable: Iterable<FromT>, selector?: SelectorFnNoIndex<FromT, ToT>) {\r\n        this.iterator = iterable[Symbol.iterator]();\r\n        this.selector = selector;\r\n    }\r\n\r\n    next(): IteratorResult<FromT> {\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const result = this.iterator.next();\r\n            if (result.done) {\r\n                return ({ done: true } as IteratorResult<FromT>);\r\n            }\r\n\r\n            let potentialOutput: ToT;\r\n            if (this.selector) {\r\n                potentialOutput = this.selector(result.value);\r\n            }\r\n            else {\r\n                potentialOutput = <ToT> <any> result.value;\r\n            }\r\n\r\n           \r\n            if (this.valuesAlreadySeen.has(potentialOutput)) {\r\n                // Already seen this value.\r\n                // Skip it and continue to next item.\r\n                continue;\r\n            }\r\n            \r\n            this.valuesAlreadySeen.add(potentialOutput);\r\n            return {\r\n                done: false,\r\n                value: result.value,\r\n            };\r\n        }\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { SeriesRollingWindowIterator } from '../iterators/series-rolling-window-iterator';\r\nimport { ISeries, WhichIndex } from '../series';\r\n\r\nexport class SeriesRollingWindowIterable<IndexT, ValueT> implements Iterable<[IndexT,ISeries<IndexT, ValueT>]> {\r\n\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    period: number;\r\n    whichIndex: WhichIndex;\r\n\r\n    constructor(iterable: Iterable<[IndexT, ValueT]>, period: number, whichIndex: WhichIndex) {\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n        this.whichIndex = whichIndex;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<[IndexT,ISeries<IndexT, ValueT>]> {\r\n        return new SeriesRollingWindowIterator(this.iterable, this.period, this.whichIndex);\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { TakeIterable } from '../iterables/take-iterable';\r\nimport { SkipIterable } from '../iterables/skip-iterable';\r\nimport { Series, ISeries, WhichIndex } from '../series';\r\n\r\nexport class SeriesRollingWindowIterator<IndexT, ValueT> implements Iterator<[IndexT,ISeries<IndexT, ValueT>]> {\r\n\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    iterator: Iterator<[IndexT, ValueT]> | undefined;\r\n    period: number;\r\n    whichIndex: WhichIndex;\r\n    curWindow: [IndexT, ValueT][] | undefined; \r\n    \r\n    constructor(iterable: Iterable<[IndexT, ValueT]>, period: number, whichIndex: WhichIndex) {\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n        this.whichIndex = whichIndex;\r\n    }\r\n\r\n    next(): IteratorResult<[IndexT,ISeries<IndexT, ValueT>]> {\r\n\r\n        if (!this.curWindow) {\r\n            this.curWindow = [];\r\n            this.iterator = this.iterable[Symbol.iterator]();\r\n            for (let i = 0; i < this.period; ++i) {\r\n                const curPos = this.iterator.next();\r\n                if (curPos.done) {\r\n                    // Underlying iterator doesn't have required number of elements.\r\n                    return ({ done: true } as IteratorResult<[IndexT,ISeries<IndexT, ValueT>]>);\r\n                }\r\n                this.curWindow.push(curPos.value);\r\n            }\r\n        }\r\n        else {\r\n            this.curWindow.shift(); // Remove first item from window.\r\n            \r\n            const curPos = this.iterator!.next();\r\n            if (curPos.done) {\r\n                // Underlying iterator doesn't have enough elements left.\r\n                return ({ done: true } as IteratorResult<[IndexT,ISeries<IndexT, ValueT>]>);\r\n            }\r\n\r\n            this.curWindow.push(curPos.value); // Add next item to window.\r\n        }\r\n\r\n        const window = new Series<IndexT, ValueT>({\r\n            pairs: this.curWindow\r\n        });\r\n\r\n        return {\r\n            //TODO: The way the index is figured out could have much better performance.\r\n            value: [this.whichIndex === WhichIndex.Start ? window.getIndex().first() : window.getIndex().last(), window],\r\n            done: false,\r\n        };\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { SeriesVariableWindowIterator, ComparerFn } from '../iterators/series-variable-window-iterator';\r\nimport { ISeries } from '../series';\r\n\r\nexport class SeriesVariableWindowIterable<IndexT, ValueT> implements Iterable<ISeries<IndexT, ValueT>> {\r\n\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    comparer: ComparerFn<ValueT>;\r\n\r\n    constructor(iterable: Iterable<[IndexT, ValueT]>, comparer: ComparerFn<ValueT>) {\r\n        this.iterable = iterable;\r\n        this.comparer = comparer;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<ISeries<IndexT, ValueT>> {\r\n        return new SeriesVariableWindowIterator(this.iterable, this.comparer);\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { TakeIterable } from '../iterables/take-iterable';\r\nimport { SkipIterable } from '../iterables/skip-iterable';\r\nimport { Series, ISeries } from '../series';\r\n\r\n/**\r\n * Compares to values and returns true if they are equivalent.\r\n */\r\nexport type ComparerFn<ValueT> = (a: ValueT, b: ValueT) => boolean;\r\n\r\nexport class SeriesVariableWindowIterator<IndexT, ValueT> implements Iterator<ISeries<IndexT, ValueT>> {\r\n\r\n    iterator: Iterator<[IndexT, ValueT]>;\r\n    nextValue: IteratorResult<[IndexT, ValueT]>;\r\n    comparer: ComparerFn<ValueT>\r\n    \r\n    constructor(iterable: Iterable<[IndexT, ValueT]>, comparer: ComparerFn<ValueT>) {\r\n        this.iterator = iterable[Symbol.iterator]();\r\n        this.nextValue = this.iterator.next();\r\n        this.comparer = comparer;\r\n    }\r\n\r\n    next(): IteratorResult<ISeries<IndexT, ValueT>> {\r\n\r\n        if (this.nextValue.done) {\r\n            // Nothing more to read.\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<ISeries<IndexT, ValueT>>)  // <= explicit cast here!;\r\n        }\r\n\r\n        const pairs = [\r\n            this.nextValue.value,\r\n        ];\r\n\r\n        let prevValue = this.nextValue.value;\r\n\r\n        // Pull values until there is one that doesn't compare.\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            this.nextValue = this.iterator.next();\r\n            if (this.nextValue.done) {\r\n                break; // No more values.\r\n            }\r\n\r\n            if (!this.comparer(prevValue[1], this.nextValue.value[1])) {\r\n                prevValue = this.nextValue.value;\r\n                break; // Doesn't compare. Start a new window.\r\n            }      \r\n            \r\n            pairs.push(this.nextValue.value);\r\n            prevValue = this.nextValue.value;\r\n        }\r\n\r\n        const window = new Series<IndexT, ValueT>({\r\n            pairs: pairs,\r\n        });\r\n\r\n        return {\r\n            value: window,\r\n            done: false,\r\n        };\r\n    }\r\n}","//\r\n// An iterator to extact an element from an array.\r\n//\r\n\r\nexport class ExtractElementIterator implements Iterator<any> {\r\n\r\n    iterator: Iterator<any[]>;\r\n    extractIndex: number;\r\n\r\n    constructor(iterator: Iterator<any[]>, extractIndex: number) {\r\n        this.iterator = iterator;\r\n        this.extractIndex = extractIndex;\r\n    }\r\n\r\n    next(): IteratorResult<any> {\r\n        \r\n        var result = this.iterator.next();\r\n        if (result.done) {\r\n            return result;\r\n        }\r\n        else {\r\n            return {\r\n                done: false,\r\n                value: result.value[this.extractIndex]\r\n            };\r\n        }\r\n    }\r\n}","//\r\n// An iterator that skips a number of values.\r\n//\r\n\r\nexport class SkipIterator implements Iterator<any> {\r\n\r\n    iterator: Iterator<any>;\r\n    numValues: number;\r\n\r\n    constructor(iterator: Iterator<any>, numValues: number) {\r\n        this.iterator = iterator;\r\n        this.numValues = numValues;\r\n    }\r\n\r\n    next(): IteratorResult<any> {\r\n        while (--this.numValues >= 0) {\r\n            var result = this.iterator.next();\r\n            if (result.done) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return this.iterator.next();\r\n    }\r\n}","//\r\n// An iterator that skips a sequence of elements while a predicate function returns true.\r\n//\r\n\r\n/**\r\n * A predicate function, returns true or false based on input.\r\n */\r\nexport type PredicateFn<InputT> = (value: InputT) => boolean;\r\n\r\nexport class SkipWhileIterator<T> implements Iterator<T> {\r\n\r\n    childIterator: Iterator<T>;\r\n    predicate: PredicateFn<T>;\r\n    doneSkipping = false;\r\n\r\n    constructor(childIterator: Iterator<T>, predicate: PredicateFn<T>) {\r\n        this.childIterator = childIterator;\r\n        this.predicate = predicate;\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            var result = this.childIterator.next();\r\n            if (result.done) {\r\n                return result; // Done.\r\n            }\r\n\r\n            if (!this.doneSkipping && this.predicate(result.value)) {\r\n                continue; // Skip it.\r\n            }\r\n\r\n            // It matches, stop skipping.\r\n            this.doneSkipping = true;\r\n            return result;\r\n        }\r\n    }\r\n}","\"use strict\"\n\nvar defaults = require('defaults')\nvar combining = require('./combining')\n\nvar DEFAULTS = {\n  nul: 0,\n  control: 0\n}\n\nmodule.exports = function wcwidth(str) {\n  return wcswidth(str, DEFAULTS)\n}\n\nmodule.exports.config = function(opts) {\n  opts = defaults(opts || {}, DEFAULTS)\n  return function wcwidth(str) {\n    return wcswidth(str, opts)\n  }\n}\n\n/*\n *  The following functions define the column width of an ISO 10646\n *  character as follows:\n *  - The null character (U+0000) has a column width of 0.\n *  - Other C0/C1 control characters and DEL will lead to a return value\n *    of -1.\n *  - Non-spacing and enclosing combining characters (general category\n *    code Mn or Me in the\n *    Unicode database) have a column width of 0.\n *  - SOFT HYPHEN (U+00AD) has a column width of 1.\n *  - Other format characters (general category code Cf in the Unicode\n *    database) and ZERO WIDTH\n *    SPACE (U+200B) have a column width of 0.\n *  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)\n *    have a column width of 0.\n *  - Spacing characters in the East Asian Wide (W) or East Asian\n *    Full-width (F) category as\n *    defined in Unicode Technical Report #11 have a column width of 2.\n *  - All remaining characters (including all printable ISO 8859-1 and\n *    WGL4 characters, Unicode control characters, etc.) have a column\n *    width of 1.\n *  This implementation assumes that characters are encoded in ISO 10646.\n*/\n\nfunction wcswidth(str, opts) {\n  if (typeof str !== 'string') return wcwidth(str, opts)\n\n  var s = 0\n  for (var i = 0; i < str.length; i++) {\n    var n = wcwidth(str.charCodeAt(i), opts)\n    if (n < 0) return -1\n    s += n\n  }\n\n  return s\n}\n\nfunction wcwidth(ucs, opts) {\n  // test for 8-bit control characters\n  if (ucs === 0) return opts.nul\n  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0)) return opts.control\n\n  // binary search in table of non-spacing characters\n  if (bisearch(ucs)) return 0\n\n  // if we arrive here, ucs is not a combining or C0/C1 control character\n  return 1 +\n      (ucs >= 0x1100 &&\n       (ucs <= 0x115f ||                       // Hangul Jamo init. consonants\n        ucs == 0x2329 || ucs == 0x232a ||\n        (ucs >= 0x2e80 && ucs <= 0xa4cf &&\n         ucs != 0x303f) ||                     // CJK ... Yi\n        (ucs >= 0xac00 && ucs <= 0xd7a3) ||    // Hangul Syllables\n        (ucs >= 0xf900 && ucs <= 0xfaff) ||    // CJK Compatibility Ideographs\n        (ucs >= 0xfe10 && ucs <= 0xfe19) ||    // Vertical forms\n        (ucs >= 0xfe30 && ucs <= 0xfe6f) ||    // CJK Compatibility Forms\n        (ucs >= 0xff00 && ucs <= 0xff60) ||    // Fullwidth Forms\n        (ucs >= 0xffe0 && ucs <= 0xffe6) ||\n        (ucs >= 0x20000 && ucs <= 0x2fffd) ||\n        (ucs >= 0x30000 && ucs <= 0x3fffd)));\n}\n\nfunction bisearch(ucs) {\n  var min = 0\n  var max = combining.length - 1\n  var mid\n\n  if (ucs < combining[0][0] || ucs > combining[max][1]) return false\n\n  while (max >= min) {\n    mid = Math.floor((min + max) / 2)\n    if (ucs > combining[mid][1]) min = mid + 1\n    else if (ucs < combining[mid][0]) max = mid - 1\n    else return true\n  }\n\n  return false\n}\n","var clone = require('clone');\n\nmodule.exports = function(options, defaults) {\n  options = options || {};\n\n  Object.keys(defaults).forEach(function(key) {\n    if (typeof options[key] === 'undefined') {\n      options[key] = clone(defaults[key]);\n    }\n  });\n\n  return options;\n};","var clone = (function() {\n'use strict';\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\nfunction clone(parent, circular, depth, prototype) {\n  var filter;\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    filter = circular.filter;\n    circular = circular.circular\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth == 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n};\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n};\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n};\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n};\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n};\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","module.exports = [\n    [ 0x0300, 0x036F ], [ 0x0483, 0x0486 ], [ 0x0488, 0x0489 ],\n    [ 0x0591, 0x05BD ], [ 0x05BF, 0x05BF ], [ 0x05C1, 0x05C2 ],\n    [ 0x05C4, 0x05C5 ], [ 0x05C7, 0x05C7 ], [ 0x0600, 0x0603 ],\n    [ 0x0610, 0x0615 ], [ 0x064B, 0x065E ], [ 0x0670, 0x0670 ],\n    [ 0x06D6, 0x06E4 ], [ 0x06E7, 0x06E8 ], [ 0x06EA, 0x06ED ],\n    [ 0x070F, 0x070F ], [ 0x0711, 0x0711 ], [ 0x0730, 0x074A ],\n    [ 0x07A6, 0x07B0 ], [ 0x07EB, 0x07F3 ], [ 0x0901, 0x0902 ],\n    [ 0x093C, 0x093C ], [ 0x0941, 0x0948 ], [ 0x094D, 0x094D ],\n    [ 0x0951, 0x0954 ], [ 0x0962, 0x0963 ], [ 0x0981, 0x0981 ],\n    [ 0x09BC, 0x09BC ], [ 0x09C1, 0x09C4 ], [ 0x09CD, 0x09CD ],\n    [ 0x09E2, 0x09E3 ], [ 0x0A01, 0x0A02 ], [ 0x0A3C, 0x0A3C ],\n    [ 0x0A41, 0x0A42 ], [ 0x0A47, 0x0A48 ], [ 0x0A4B, 0x0A4D ],\n    [ 0x0A70, 0x0A71 ], [ 0x0A81, 0x0A82 ], [ 0x0ABC, 0x0ABC ],\n    [ 0x0AC1, 0x0AC5 ], [ 0x0AC7, 0x0AC8 ], [ 0x0ACD, 0x0ACD ],\n    [ 0x0AE2, 0x0AE3 ], [ 0x0B01, 0x0B01 ], [ 0x0B3C, 0x0B3C ],\n    [ 0x0B3F, 0x0B3F ], [ 0x0B41, 0x0B43 ], [ 0x0B4D, 0x0B4D ],\n    [ 0x0B56, 0x0B56 ], [ 0x0B82, 0x0B82 ], [ 0x0BC0, 0x0BC0 ],\n    [ 0x0BCD, 0x0BCD ], [ 0x0C3E, 0x0C40 ], [ 0x0C46, 0x0C48 ],\n    [ 0x0C4A, 0x0C4D ], [ 0x0C55, 0x0C56 ], [ 0x0CBC, 0x0CBC ],\n    [ 0x0CBF, 0x0CBF ], [ 0x0CC6, 0x0CC6 ], [ 0x0CCC, 0x0CCD ],\n    [ 0x0CE2, 0x0CE3 ], [ 0x0D41, 0x0D43 ], [ 0x0D4D, 0x0D4D ],\n    [ 0x0DCA, 0x0DCA ], [ 0x0DD2, 0x0DD4 ], [ 0x0DD6, 0x0DD6 ],\n    [ 0x0E31, 0x0E31 ], [ 0x0E34, 0x0E3A ], [ 0x0E47, 0x0E4E ],\n    [ 0x0EB1, 0x0EB1 ], [ 0x0EB4, 0x0EB9 ], [ 0x0EBB, 0x0EBC ],\n    [ 0x0EC8, 0x0ECD ], [ 0x0F18, 0x0F19 ], [ 0x0F35, 0x0F35 ],\n    [ 0x0F37, 0x0F37 ], [ 0x0F39, 0x0F39 ], [ 0x0F71, 0x0F7E ],\n    [ 0x0F80, 0x0F84 ], [ 0x0F86, 0x0F87 ], [ 0x0F90, 0x0F97 ],\n    [ 0x0F99, 0x0FBC ], [ 0x0FC6, 0x0FC6 ], [ 0x102D, 0x1030 ],\n    [ 0x1032, 0x1032 ], [ 0x1036, 0x1037 ], [ 0x1039, 0x1039 ],\n    [ 0x1058, 0x1059 ], [ 0x1160, 0x11FF ], [ 0x135F, 0x135F ],\n    [ 0x1712, 0x1714 ], [ 0x1732, 0x1734 ], [ 0x1752, 0x1753 ],\n    [ 0x1772, 0x1773 ], [ 0x17B4, 0x17B5 ], [ 0x17B7, 0x17BD ],\n    [ 0x17C6, 0x17C6 ], [ 0x17C9, 0x17D3 ], [ 0x17DD, 0x17DD ],\n    [ 0x180B, 0x180D ], [ 0x18A9, 0x18A9 ], [ 0x1920, 0x1922 ],\n    [ 0x1927, 0x1928 ], [ 0x1932, 0x1932 ], [ 0x1939, 0x193B ],\n    [ 0x1A17, 0x1A18 ], [ 0x1B00, 0x1B03 ], [ 0x1B34, 0x1B34 ],\n    [ 0x1B36, 0x1B3A ], [ 0x1B3C, 0x1B3C ], [ 0x1B42, 0x1B42 ],\n    [ 0x1B6B, 0x1B73 ], [ 0x1DC0, 0x1DCA ], [ 0x1DFE, 0x1DFF ],\n    [ 0x200B, 0x200F ], [ 0x202A, 0x202E ], [ 0x2060, 0x2063 ],\n    [ 0x206A, 0x206F ], [ 0x20D0, 0x20EF ], [ 0x302A, 0x302F ],\n    [ 0x3099, 0x309A ], [ 0xA806, 0xA806 ], [ 0xA80B, 0xA80B ],\n    [ 0xA825, 0xA826 ], [ 0xFB1E, 0xFB1E ], [ 0xFE00, 0xFE0F ],\n    [ 0xFE20, 0xFE23 ], [ 0xFEFF, 0xFEFF ], [ 0xFFF9, 0xFFFB ],\n    [ 0x10A01, 0x10A03 ], [ 0x10A05, 0x10A06 ], [ 0x10A0C, 0x10A0F ],\n    [ 0x10A38, 0x10A3A ], [ 0x10A3F, 0x10A3F ], [ 0x1D167, 0x1D169 ],\n    [ 0x1D173, 0x1D182 ], [ 0x1D185, 0x1D18B ], [ 0x1D1AA, 0x1D1AD ],\n    [ 0x1D242, 0x1D244 ], [ 0xE0001, 0xE0001 ], [ 0xE0020, 0xE007F ],\n    [ 0xE0100, 0xE01EF ]\n]\n","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { DataFrameWindowIterator } from '../iterators/dataframe-window-iterator';\r\nimport { IDataFrame } from '../dataframe';\r\n\r\nexport class DataFrameWindowIterable<IndexT, ValueT> implements Iterable<IDataFrame<IndexT, ValueT>> {\r\n\r\n    columnNames: Iterable<string>;\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    period: number;\r\n\r\n    constructor(columnNames: Iterable<string>, iterable: Iterable<[IndexT, ValueT]>, period: number) {\r\n        this.columnNames = columnNames;\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<IDataFrame<IndexT, ValueT>> {\r\n        return new DataFrameWindowIterator(this.columnNames, this.iterable, this.period);\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { TakeIterable } from '../iterables/take-iterable';\r\nimport { SkipIterable } from '../iterables/skip-iterable';\r\nimport { DataFrame, IDataFrame } from '../dataframe';\r\n\r\nexport class DataFrameWindowIterator<IndexT, ValueT> implements Iterator<IDataFrame<IndexT, ValueT>> {\r\n\r\n    columnNames: Iterable<string>;\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    iterator: Iterator<[IndexT, ValueT]> | undefined;\r\n    period: number;\r\n    \r\n    constructor(columnNames: Iterable<string>, iterable: Iterable<[IndexT, ValueT]>, period: number) {\r\n        this.columnNames = columnNames;\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n    }\r\n\r\n    next(): IteratorResult<IDataFrame<IndexT, ValueT>> {\r\n\r\n        if (!this.iterator) {\r\n            this.iterator = this.iterable[Symbol.iterator]();\r\n        }\r\n        \r\n        const curWindow = [];\r\n\r\n        for (let i = 0; i < this.period; ++i) {\r\n            const curPos = this.iterator.next();\r\n            if (curPos.done) {\r\n                // Underlying iterator is finished.\r\n                break;\r\n            }\r\n            curWindow.push(curPos.value);\r\n        }\r\n\r\n        if (curWindow.length === 0) {\r\n            // Underlying iterator doesn't have required number of elements.\r\n            return ({ done: true } as IteratorResult<IDataFrame<IndexT, ValueT>>);\r\n        }\r\n    \r\n        const window = new DataFrame<IndexT, ValueT>({\r\n            columnNames: this.columnNames,\r\n            pairs: curWindow\r\n        });\r\n\r\n        return {\r\n            value: window,\r\n            done: false,\r\n        };\r\n    }\r\n}","//\r\n// An iterable that iterates the rows of a CSV file.\r\n//\r\n\r\nimport { CsvRowsIterator } from '../iterators/csv-rows-iterator';\r\n\r\nexport class CsvRowsIterable implements Iterable<any> {\r\n\r\n    columnNames: Iterable<string>;\r\n    rows: Iterable<any>;\r\n\r\n    constructor(columnNames: Iterable<string>, rows: Iterable<any>) {\r\n        this.columnNames = columnNames;\r\n        this.rows = rows;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        return new CsvRowsIterator(this.columnNames, this.rows);\r\n    }\r\n}","//\r\n// An iterator that iterates the rows of a CSV file.\r\n//\r\n\r\nexport class CsvRowsIterator implements Iterator<any> {\r\n\r\n    columnNames: string[];\r\n    rowsIterator: Iterator<any>;\r\n    index = 0;\r\n\r\n    constructor(columnNames: Iterable<string>, rowsIterable: Iterable<any>) {\r\n        this.columnNames = Array.from(columnNames);\r\n        this.rowsIterator = rowsIterable[Symbol.iterator]();\r\n    }\r\n\r\n    next(): IteratorResult<any> {\r\n\r\n        var result = this.rowsIterator.next();\r\n        if (result.done) {\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<any>)  // <= explicit cast here!;\r\n        }\r\n\r\n        var row = result.value;\r\n        var value: any = {};\r\n        for (var cellIndex = 0; cellIndex < this.columnNames.length; ++cellIndex) {\r\n            var columnName = this.columnNames[cellIndex];\r\n            value[columnName] = row[cellIndex];\r\n        }\r\n\r\n        return {\r\n            done: false, \r\n            value: value,\r\n        };\r\n   }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { DataFrameRollingWindowIterator } from '../iterators/dataframe-rolling-window-iterator';\r\nimport { IDataFrame } from '../dataframe';\r\n\r\nexport class DataFrameRollingWindowIterable<IndexT, ValueT> implements Iterable<IDataFrame<IndexT, ValueT>> {\r\n\r\n    columnNames: Iterable<string>;\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    period: number;\r\n\r\n    constructor(columnNames: Iterable<string>, iterable: Iterable<[IndexT, ValueT]>, period: number) {\r\n        this.columnNames = columnNames;\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<IDataFrame<IndexT, ValueT>> {\r\n        return new DataFrameRollingWindowIterator(this.columnNames, this.iterable, this.period);\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { TakeIterable } from '../iterables/take-iterable';\r\nimport { SkipIterable } from '../iterables/skip-iterable';\r\nimport { DataFrame, IDataFrame } from '../dataframe';\r\n\r\nexport class DataFrameRollingWindowIterator<IndexT, ValueT> implements Iterator<IDataFrame<IndexT, ValueT>> {\r\n\r\n    columnNames: Iterable<string>;\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    iterator: Iterator<[IndexT, ValueT]> | undefined;\r\n    period: number;\r\n    curWindow: [IndexT, ValueT][] | undefined; \r\n    \r\n    constructor(columnNames: Iterable<string>, iterable: Iterable<[IndexT, ValueT]>, period: number) {\r\n        this.columnNames = columnNames;\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n    }\r\n\r\n    next(): IteratorResult<IDataFrame<IndexT, ValueT>> {\r\n\r\n        if (!this.curWindow) {\r\n            this.curWindow = [];\r\n            this.iterator = this.iterable[Symbol.iterator]();\r\n            for (let i = 0; i < this.period; ++i) {\r\n                const curPos = this.iterator.next();\r\n                if (curPos.done) {\r\n                    // Underlying iterator doesn't have required number of elements.\r\n                    return ({ done: true } as IteratorResult<IDataFrame<IndexT, ValueT>>);\r\n                }\r\n                this.curWindow.push(curPos.value);\r\n            }\r\n        }\r\n        else {\r\n            this.curWindow.shift(); // Remove first item from window.\r\n            \r\n            const curPos = this.iterator!.next();\r\n            if (curPos.done) {\r\n                // Underlying iterator doesn't have enough elements left.\r\n                return ({ done: true } as IteratorResult<IDataFrame<IndexT, ValueT>>);\r\n            }\r\n\r\n            this.curWindow.push(curPos.value); // Add next item to window.\r\n        }\r\n\r\n        const window = new DataFrame<IndexT, ValueT>({\r\n            columnNames: this.columnNames,\r\n            pairs: this.curWindow\r\n        });\r\n\r\n        return {\r\n            value: window,\r\n            done: false,\r\n        };\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { DataFrameVariableWindowIterator, ComparerFn } from '../iterators/dataframe-variable-window-iterator';\r\nimport { IDataFrame } from '../dataframe';\r\n\r\nexport class DataFrameVariableWindowIterable<IndexT, ValueT> implements Iterable<IDataFrame<IndexT, ValueT>> {\r\n\r\n    columnNames: Iterable<string>;\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    comparer: ComparerFn<ValueT>;\r\n\r\n    constructor(columnNames: Iterable<string>, iterable: Iterable<[IndexT, ValueT]>, comparer: ComparerFn<ValueT>) {\r\n        this.columnNames = columnNames;\r\n        this.iterable = iterable;\r\n        this.comparer = comparer;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<IDataFrame<IndexT, ValueT>> {\r\n        return new DataFrameVariableWindowIterator(this.columnNames, this.iterable, this.comparer);\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { TakeIterable } from '../iterables/take-iterable';\r\nimport { SkipIterable } from '../iterables/skip-iterable';\r\nimport { DataFrame, IDataFrame } from '../dataframe';\r\n\r\n/**\r\n * Compares to values and returns true if they are equivalent.\r\n */\r\nexport type ComparerFn<ValueT> = (a: ValueT, b: ValueT) => boolean;\r\n\r\nexport class DataFrameVariableWindowIterator<IndexT, ValueT> implements Iterator<IDataFrame<IndexT, ValueT>> {\r\n\r\n    columnNames: Iterable<string>;\r\n    iterator: Iterator<[IndexT, ValueT]>;\r\n    nextValue: IteratorResult<[IndexT, ValueT]>;\r\n    comparer: ComparerFn<ValueT>\r\n    \r\n    constructor(columnNames: Iterable<string>, iterable: Iterable<[IndexT, ValueT]>, comparer: ComparerFn<ValueT>) {\r\n        this.columnNames = columnNames;\r\n        this.iterator = iterable[Symbol.iterator]();\r\n        this.nextValue = this.iterator.next();\r\n        this.comparer = comparer;\r\n    }\r\n\r\n    next(): IteratorResult<IDataFrame<IndexT, ValueT>> {\r\n\r\n        if (this.nextValue.done) {\r\n            // Nothing more to read.\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<IDataFrame<IndexT, ValueT>>)  // <= explicit cast here!;\r\n        }\r\n\r\n        const pairs = [\r\n            this.nextValue.value,\r\n        ];\r\n\r\n        let prevValue = this.nextValue.value;\r\n\r\n        // Pull values until there is one that doesn't compare.\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            this.nextValue = this.iterator.next();\r\n            if (this.nextValue.done) {\r\n                break; // No more values.\r\n            }\r\n\r\n            if (!this.comparer(prevValue[1], this.nextValue.value[1])) {\r\n                prevValue = this.nextValue.value;   \r\n                break; // Doesn't compare. Start a new window.\r\n            }      \r\n            \r\n            pairs.push(this.nextValue.value);\r\n            prevValue = this.nextValue.value;\r\n        }\r\n\r\n        const window = new DataFrame<IndexT, ValueT>({\r\n            columnNames: this.columnNames,\r\n            pairs: pairs,\r\n        });\r\n\r\n        return {\r\n            value: window,\r\n            done: false,\r\n        };\r\n    }\r\n}","//\r\n// An iterable that iterates the elements repeatedly.\r\n//\r\n\r\nimport { RepeatIterator } from '../iterators/repeat-iterator';\r\n\r\nexport class RepeatIterable<T> implements Iterable<T> {\r\n\r\n    iterable: Iterable<T>;\r\n    count: number;\r\n\r\n    constructor(iterable: Iterable<T>, count: number) {\r\n        this.iterable = iterable\r\n        this.count = count;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        return new RepeatIterator(this.iterable, this.count);\r\n    }\r\n}","//\r\n// An iterator that iterates the elements of an iterable multiple times.\r\n// Implementation similar to https://numpy.org/doc/stable/reference/generated/numpy.repeat.html\r\n//\r\n\r\nexport class RepeatIterator<T> implements Iterator<T> {\r\n\r\n    iterator: Iterator<T>;\r\n    count: number;\r\n    repetition = 0;\r\n    result: IteratorResult<T>;\r\n\r\n    constructor(iterable: Iterable<T>, count: number) {\r\n        this.iterator = iterable[Symbol.iterator]();\r\n        this.count = count;\r\n        this.result = this.iterator.next()\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n\r\n        if (this.count == 0) {\r\n            return ({ done: true } as IteratorResult<T>);\r\n        }\r\n\r\n        if (this.repetition == this.count) {\r\n            this.result = this.iterator.next();\r\n            this.repetition = 0;\r\n        }\r\n\r\n        this.repetition += 1;\r\n\r\n        if (this.result.done) {\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<T>); // <= explicit cast here!;\r\n        }\r\n\r\n        return {\r\n            done: false,\r\n            value: this.result.value\r\n        };\r\n    }\r\n\r\n}","//\r\n// An iterable that iterates the elements repeatedly.\r\n//\r\n\r\nimport { TileIterator } from '../iterators/tile-iterator';\r\n\r\nexport class TileIterable<T> implements Iterable<T> {\r\n\r\n    iterable: Iterable<T>;\r\n    count: number;\r\n\r\n    constructor(iterable: Iterable<T>, count: number) {\r\n        this.iterable = iterable\r\n        this.count = count;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        return new TileIterator(this.iterable, this.count);\r\n    }\r\n}","//\r\n// An iterator that iterates the elements of an iterable multiple times.\r\n// Implementation similar to - https://numpy.org/doc/stable/reference/generated/numpy.tile.html\r\n//\r\n\r\nexport class TileIterator<T> implements Iterator<T> {\r\n\r\n    iterator: Iterator<T>;\r\n    iterable: Iterable<T>;\r\n    count = 0;\r\n    repetition = 0;\r\n    firstIteration = true;\r\n\r\n    constructor(iterable: Iterable<T>, count: number) {\r\n        this.iterable = iterable;\r\n        this.iterator = iterable[Symbol.iterator]();\r\n        this.count = count;\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n\r\n        let result = this.iterator.next();\r\n\r\n        // Return done for empty iterable\r\n        if (this.firstIteration && result.done) {\r\n            return ({ done: true } as IteratorResult<T>);\r\n        }\r\n\r\n        this.firstIteration = false;\r\n\r\n        if (result.done) {\r\n            this.repetition += 1;\r\n            // Reinitialize iterator once iterated completely\r\n            this.iterator = this.iterable[Symbol.iterator]();\r\n            \r\n            result = this.iterator.next();\r\n        }\r\n\r\n        if (this.repetition < this.count) {\r\n            return {\r\n                done: false,\r\n                value: result.value,\r\n            };\r\n        }\r\n        else {\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<T>); // <= explicit cast here!;\r\n        }\r\n    }\r\n\r\n}","//\r\n// An iterable that converts sets of elements in child iterables to a single contiguous array.\r\n//\r\n\r\nimport { RavelIterator } from '../iterators/ravel-iterator';\r\n\r\nexport class RavelIterable<T> implements Iterable<T> {\r\n\r\n    iterables: Iterable<T>[];\r\n\r\n    constructor(iterables: Iterable<T>[]) {\r\n        this.iterables = iterables;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<T> {\r\n        return new RavelIterator<T>(this.iterables);\r\n    }\r\n}","//\r\n// An iterator that produces a contiguous flattened array generated from each set of elements in child iterables.\r\n// Implementation similar to https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html with order 'C'\r\n//\r\n// Note that numpy does not work with arrays of varying lengths. However, the dataforge implementation ignores\r\n// that requirement due to the iterator architecture. Moreover, since the RavelIterator is only used internally\r\n// such cases will not occur.\r\n//\r\n\r\nexport class RavelIterator<T> implements Iterator<T> {\r\n\r\n    iterators: Iterator<T>[];\r\n    iteratorIndex = 0;\r\n\r\n    constructor(iterables: Iterable<T>[]) {\r\n        this.iterators = iterables.map(iterable => iterable[Symbol.iterator]());\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n\r\n        if (this.iterators.length > 0) {\r\n            let result = this.iterators[this.iteratorIndex].next();\r\n\r\n            while (result.done) {\r\n                this.iteratorIndex += 1;\r\n    \r\n                if (this.iteratorIndex < this.iterators.length) {\r\n                    result = this.iterators[this.iteratorIndex].next();\r\n                }\r\n                else {\r\n                    // https://github.com/Microsoft/TypeScript/issues/8938\r\n                    return ({ done: true } as IteratorResult<T>); // <= explicit cast here!;\r\n                }\r\n            }\r\n    \r\n            return {\r\n                done: false,\r\n                value: result.value,\r\n            };\r\n        }\r\n        \r\n        // Return done if empty array passed\r\n        return ({ done: true } as IteratorResult<T>);\r\n    }\r\n\r\n}","//\r\n// An iterable that iterates the column names of lazy dataframe.\r\n//\r\n\r\nimport { ColumnNamesIterator } from '../iterators/column-names-iterator';\r\n\r\nexport class ColumnNamesIterable implements Iterable<string> {\r\n\r\n    values: Iterable<any>;\r\n    considerAllRows: boolean;\r\n\r\n    constructor(values: Iterable<any>, considerAllRows: boolean) {\r\n        this.values = values;\r\n        this.considerAllRows = considerAllRows\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<string> {\r\n        return new ColumnNamesIterator(this.values, this.considerAllRows);\r\n    }\r\n}","//\r\n// An iterator for the column names of lazy dataframe.\r\n//\r\n\r\nimport { ArrayIterator } from './array-iterator';\r\n\r\nexport class ColumnNamesIterator implements Iterator<string> {\r\n\r\n    columnNamesIterator: Iterator<string> | null = null;\r\n    values: Iterable<any>;\r\n    considerAllRows: boolean;\r\n\r\n    constructor(values: Iterable<any>, considerAllRows: boolean) {\r\n        this.values = values;\r\n        this.considerAllRows = considerAllRows;\r\n    }\r\n\r\n    next(): IteratorResult<string> {\r\n        if (this.columnNamesIterator === null)  {\r\n            if (this.considerAllRows) {\r\n                var combinedFields: any = {};\r\n                \r\n                // Check all items.\r\n                for (const value of this.values) {\r\n                    for (const fieldName of Object.keys(value)) {\r\n                        combinedFields[fieldName] = true;\r\n                    }\r\n                }\r\n\r\n                this.columnNamesIterator = new ArrayIterator(Object.keys(combinedFields));\r\n            }\r\n            else {\r\n                // Just check the first item.\r\n                var valuesIterator = this.values[Symbol.iterator]();\r\n                var firstResult = valuesIterator.next();\r\n                if (firstResult.done) {\r\n                    return {\r\n                        done: true,\r\n                        value: \"\",\r\n                    };\r\n                }\r\n\r\n                this.columnNamesIterator = new ArrayIterator(Object.keys(firstResult.value));\r\n            }\r\n        }\r\n\r\n        return this.columnNamesIterator.next();\r\n    }\r\n\r\n}","'use strict';Object.defineProperty(exports,'__esModule',{value:!0}),exports.addCustomTypes=exports.Schema=exports.t=void 0;var _typy=require('./typy'),_typy2=_interopRequireDefault(_typy);function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}var t=function(a,b){return new _typy2.default().t(a,b)},Schema=_typy2.default.Schema,addCustomTypes=function(a){if(t(a).isObject)Object.keys(a).forEach(function(b){if(t(a[b]).isFunction)_typy2.default.prototype.__defineGetter__(b,function(){return a[b](this.input)});else throw new Error('validator '+b+' is not a function')});else throw new Error('validators must be key value pairs')};exports.default=t,exports.t=t,exports.Schema=Schema,exports.addCustomTypes=addCustomTypes;","'use strict';Object.defineProperty(exports,'__esModule',{value:!0});var _typeof='function'==typeof Symbol&&'symbol'==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&'function'==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?'symbol':typeof a},_createClass=function(){function a(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,'value'in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}(),_util=require('./util');function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError('Cannot call a class as a function')}var Typy=function(){function a(){var b=this;_classCallCheck(this,a),this.t=function(a,c){if(b.input=a,b.schemaCheck=null,c)if('string'==typeof c)b.input=(0,_util.getNestedObject)(b.input,c);else{var d=(0,_util.convertSchemaAndGetMatch)(b.input,c);-1===d?(b.schemaCheck=!1,b.input=a):(b.schemaCheck=!0,b.input=d)}return b}}return _createClass(a,[{key:'isValid',get:function get(){return null!==this.schemaCheck&&!0===this.schemaCheck&&null!==this.input&&void 0!==this.input}},{key:'isDefined',get:function get(){return'undefined'!=typeof this.input}},{key:'isUndefined',get:function get(){return'undefined'==typeof this.input}},{key:'isNull',get:function get(){return null===this.input&&'object'===_typeof(this.input)}},{key:'isNullOrUndefined',get:function get(){return!!(this.isNull||this.isUndefined)}},{key:'isBoolean',get:function get(){return _typeof(this.input)===_typeof(!0)}},{key:'isTrue',get:function get(){return!0===this.input}},{key:'isFalse',get:function get(){return!1===this.input}},{key:'isTruthy',get:function get(){return!!this.input}},{key:'isFalsy',get:function get(){return!this.input}},{key:'isObject',get:function get(){return'object'===_typeof(this.input)&&this.input===Object(this.input)&&'[object Array]'!==Object.prototype.toString.call(this.input)}},{key:'isEmptyObject',get:function get(){return!!(this.isObject&&0===Object.keys(this.input).length)}},{key:'isString',get:function get(){return'string'==typeof this.input}},{key:'isEmptyString',get:function get(){return!!(this.isString&&0===this.input.length)}},{key:'isNumber',get:function get(){return!!Number.isFinite(this.input)}},{key:'isArray',get:function get(){return!!Array.isArray(this.input)}},{key:'isEmptyArray',get:function get(){return!!(this.isArray&&0===this.input.length)}},{key:'isFunction',get:function get(){return'function'==typeof this.input}},{key:'safeObject',get:function get(){return this.input}},{key:'safeString',get:function get(){return this.isString?this.input:''}},{key:'safeNumber',get:function get(){return this.isNumber?this.input:0}},{key:'safeBoolean',get:function get(){return!!this.isBoolean&&this.input}},{key:'safeFunction',get:function get(){return this.isFunction?this.input:function(){}}}]),a}();Typy.Schema={Number:1,String:'typy',Boolean:!0,Null:null,Undefined:void 0,Array:[],Function:function Function(){}},exports.default=Typy,module.exports=exports['default'];","'use strict';var _typeof='function'==typeof Symbol&&'symbol'==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&'function'==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?'symbol':typeof a},_arguments=arguments,getNestedObject=function(a,b){if(!(1<_arguments.length&&'string'!=typeof b)){if('undefined'!=typeof a&&'string'==typeof b){var c=/[.\\[\\]'\"]/g,d=b.split(c).filter(function(a){return''!==a});a=d.reduce(function(a,b){return a&&'undefined'!==a[b]?a[b]:void 0},a)}return a}},buildSchema=function(a){if('[object Array]'===Object.prototype.toString.call(a))a.forEach(function(a){return buildSchema(a)});else if('[object Object]'===Object.prototype.toString.call(a))Object.keys(a).forEach(function(b){return buildSchema(a[b])});else return'undefined'==typeof a?'undefined':_typeof(a);return a},getSchemaMatch=function(a,b){var c=!1;if('[object Array]'===Object.prototype.toString.call(a)){if(b.length)for(var d=0;d<a.length;d+=1){if(!getSchemaMatch(a[d],b[d])){c=!1;break}c=!0}else return!0;}else if('[object Object]'===Object.prototype.toString.call(a))for(var e in a){if(!getSchemaMatch(a[e],b[e])){c=!1;break}c=!0}else return('undefined'==typeof b?'undefined':_typeof(b))===('undefined'==typeof a?'undefined':_typeof(a));return c},convertSchemaAndGetMatch=function(a,b){var c=buildSchema(b);return getSchemaMatch(a,c)?a:-1};module.exports={getNestedObject:getNestedObject,buildSchema:buildSchema,getSchemaMatch:getSchemaMatch,convertSchemaAndGetMatch:convertSchemaAndGetMatch};","//\r\n// An iterator that iterates the a \"cached iterator\" iterable.\r\n//\r\n\r\nimport { CachedIteratorIterable } from \"../iterables/cached-iterator-iterable\";\r\n\r\n\r\nexport class CachedIterator<T> implements Iterator<T> {\r\n\r\n    private index = 0;\r\n\r\n    constructor(private iterable: CachedIteratorIterable<T>) {\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n        return this.iterable._next(this.index++);\r\n    }\r\n\r\n}","/*! @preserve\n * numeral.js\n * version : 2.0.6\n * author : Adam Draper\n * license : MIT\n * http://adamwdraper.github.com/Numeral-js/\n */\n\n(function (global, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        global.numeral = factory();\n    }\n}(this, function () {\n    /************************************\n        Variables\n    ************************************/\n\n    var numeral,\n        _,\n        VERSION = '2.0.6',\n        formats = {},\n        locales = {},\n        defaults = {\n            currentLocale: 'en',\n            zeroFormat: null,\n            nullFormat: null,\n            defaultFormat: '0,0',\n            scalePercentBy100: true\n        },\n        options = {\n            currentLocale: defaults.currentLocale,\n            zeroFormat: defaults.zeroFormat,\n            nullFormat: defaults.nullFormat,\n            defaultFormat: defaults.defaultFormat,\n            scalePercentBy100: defaults.scalePercentBy100\n        };\n\n\n    /************************************\n        Constructors\n    ************************************/\n\n    // Numeral prototype object\n    function Numeral(input, number) {\n        this._input = input;\n\n        this._value = number;\n    }\n\n    numeral = function(input) {\n        var value,\n            kind,\n            unformatFunction,\n            regexp;\n\n        if (numeral.isNumeral(input)) {\n            value = input.value();\n        } else if (input === 0 || typeof input === 'undefined') {\n            value = 0;\n        } else if (input === null || _.isNaN(input)) {\n            value = null;\n        } else if (typeof input === 'string') {\n            if (options.zeroFormat && input === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {\n                value = null;\n            } else {\n                for (kind in formats) {\n                    regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;\n\n                    if (regexp && input.match(regexp)) {\n                        unformatFunction = formats[kind].unformat;\n\n                        break;\n                    }\n                }\n\n                unformatFunction = unformatFunction || numeral._.stringToNumber;\n\n                value = unformatFunction(input);\n            }\n        } else {\n            value = Number(input)|| null;\n        }\n\n        return new Numeral(input, value);\n    };\n\n    // version number\n    numeral.version = VERSION;\n\n    // compare numeral object\n    numeral.isNumeral = function(obj) {\n        return obj instanceof Numeral;\n    };\n\n    // helper functions\n    numeral._ = _ = {\n        // formats numbers separators, decimals places, signs, abbreviations\n        numberToFormat: function(value, format, roundingFunction) {\n            var locale = locales[numeral.options.currentLocale],\n                negP = false,\n                optDec = false,\n                leadingCount = 0,\n                abbr = '',\n                trillion = 1000000000000,\n                billion = 1000000000,\n                million = 1000000,\n                thousand = 1000,\n                decimal = '',\n                neg = false,\n                abbrForce, // force abbreviation\n                abs,\n                min,\n                max,\n                power,\n                int,\n                precision,\n                signed,\n                thousands,\n                output;\n\n            // make sure we never format a null value\n            value = value || 0;\n\n            abs = Math.abs(value);\n\n            // see if we should use parentheses for negative number or if we should prefix with a sign\n            // if both are present we default to parentheses\n            if (numeral._.includes(format, '(')) {\n                negP = true;\n                format = format.replace(/[\\(|\\)]/g, '');\n            } else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {\n                signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;\n                format = format.replace(/[\\+|\\-]/g, '');\n            }\n\n            // see if abbreviation is wanted\n            if (numeral._.includes(format, 'a')) {\n                abbrForce = format.match(/a(k|m|b|t)?/);\n\n                abbrForce = abbrForce ? abbrForce[1] : false;\n\n                // check for space before abbreviation\n                if (numeral._.includes(format, ' a')) {\n                    abbr = ' ';\n                }\n\n                format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');\n\n                if (abs >= trillion && !abbrForce || abbrForce === 't') {\n                    // trillion\n                    abbr += locale.abbreviations.trillion;\n                    value = value / trillion;\n                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === 'b') {\n                    // billion\n                    abbr += locale.abbreviations.billion;\n                    value = value / billion;\n                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === 'm') {\n                    // million\n                    abbr += locale.abbreviations.million;\n                    value = value / million;\n                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === 'k') {\n                    // thousand\n                    abbr += locale.abbreviations.thousand;\n                    value = value / thousand;\n                }\n            }\n\n            // check for optional decimals\n            if (numeral._.includes(format, '[.]')) {\n                optDec = true;\n                format = format.replace('[.]', '.');\n            }\n\n            // break number and format\n            int = value.toString().split('.')[0];\n            precision = format.split('.')[1];\n            thousands = format.indexOf(',');\n            leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;\n\n            if (precision) {\n                if (numeral._.includes(precision, '[')) {\n                    precision = precision.replace(']', '');\n                    precision = precision.split('[');\n                    decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);\n                } else {\n                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);\n                }\n\n                int = decimal.split('.')[0];\n\n                if (numeral._.includes(decimal, '.')) {\n                    decimal = locale.delimiters.decimal + decimal.split('.')[1];\n                } else {\n                    decimal = '';\n                }\n\n                if (optDec && Number(decimal.slice(1)) === 0) {\n                    decimal = '';\n                }\n            } else {\n                int = numeral._.toFixed(value, 0, roundingFunction);\n            }\n\n            // check abbreviation again after rounding\n            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {\n                int = String(Number(int) / 1000);\n\n                switch (abbr) {\n                    case locale.abbreviations.thousand:\n                        abbr = locale.abbreviations.million;\n                        break;\n                    case locale.abbreviations.million:\n                        abbr = locale.abbreviations.billion;\n                        break;\n                    case locale.abbreviations.billion:\n                        abbr = locale.abbreviations.trillion;\n                        break;\n                }\n            }\n\n\n            // format number\n            if (numeral._.includes(int, '-')) {\n                int = int.slice(1);\n                neg = true;\n            }\n\n            if (int.length < leadingCount) {\n                for (var i = leadingCount - int.length; i > 0; i--) {\n                    int = '0' + int;\n                }\n            }\n\n            if (thousands > -1) {\n                int = int.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + locale.delimiters.thousands);\n            }\n\n            if (format.indexOf('.') === 0) {\n                int = '';\n            }\n\n            output = int + decimal + (abbr ? abbr : '');\n\n            if (negP) {\n                output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');\n            } else {\n                if (signed >= 0) {\n                    output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');\n                } else if (neg) {\n                    output = '-' + output;\n                }\n            }\n\n            return output;\n        },\n        // unformats numbers separators, decimals places, signs, abbreviations\n        stringToNumber: function(string) {\n            var locale = locales[options.currentLocale],\n                stringOriginal = string,\n                abbreviations = {\n                    thousand: 3,\n                    million: 6,\n                    billion: 9,\n                    trillion: 12\n                },\n                abbreviation,\n                value,\n                i,\n                regexp;\n\n            if (options.zeroFormat && string === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {\n                value = null;\n            } else {\n                value = 1;\n\n                if (locale.delimiters.decimal !== '.') {\n                    string = string.replace(/\\./g, '').replace(locale.delimiters.decimal, '.');\n                }\n\n                for (abbreviation in abbreviations) {\n                    regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\\\)|(\\\\' + locale.currency.symbol + ')?(?:\\\\))?)?$');\n\n                    if (stringOriginal.match(regexp)) {\n                        value *= Math.pow(10, abbreviations[abbreviation]);\n                        break;\n                    }\n                }\n\n                // check for negative number\n                value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;\n\n                // remove non numbers\n                string = string.replace(/[^0-9\\.]+/g, '');\n\n                value *= Number(string);\n            }\n\n            return value;\n        },\n        isNaN: function(value) {\n            return typeof value === 'number' && isNaN(value);\n        },\n        includes: function(string, search) {\n            return string.indexOf(search) !== -1;\n        },\n        insert: function(string, subString, start) {\n            return string.slice(0, start) + subString + string.slice(start);\n        },\n        reduce: function(array, callback /*, initialValue*/) {\n            if (this === null) {\n                throw new TypeError('Array.prototype.reduce called on null or undefined');\n            }\n\n            if (typeof callback !== 'function') {\n                throw new TypeError(callback + ' is not a function');\n            }\n\n            var t = Object(array),\n                len = t.length >>> 0,\n                k = 0,\n                value;\n\n            if (arguments.length === 3) {\n                value = arguments[2];\n            } else {\n                while (k < len && !(k in t)) {\n                    k++;\n                }\n\n                if (k >= len) {\n                    throw new TypeError('Reduce of empty array with no initial value');\n                }\n\n                value = t[k++];\n            }\n            for (; k < len; k++) {\n                if (k in t) {\n                    value = callback(value, t[k], k, t);\n                }\n            }\n            return value;\n        },\n        /**\n         * Computes the multiplier necessary to make x >= 1,\n         * effectively eliminating miscalculations caused by\n         * finite precision.\n         */\n        multiplier: function (x) {\n            var parts = x.toString().split('.');\n\n            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);\n        },\n        /**\n         * Given a variable number of arguments, returns the maximum\n         * multiplier that must be used to normalize an operation involving\n         * all of them.\n         */\n        correctionFactor: function () {\n            var args = Array.prototype.slice.call(arguments);\n\n            return args.reduce(function(accum, next) {\n                var mn = _.multiplier(next);\n                return accum > mn ? accum : mn;\n            }, 1);\n        },\n        /**\n         * Implementation of toFixed() that treats floats more like decimals\n         *\n         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n         * problems for accounting- and finance-related software.\n         */\n        toFixed: function(value, maxDecimals, roundingFunction, optionals) {\n            var splitValue = value.toString().split('.'),\n                minDecimals = maxDecimals - (optionals || 0),\n                boundedPrecision,\n                optionalsRegExp,\n                power,\n                output;\n\n            // Use the smallest precision value possible to avoid errors from floating point representation\n            if (splitValue.length === 2) {\n              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);\n            } else {\n              boundedPrecision = minDecimals;\n            }\n\n            power = Math.pow(10, boundedPrecision);\n\n            // Multiply up by precision, round accurately, then divide and use native toFixed():\n            output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);\n\n            if (optionals > maxDecimals - boundedPrecision) {\n                optionalsRegExp = new RegExp('\\\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');\n                output = output.replace(optionalsRegExp, '');\n            }\n\n            return output;\n        }\n    };\n\n    // avaliable options\n    numeral.options = options;\n\n    // avaliable formats\n    numeral.formats = formats;\n\n    // avaliable formats\n    numeral.locales = locales;\n\n    // This function sets the current locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    numeral.locale = function(key) {\n        if (key) {\n            options.currentLocale = key.toLowerCase();\n        }\n\n        return options.currentLocale;\n    };\n\n    // This function provides access to the loaded locale data.  If\n    // no arguments are passed in, it will simply return the current\n    // global locale object.\n    numeral.localeData = function(key) {\n        if (!key) {\n            return locales[options.currentLocale];\n        }\n\n        key = key.toLowerCase();\n\n        if (!locales[key]) {\n            throw new Error('Unknown locale : ' + key);\n        }\n\n        return locales[key];\n    };\n\n    numeral.reset = function() {\n        for (var property in defaults) {\n            options[property] = defaults[property];\n        }\n    };\n\n    numeral.zeroFormat = function(format) {\n        options.zeroFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numeral.nullFormat = function (format) {\n        options.nullFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numeral.defaultFormat = function(format) {\n        options.defaultFormat = typeof(format) === 'string' ? format : '0.0';\n    };\n\n    numeral.register = function(type, name, format) {\n        name = name.toLowerCase();\n\n        if (this[type + 's'][name]) {\n            throw new TypeError(name + ' ' + type + ' already registered.');\n        }\n\n        this[type + 's'][name] = format;\n\n        return format;\n    };\n\n\n    numeral.validate = function(val, culture) {\n        var _decimalSep,\n            _thousandSep,\n            _currSymbol,\n            _valArray,\n            _abbrObj,\n            _thousandRegEx,\n            localeData,\n            temp;\n\n        //coerce val to string\n        if (typeof val !== 'string') {\n            val += '';\n\n            if (console.warn) {\n                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);\n            }\n        }\n\n        //trim whitespaces from either sides\n        val = val.trim();\n\n        //if val is just digits return true\n        if (!!val.match(/^\\d+$/)) {\n            return true;\n        }\n\n        //if val is empty return false\n        if (val === '') {\n            return false;\n        }\n\n        //get the decimal and thousands separator from numeral.localeData\n        try {\n            //check if the culture is understood by numeral. if not, default it to current locale\n            localeData = numeral.localeData(culture);\n        } catch (e) {\n            localeData = numeral.localeData(numeral.locale());\n        }\n\n        //setup the delimiters and currency symbol based on culture/locale\n        _currSymbol = localeData.currency.symbol;\n        _abbrObj = localeData.abbreviations;\n        _decimalSep = localeData.delimiters.decimal;\n        if (localeData.delimiters.thousands === '.') {\n            _thousandSep = '\\\\.';\n        } else {\n            _thousandSep = localeData.delimiters.thousands;\n        }\n\n        // validating currency symbol\n        temp = val.match(/^[^\\d]+/);\n        if (temp !== null) {\n            val = val.substr(1);\n            if (temp[0] !== _currSymbol) {\n                return false;\n            }\n        }\n\n        //validating abbreviation symbol\n        temp = val.match(/[^\\d]+$/);\n        if (temp !== null) {\n            val = val.slice(0, -1);\n            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {\n                return false;\n            }\n        }\n\n        _thousandRegEx = new RegExp(_thousandSep + '{2}');\n\n        if (!val.match(/[^\\d.,]/g)) {\n            _valArray = val.split(_decimalSep);\n            if (_valArray.length > 2) {\n                return false;\n            } else {\n                if (_valArray.length < 2) {\n                    return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx));\n                } else {\n                    if (_valArray[0].length === 1) {\n                        return ( !! _valArray[0].match(/^\\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\\d+$/));\n                    } else {\n                        return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\\d+$/));\n                    }\n                }\n            }\n        }\n\n        return false;\n    };\n\n\n    /************************************\n        Numeral Prototype\n    ************************************/\n\n    numeral.fn = Numeral.prototype = {\n        clone: function() {\n            return numeral(this);\n        },\n        format: function(inputString, roundingFunction) {\n            var value = this._value,\n                format = inputString || options.defaultFormat,\n                kind,\n                output,\n                formatFunction;\n\n            // make sure we have a roundingFunction\n            roundingFunction = roundingFunction || Math.round;\n\n            // format based on value\n            if (value === 0 && options.zeroFormat !== null) {\n                output = options.zeroFormat;\n            } else if (value === null && options.nullFormat !== null) {\n                output = options.nullFormat;\n            } else {\n                for (kind in formats) {\n                    if (format.match(formats[kind].regexps.format)) {\n                        formatFunction = formats[kind].format;\n\n                        break;\n                    }\n                }\n\n                formatFunction = formatFunction || numeral._.numberToFormat;\n\n                output = formatFunction(value, format, roundingFunction);\n            }\n\n            return output;\n        },\n        value: function() {\n            return this._value;\n        },\n        input: function() {\n            return this._input;\n        },\n        set: function(value) {\n            this._value = Number(value);\n\n            return this;\n        },\n        add: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n\n            function cback(accum, curr, currI, O) {\n                return accum + Math.round(corrFactor * curr);\n            }\n\n            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;\n\n            return this;\n        },\n        subtract: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n\n            function cback(accum, curr, currI, O) {\n                return accum - Math.round(corrFactor * curr);\n            }\n\n            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;\n\n            return this;\n        },\n        multiply: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);\n            }\n\n            this._value = _.reduce([this._value, value], cback, 1);\n\n            return this;\n        },\n        divide: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);\n            }\n\n            this._value = _.reduce([this._value, value], cback);\n\n            return this;\n        },\n        difference: function(value) {\n            return Math.abs(numeral(this._value).subtract(value).value());\n        }\n    };\n\n    /************************************\n        Default Locale && Format\n    ************************************/\n\n    numeral.register('locale', 'en', {\n        delimiters: {\n            thousands: ',',\n            decimal: '.'\n        },\n        abbreviations: {\n            thousand: 'k',\n            million: 'm',\n            billion: 'b',\n            trillion: 't'\n        },\n        ordinal: function(number) {\n            var b = number % 10;\n            return (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n        },\n        currency: {\n            symbol: '$'\n        }\n    });\n\n    \n\n(function() {\n        numeral.register('format', 'bps', {\n            regexps: {\n                format: /(BPS)/,\n                unformat: /(BPS)/\n            },\n            format: function(value, format, roundingFunction) {\n                var space = numeral._.includes(format, ' BPS') ? ' ' : '',\n                    output;\n\n                value = value * 10000;\n\n                // check for space before BPS\n                format = format.replace(/\\s?BPS/, '');\n\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n\n                if (numeral._.includes(output, ')')) {\n                    output = output.split('');\n\n                    output.splice(-1, 0, space + 'BPS');\n\n                    output = output.join('');\n                } else {\n                    output = output + space + 'BPS';\n                }\n\n                return output;\n            },\n            unformat: function(string) {\n                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);\n            }\n        });\n})();\n\n\n(function() {\n        var decimal = {\n            base: 1000,\n            suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n        },\n        binary = {\n            base: 1024,\n            suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']\n        };\n\n    var allSuffixes =  decimal.suffixes.concat(binary.suffixes.filter(function (item) {\n            return decimal.suffixes.indexOf(item) < 0;\n        }));\n        var unformatRegex = allSuffixes.join('|');\n        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)\n        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';\n\n    numeral.register('format', 'bytes', {\n        regexps: {\n            format: /([0\\s]i?b)/,\n            unformat: new RegExp(unformatRegex)\n        },\n        format: function(value, format, roundingFunction) {\n            var output,\n                bytes = numeral._.includes(format, 'ib') ? binary : decimal,\n                suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '',\n                power,\n                min,\n                max;\n\n            // check for space before\n            format = format.replace(/\\s?i?b/, '');\n\n            for (power = 0; power <= bytes.suffixes.length; power++) {\n                min = Math.pow(bytes.base, power);\n                max = Math.pow(bytes.base, power + 1);\n\n                if (value === null || value === 0 || value >= min && value < max) {\n                    suffix += bytes.suffixes[power];\n\n                    if (min > 0) {\n                        value = value / min;\n                    }\n\n                    break;\n                }\n            }\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            return output + suffix;\n        },\n        unformat: function(string) {\n            var value = numeral._.stringToNumber(string),\n                power,\n                bytesMultiplier;\n\n            if (value) {\n                for (power = decimal.suffixes.length - 1; power >= 0; power--) {\n                    if (numeral._.includes(string, decimal.suffixes[power])) {\n                        bytesMultiplier = Math.pow(decimal.base, power);\n\n                        break;\n                    }\n\n                    if (numeral._.includes(string, binary.suffixes[power])) {\n                        bytesMultiplier = Math.pow(binary.base, power);\n\n                        break;\n                    }\n                }\n\n                value *= (bytesMultiplier || 1);\n            }\n\n            return value;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'currency', {\n        regexps: {\n            format: /(\\$)/\n        },\n        format: function(value, format, roundingFunction) {\n            var locale = numeral.locales[numeral.options.currentLocale],\n                symbols = {\n                    before: format.match(/^([\\+|\\-|\\(|\\s|\\$]*)/)[0],\n                    after: format.match(/([\\+|\\-|\\)|\\s|\\$]*)$/)[0]\n                },\n                output,\n                symbol,\n                i;\n\n            // strip format of spaces and $\n            format = format.replace(/\\s?\\$\\s?/, '');\n\n            // format the number\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            // update the before and after based on value\n            if (value >= 0) {\n                symbols.before = symbols.before.replace(/[\\-\\(]/, '');\n                symbols.after = symbols.after.replace(/[\\-\\)]/, '');\n            } else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {\n                symbols.before = '-' + symbols.before;\n            }\n\n            // loop through each before symbol\n            for (i = 0; i < symbols.before.length; i++) {\n                symbol = symbols.before[i];\n\n                switch (symbol) {\n                    case '$':\n                        output = numeral._.insert(output, locale.currency.symbol, i);\n                        break;\n                    case ' ':\n                        output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);\n                        break;\n                }\n            }\n\n            // loop through each after symbol\n            for (i = symbols.after.length - 1; i >= 0; i--) {\n                symbol = symbols.after[i];\n\n                switch (symbol) {\n                    case '$':\n                        output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));\n                        break;\n                    case ' ':\n                        output = i === symbols.after.length - 1 ? output + ' ' : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));\n                        break;\n                }\n            }\n\n\n            return output;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'exponential', {\n        regexps: {\n            format: /(e\\+|e-)/,\n            unformat: /(e\\+|e-)/\n        },\n        format: function(value, format, roundingFunction) {\n            var output,\n                exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0',\n                parts = exponential.split('e');\n\n            format = format.replace(/e[\\+|\\-]{1}0/, '');\n\n            output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);\n\n            return output + 'e' + parts[1];\n        },\n        unformat: function(string) {\n            var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'),\n                value = Number(parts[0]),\n                power = Number(parts[1]);\n\n            power = numeral._.includes(string, 'e-') ? power *= -1 : power;\n\n            function cback(accum, curr, currI, O) {\n                var corrFactor = numeral._.correctionFactor(accum, curr),\n                    num = (accum * corrFactor) * (curr * corrFactor) / (corrFactor * corrFactor);\n                return num;\n            }\n\n            return numeral._.reduce([value, Math.pow(10, power)], cback, 1);\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'ordinal', {\n        regexps: {\n            format: /(o)/\n        },\n        format: function(value, format, roundingFunction) {\n            var locale = numeral.locales[numeral.options.currentLocale],\n                output,\n                ordinal = numeral._.includes(format, ' o') ? ' ' : '';\n\n            // check for space before\n            format = format.replace(/\\s?o/, '');\n\n            ordinal += locale.ordinal(value);\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            return output + ordinal;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'percentage', {\n        regexps: {\n            format: /(%)/,\n            unformat: /(%)/\n        },\n        format: function(value, format, roundingFunction) {\n            var space = numeral._.includes(format, ' %') ? ' ' : '',\n                output;\n\n            if (numeral.options.scalePercentBy100) {\n                value = value * 100;\n            }\n\n            // check for space before %\n            format = format.replace(/\\s?\\%/, '');\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            if (numeral._.includes(output, ')')) {\n                output = output.split('');\n\n                output.splice(-1, 0, space + '%');\n\n                output = output.join('');\n            } else {\n                output = output + space + '%';\n            }\n\n            return output;\n        },\n        unformat: function(string) {\n            var number = numeral._.stringToNumber(string);\n            if (numeral.options.scalePercentBy100) {\n                return number * 0.01;\n            }\n            return number;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'time', {\n        regexps: {\n            format: /(:)/,\n            unformat: /(:)/\n        },\n        format: function(value, format, roundingFunction) {\n            var hours = Math.floor(value / 60 / 60),\n                minutes = Math.floor((value - (hours * 60 * 60)) / 60),\n                seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));\n\n            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);\n        },\n        unformat: function(string) {\n            var timeArray = string.split(':'),\n                seconds = 0;\n\n            // turn hours and minutes into seconds and add them all up\n            if (timeArray.length === 3) {\n                // hours\n                seconds = seconds + (Number(timeArray[0]) * 60 * 60);\n                // minutes\n                seconds = seconds + (Number(timeArray[1]) * 60);\n                // seconds\n                seconds = seconds + Number(timeArray[2]);\n            } else if (timeArray.length === 2) {\n                // minutes\n                seconds = seconds + (Number(timeArray[0]) * 60);\n                // seconds\n                seconds = seconds + Number(timeArray[1]);\n            }\n            return Number(seconds);\n        }\n    });\n})();\n\nreturn numeral;\n}));\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n"],"sourceRoot":""}